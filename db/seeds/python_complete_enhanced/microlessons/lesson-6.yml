slug: lesson-6
title: Lesson 6
sequence_order: 6
estimated_minutes: 2
difficulty: easy
key_concepts: []
content_md: "# Microlesson \U0001F680\n\n# Production GraphQL\n\n    ## Apollo Server\
  \ Setup\n\n    Apollo Server is the industry-standard GraphQL server for Node.js.\n\
  \n    ### Basic Production Setup\n\n    ```javascript\n    const { ApolloServer\
  \ } = require('apollo-server-express');\n    const express = require('express');\n\
  \    const helmet = require('helmet');\n    const cors = require('cors');\n    const\
  \ compression = require('compression');\n    const { createServer } = require('http');\n\
  \n    const app = express();\n\n    // Security middleware\n    app.use(helmet({\n\
  \      contentSecurityPolicy: false,\n      crossOriginEmbedderPolicy: false\n \
  \   }));\n\n    // CORS\n    app.use(cors({\n      origin: process.env.ALLOWED_ORIGINS?.split(',')\
  \ || '*',\n      credentials: true\n    }));\n\n    // Compression\n    app.use(compression());\n\
  \n    // Health check endpoint\n    app.get('/health', (req, res) => {\n      res.json({\
  \ status: 'healthy', timestamp: new Date().toISOString() });\n    });\n\n    //\
  \ Create Apollo Server\n    const server = new ApolloServer({\n      typeDefs,\n\
  \      resolvers,\n      context: async ({ req }) => ({\n        db,\n        user:\
  \ req.user,\n        loaders: createLoaders(db)\n      }),\n\n      // Production\
  \ settings\n      introspection: process.env.NODE_ENV !== 'production',\n      playground:\
  \ process.env.NODE_ENV !== 'production',\n\n      // Error handling\n      formatError:\
  \ (error) => {\n        // Log error\n        console.error('GraphQL Error:', error);\n\
  \n        // Don't expose internal errors in production\n        if (process.env.NODE_ENV\
  \ === 'production') {\n          // Remove stack traces\n          delete error.extensions?.exception;\n\
  \        }\n\n        return error;\n      },\n\n      // Performance monitoring\n\
  \      plugins: [\n        {\n          requestDidStart() {\n            const start\
  \ = Date.now();\n            return {\n              willSendResponse({ response\
  \ }) {\n                const duration = Date.now() - start;\n                console.log(\\\
  `Query took \\${duration}ms\\`);\n              }\n            };\n          }\n\
  \        }\n      ]\n    });\n\n    server.applyMiddleware({ app, path: '/graphql'\
  \ });\n\n    const httpServer = createServer(app);\n    server.installSubscriptionHandlers(httpServer);\n\
  \n    const PORT = process.env.PORT || 4000;\n    httpServer.listen(PORT, () =>\
  \ {\n      console.log(\\`\U0001F680 Server ready at http://localhost:\\${PORT}\\\
  ${server.graphqlPath}\\`);\n      console.log(\\`\U0001F50C Subscriptions ready\
  \ at ws://localhost:\\${PORT}\\${server.subscriptionsPath}\\`);\n    });\n    ```\n\
  \n    ## GraphQL with TypeScript\n\n    ### Type-Safe Schema\n\n    ```typescript\n\
  \    // types.ts\n    export interface User {\n      id: string;\n      name: string;\n\
  \      email: string;\n      role: Role;\n      createdAt: Date;\n      updatedAt:\
  \ Date;\n    }\n\n    export interface Post {\n      id: string;\n      title: string;\n\
  \      content: string;\n      authorId: string;\n      published: boolean;\n  \
  \    createdAt: Date;\n      updatedAt: Date;\n    }\n\n    export enum Role {\n\
  \      ADMIN = 'ADMIN',\n      USER = 'USER',\n      MODERATOR = 'MODERATOR'\n \
  \   }\n\n    export interface Context {\n      db: Database;\n      user: User |\
  \ null;\n      loaders: {\n        user: DataLoader<string, User>;\n        post:\
  \ DataLoader<string, Post>;\n      };\n    }\n\n    export interface CreatePostInput\
  \ {\n      title: string;\n      content: string;\n      tags?: string[];\n    \
  \  published?: boolean;\n    }\n    ```\n\n    ### Type-Safe Resolvers\n\n    ```typescript\n\
  \    import { IResolvers } from '@graphql-tools/utils';\n    import { Context, User,\
  \ Post, CreatePostInput } from './types';\n\n    export const resolvers: IResolvers<any,\
  \ Context> = {\n      Query: {\n        me: (parent, args, context): User | null\
  \ => {\n          return context.user;\n        },\n\n        user: async (\n  \
  \        parent,\n          args: { id: string },\n          context\n        ):\
  \ Promise<User | null> => {\n          return await context.loaders.user.load(args.id);\n\
  \        },\n\n        posts: async (\n          parent,\n          args: { limit?:\
  \ number; offset?: number },\n          context\n        ): Promise<Post[]> => {\n\
  \          const limit = args.limit || 10;\n          const offset = args.offset\
  \ || 0;\n\n          return await context.db.posts\n            .limit(limit)\n\
  \            .offset(offset)\n            .orderBy('createdAt', 'desc');\n     \
  \   }\n      },\n\n      Mutation: {\n        createPost: async (\n          parent,\n\
  \          args: { input: CreatePostInput },\n          context\n        ): Promise<Post>\
  \ => {\n          if (!context.user) {\n            throw new Error('Not authenticated');\n\
  \          }\n\n          const { input } = args;\n          const post = await\
  \ context.db.posts.create({\n            ...input,\n            authorId: context.user.id,\n\
  \            published: input.published ?? false\n          });\n\n          return\
  \ post;\n        }\n      },\n\n      // Field resolvers with types\n      User:\
  \ {\n        posts: async (parent: User, args, context): Promise<Post[]> => {\n\
  \          return await context.db.posts.where({ authorId: parent.id });\n     \
  \   }\n      },\n\n      Post: {\n        author: async (parent: Post, args, context):\
  \ Promise<User> => {\n          return await context.loaders.user.load(parent.authorId);\n\
  \        }\n      }\n    };\n    ```\n\n    ### Code Generation\n\n    **Use GraphQL\
  \ Code Generator for automatic type generation**\n\n    ```bash\n    npm install\
  \ -D @graphql-codegen/cli @graphql-codegen/typescript @graphql-codegen/typescript-resolvers\n\
  \    ```\n\n    ```yaml\n    # codegen.yml\n    schema: \"./schema.graphql\"\n \
  \   generates:\n      ./src/generated/graphql.ts:\n        plugins:\n          -\
  \ typescript\n          - typescript-resolvers\n        config:\n          contextType:\
  \ \"../types#Context\"\n          mappers:\n            User: \"../types#User\"\n\
  \            Post: \"../types#Post\"\n    ```\n\n    ```bash\n    # Generate types\n\
  \    npx graphql-codegen\n    ```\n\n    ## Caching Strategies\n\n    ### Response\
  \ Caching\n\n    ```javascript\n    const { ApolloServer } = require('apollo-server-express');\n\
  \    const responseCachePlugin = require('apollo-server-plugin-response-cache');\n\
  \    const { RedisCache } = require('apollo-server-cache-redis');\n\n    const server\
  \ = new ApolloServer({\n      typeDefs,\n      resolvers,\n      cache: new RedisCache({\n\
  \        host: process.env.REDIS_HOST,\n        port: process.env.REDIS_PORT\n \
  \     }),\n      plugins: [\n        responseCachePlugin({\n          // Cache by\
  \ session ID\n          sessionId: (requestContext) => {\n            return requestContext.request.http?.headers.get('session-id')\
  \ || null;\n          }\n        })\n      ]\n    });\n    ```\n\n    **Add cache\
  \ hints to schema:**\n\n    ```graphql\n    type Query {\n      # Cache for 60 seconds\n\
  \      posts: [Post!]! @cacheControl(maxAge: 60)\n\n      # Cache for 300 seconds,\
  \ public\n      publicPosts: [Post!]! @cacheControl(maxAge: 300, scope: PUBLIC)\n\
  \n      # Don't cache\n      me: User @cacheControl(maxAge: 0)\n    }\n\n    type\
  \ Post @cacheControl(maxAge: 60) {\n      id: ID!\n      title: String!\n      #\
  \ Override parent cache\n      viewCount: Int! @cacheControl(maxAge: 10)\n    }\n\
  \    ```\n\n    ### Persisted Queries\n\n    **Reduce bandwidth and improve security**\n\
  \n    ```javascript\n    const { ApolloServer } = require('apollo-server-express');\n\
  \    const { createPersistedQueryLink } = require('@apollo/client/link/persisted-queries');\n\
  \n    const server = new ApolloServer({\n      typeDefs,\n      resolvers,\n   \
  \   persistedQueries: {\n        cache: new RedisCache({\n          host: process.env.REDIS_HOST\n\
  \        })\n      }\n    });\n\n    // Client setup\n    import { createPersistedQueryLink\
  \ } from '@apollo/client/link/persisted-queries';\n    import { sha256 } from 'crypto-hash';\n\
  \n    const link = createPersistedQueryLink({ sha256 }).concat(httpLink);\n\n  \
  \  const client = new ApolloClient({\n      link,\n      cache: new InMemoryCache()\n\
  \    });\n\n    // First request: sends full query + hash\n    // Subsequent requests:\
  \ sends only hash (smaller payload)\n    ```\n\n    ## Query Complexity and Rate\
  \ Limiting\n\n    ### Query Complexity\n\n    **Prevent expensive queries**\n\n\
  \    ```javascript\n    const { createComplexityLimitRule } = require('graphql-validation-complexity');\n\
  \n    const server = new ApolloServer({\n      typeDefs,\n      resolvers,\n   \
  \   validationRules: [\n        createComplexityLimitRule(1000, {\n          onCost:\
  \ (cost) => {\n            console.log('Query cost:', cost);\n          },\n   \
  \       formatErrorMessage: (cost) => {\n            return \\`Query too complex:\
  \ \\${cost}. Maximum allowed: 1000\\`;\n          }\n        })\n      ]\n    });\n\
  \    ```\n\n    **Assign costs to fields:**\n\n    ```graphql\n    type Query {\n\
  \      user(id: ID!): User       # Cost: 1\n      users: [User!]!           # Cost:\
  \ 10 (returns multiple)\n    }\n\n    type User {\n      id: ID!               \
  \    # Cost: 0\n      name: String!             # Cost: 0\n      posts: [Post!]!\
  \           # Cost: 10 (N+1 potential)\n      followers: [User!]!       # Cost:\
  \ 10\n    }\n\n    # This query would have high cost:\n    query {\n      users\
  \ {                   # 10\n        posts {                 # 10 × users\n     \
  \     author {              # 1 × posts × users\n            followers {       \
  \  # 10 × posts × users\n              posts {           # 10 × followers × posts\
  \ × users\n                title\n              }\n            }\n          }\n\
  \        }\n      }\n    }\n    ```\n\n    ### Rate Limiting\n\n    ```javascript\n\
  \    const { RateLimiterRedis } = require('rate-limiter-flexible');\n    const Redis\
  \ = require('ioredis');\n\n    const redisClient = new Redis({\n      host: process.env.REDIS_HOST,\n\
  \      port: process.env.REDIS_PORT\n    });\n\n    const rateLimiter = new RateLimiterRedis({\n\
  \      storeClient: redisClient,\n      points: 100,        // Number of requests\n\
  \      duration: 60,       // Per 60 seconds\n      blockDuration: 60   // Block\
  \ for 60 seconds if exceeded\n    });\n\n    const server = new ApolloServer({\n\
  \      typeDefs,\n      resolvers,\n      context: async ({ req }) => {\n      \
  \  const ip = req.ip || req.connection.remoteAddress;\n\n        try {\n       \
  \   await rateLimiter.consume(ip);\n        } catch (error) {\n          throw new\
  \ Error('Too many requests. Please try again later.');\n        }\n\n        return\
  \ { db, user: req.user };\n      }\n    });\n    ```\n\n    ### Field-Level Rate\
  \ Limiting\n\n    ```javascript\n    const { shield, rule } = require('graphql-shield');\n\
  \n    const isAuthenticated = rule({ cache: 'contextual' })(\n      async (parent,\
  \ args, context) => {\n        return context.user !== null;\n      }\n    );\n\n\
  \    const rateLimit = rule({ cache: 'contextual' })(\n      async (parent, args,\
  \ context) => {\n        const key = \\`rate_limit:\\${context.user?.id || context.ip}\\\
  `;\n\n        try {\n          await rateLimiter.consume(key);\n          return\
  \ true;\n        } catch {\n          return new Error('Rate limit exceeded');\n\
  \        }\n      }\n    );\n\n    const permissions = shield({\n      Query: {\n\
  \        me: isAuthenticated,\n        searchPosts: rateLimit  // Rate limit search\n\
  \      },\n      Mutation: {\n        createPost: isAuthenticated,\n        uploadAvatar:\
  \ rateLimit  // Rate limit uploads\n      }\n    });\n\n    const server = new ApolloServer({\n\
  \      typeDefs,\n      resolvers,\n      middlewares: [permissions]\n    });\n\
  \    ```\n\n    ## Schema Stitching and Federation\n\n    ### Schema Stitching (Legacy)\n\
  \n    **Combine multiple GraphQL schemas**\n\n    ```javascript\n    const { stitchSchemas\
  \ } = require('@graphql-tools/stitch');\n\n    // User service\n    const userSchema\
  \ = makeExecutableSchema({\n      typeDefs: `\n        type User {\n          id:\
  \ ID!\n          name: String!\n        }\n        type Query {\n          user(id:\
  \ ID!): User\n        }\n      `,\n      resolvers: userResolvers\n    });\n\n \
  \   // Post service\n    const postSchema = makeExecutableSchema({\n      typeDefs:\
  \ `\n        type Post {\n          id: ID!\n          title: String!\n        \
  \  authorId: ID!\n        }\n        type Query {\n          post(id: ID!): Post\n\
  \        }\n      `,\n      resolvers: postResolvers\n    });\n\n    // Stitch schemas\
  \ together\n    const stitchedSchema = stitchSchemas({\n      subschemas: [\n  \
  \      { schema: userSchema },\n        { schema: postSchema }\n      ]\n    });\n\
  \    ```\n\n    ### Apollo Federation (Modern)\n\n    **Microservices architecture\
  \ for GraphQL**\n\n    ```javascript\n    // User service (subgraph)\n    const\
  \ { ApolloServer, gql } = require('apollo-server');\n    const { buildFederatedSchema\
  \ } = require('@apollo/federation');\n\n    const typeDefs = gql\\`\n      type\
  \ User @key(fields: \"id\") {\n        id: ID!\n        name: String!\n        email:\
  \ String!\n      }\n\n      extend type Post @key(fields: \"id\") {\n        id:\
  \ ID! @external\n        author: User\n      }\n\n      type Query {\n        user(id:\
  \ ID!): User\n      }\n    \\`;\n\n    const resolvers = {\n      User: {\n    \
  \    __resolveReference(user) {\n          return getUserById(user.id);\n      \
  \  }\n      },\n      Post: {\n        author(post) {\n          return { __typename:\
  \ 'User', id: post.authorId };\n        }\n      }\n    };\n\n    const server =\
  \ new ApolloServer({\n      schema: buildFederatedSchema([{ typeDefs, resolvers\
  \ }])\n    });\n\n    // Post service (subgraph)\n    const typeDefs = gql\\`\n\
  \      type Post @key(fields: \"id\") {\n        id: ID!\n        title: String!\n\
  \        content: String!\n        authorId: ID!\n      }\n\n      type Query {\n\
  \        post(id: ID!): Post\n        posts: [Post!]!\n      }\n    \\`;\n\n   \
  \ // Gateway (combines subgraphs)\n    const { ApolloGateway } = require('@apollo/gateway');\n\
  \n    const gateway = new ApolloGateway({\n      serviceList: [\n        { name:\
  \ 'users', url: 'http://localhost:4001/graphql' },\n        { name: 'posts', url:\
  \ 'http://localhost:4002/graphql' }\n      ]\n    });\n\n    const server = new\
  \ ApolloServer({ gateway });\n    ```\n\n    ## Monitoring and Performance\n\n \
  \   ### Apollo Studio\n\n    ```javascript\n    const { ApolloServer } = require('apollo-server');\n\
  \n    const server = new ApolloServer({\n      typeDefs,\n      resolvers,\n   \
  \   plugins: [\n        require('apollo-server-core').ApolloServerPluginUsageReporting({\n\
  \          sendVariableValues: { all: true },\n          sendHeaders: { all: true\
  \ }\n        })\n      ]\n    });\n\n    // Set APOLLO_KEY environment variable\n\
  \    // Metrics sent to Apollo Studio automatically\n    ```\n\n    ### Custom Metrics\n\
  \n    ```javascript\n    const prometheus = require('prom-client');\n\n    // Define\
  \ metrics\n    const queryDuration = new prometheus.Histogram({\n      name: 'graphql_query_duration_ms',\n\
  \      help: 'GraphQL query duration in milliseconds',\n      labelNames: ['operation_name']\n\
  \    });\n\n    const queryErrors = new prometheus.Counter({\n      name: 'graphql_query_errors_total',\n\
  \      help: 'Total GraphQL query errors',\n      labelNames: ['operation_name',\
  \ 'error_type']\n    });\n\n    const server = new ApolloServer({\n      typeDefs,\n\
  \      resolvers,\n      plugins: [\n        {\n          requestDidStart(requestContext)\
  \ {\n            const start = Date.now();\n            const operationName = requestContext.request.operationName;\n\
  \n            return {\n              willSendResponse() {\n                const\
  \ duration = Date.now() - start;\n                queryDuration.observe({ operation_name:\
  \ operationName }, duration);\n              },\n\n              didEncounterErrors(requestContext)\
  \ {\n                const { errors } = requestContext;\n                errors.forEach(error\
  \ => {\n                  queryErrors.inc({\n                    operation_name:\
  \ operationName,\n                    error_type: error.extensions?.code || 'UNKNOWN'\n\
  \                  });\n                });\n              }\n            };\n \
  \         }\n        }\n      ]\n    });\n\n    // Prometheus metrics endpoint\n\
  \    app.get('/metrics', async (req, res) => {\n      res.set('Content-Type', prometheus.register.contentType);\n\
  \      res.end(await prometheus.register.metrics());\n    });\n    ```\n\n    ###\
  \ Query Performance Logging\n\n    ```javascript\n    const server = new ApolloServer({\n\
  \      typeDefs,\n      resolvers,\n      plugins: [\n        {\n          requestDidStart()\
  \ {\n            return {\n              executionDidStart() {\n               \
  \ return {\n                  willResolveField({ info }) {\n                   \
  \ const start = Date.now();\n                    return () => {\n              \
  \        const duration = Date.now() - start;\n                      if (duration\
  \ > 100) {  // Log slow resolvers\n                        console.warn(\n     \
  \                     \\`Slow resolver: \\${info.parentType}.\\${info.fieldName}\
  \ took \\${duration}ms\\`\n                        );\n                      }\n\
  \                    };\n                  }\n                };\n             \
  \ }\n            };\n          }\n        }\n      ]\n    });\n    ```\n\n    ##\
  \ Production Best Practices\n\n    ### 1. Security\n\n    ```javascript\n    //\
  \ Disable introspection in production\n    introspection: process.env.NODE_ENV !==\
  \ 'production',\n\n    // Depth limiting\n    const depthLimit = require('graphql-depth-limit');\n\
  \    validationRules: [depthLimit(5)],\n\n    // Query whitelisting (persisted queries\
  \ only)\n    persistedQueries: {\n      ttl: 900\n    },\n\n    // Disable playground\
  \ in production\n    playground: false,\n\n    // CORS\n    cors: {\n      origin:\
  \ process.env.ALLOWED_ORIGINS.split(','),\n      credentials: true\n    }\n    ```\n\
  \n    ### 2. Performance\n\n    ```javascript\n    // DataLoader for all relations\n\
  \    loaders: createLoaders(db),\n\n    // Response caching\n    cache: new RedisCache(),\n\
  \n    // Query complexity limits\n    validationRules: [complexityLimit(1000)],\n\
  \n    // Connection pooling\n    db: new Pool({\n      max: 20,\n      idleTimeoutMillis:\
  \ 30000\n    })\n    ```\n\n    ### 3. Error Handling\n\n    ```javascript\n   \
  \ formatError: (error) => {\n      // Log all errors\n      logger.error('GraphQL\
  \ Error:', {\n        message: error.message,\n        path: error.path,\n     \
  \   code: error.extensions?.code\n      });\n\n      // Don't expose internals in\
  \ production\n      if (process.env.NODE_ENV === 'production') {\n        if (error.message.includes('database'))\
  \ {\n          return new Error('Internal server error');\n        }\n      }\n\n\
  \      return error;\n    }\n    ```\n\n    ### 4. Monitoring\n\n    - **Apollo\
  \ Studio** for query analytics\n    - **Prometheus** for metrics\n    - **DataDog/New\
  \ Relic** for APM\n    - **Sentry** for error tracking\n    - **CloudWatch/Grafana**\
  \ for infrastructure\n\n    ### 5. Documentation\n\n    ```graphql\n    \"\"\"\n\
  \    Represents a user in the system\n    \"\"\"\n    type User {\n      \"\"\"\n\
  \      Unique user identifier\n      \"\"\"\n      id: ID!\n\n      \"\"\"\n   \
  \   User's display name\n      \"\"\"\n      name: String!\n\n      \"\"\"\n   \
  \   User's email address (private, only visible to user)\n      \"\"\"\n      email:\
  \ String!\n    }\n\n    type Query {\n      \"\"\"\n      Get a user by ID\n   \
  \   @param id - The user's unique identifier\n      @returns User object or null\
  \ if not found\n      \"\"\"\n      user(id: ID!): User\n    }\n    ```\n\n    ##\
  \ Complete Production Example\n\n    ```javascript\n    require('dotenv').config();\n\
  \    const { ApolloServer } = require('apollo-server-express');\n    const express\
  \ = require('express');\n    const helmet = require('helmet');\n    const compression\
  \ = require('compression');\n    const { createServer } = require('http');\n   \
  \ const { RedisCache } = require('apollo-server-cache-redis');\n    const depthLimit\
  \ = require('graphql-depth-limit');\n    const { createComplexityLimitRule } = require('graphql-validation-complexity');\n\
  \n    const app = express();\n\n    // Middleware\n    app.use(helmet());\n    app.use(compression());\n\
  \    app.use(express.json());\n\n    // Health check\n    app.get('/health', (req,\
  \ res) => {\n      res.json({ status: 'healthy' });\n    });\n\n    // Apollo Server\n\
  \    const server = new ApolloServer({\n      typeDefs,\n      resolvers,\n    \
  \  cache: new RedisCache({\n        host: process.env.REDIS_HOST,\n        port:\
  \ process.env.REDIS_PORT\n      }),\n      context: async ({ req }) => ({\n    \
  \    db,\n        user: req.user,\n        loaders: createLoaders(db)\n      }),\n\
  \      introspection: process.env.NODE_ENV !== 'production',\n      playground:\
  \ process.env.NODE_ENV !== 'production',\n      validationRules: [\n        depthLimit(5),\n\
  \        createComplexityLimitRule(1000)\n      ],\n      formatError: (error) =>\
  \ {\n        console.error(error);\n        if (process.env.NODE_ENV === 'production')\
  \ {\n          delete error.extensions?.exception;\n        }\n        return error;\n\
  \      }\n    });\n\n    server.applyMiddleware({ app });\n\n    const httpServer\
  \ = createServer(app);\n    server.installSubscriptionHandlers(httpServer);\n\n\
  \    const PORT = process.env.PORT || 4000;\n    httpServer.listen(PORT, () => {\n\
  \      console.log(\\`\U0001F680 Server ready at http://localhost:\\${PORT}\\${server.graphqlPath}\\\
  `);\n    });\n    ```\n\n    **Congratulations!** You now have the knowledge to\
  \ build production-ready GraphQL APIs with best practices for performance, security,\
  \ and scalability."
exercises:
- type: mcq
  slug: lesson-6-mcq-1
  sequence_order: 1
  question: What is the primary advantage of Redis storing data in RAM?
  options:
  - Sub-millisecond latency and 100,000+ operations per second
  - Lower cost than disk storage
  - Automatic data backup
  - Better security
  correct_answer_index: 0
  explanation: Redis stores all data in RAM (not disk), which provides sub-millisecond latency and can handle 100,000+ operations per second on commodity hardware. This makes it ideal for caching, real-time analytics, and high-performance applications where speed is critical.
- type: mcq
  slug: lesson-6-mcq-2
  sequence_order: 2
  question: What does the Redis command INCR do?
  options:
  - Atomically increments a numeric value stored at a key by 1
  - Increases the expiration time of a key
  - Increments all keys in the database
  - Inserts a new record
  correct_answer_index: 0
  explanation: INCR atomically increments the integer value of a key by 1. If the key does not exist, it is set to 0 before performing the operation. This is useful for counters, rate limiting, and metrics. The operation is atomic, making it safe in concurrent environments.
- type: mcq
  slug: lesson-6-mcq-3
  sequence_order: 3
  question: Why would you use Redis with an expiration time (ex parameter)?
  options:
  - To automatically remove data after a certain time, useful for caching and sessions
  - To make queries run faster
  - To compress the data
  - To create backups
  correct_answer_index: 0
  explanation: Setting an expiration time (using EX or EXPIRE) automatically removes the key after the specified seconds. This is essential for caching (auto-invalidate stale data), session management (auto-logout), and rate limiting (reset counters). Redis handles cleanup automatically, preventing memory bloat.
objectives:
- Understand core concepts of Production GraphQL
- Apply learned concepts in practical scenarios
- Identify best practices and common patterns
- Recognize trade-offs in different approaches
next_recommended:
- control
- data-structures
