slug: introduction-to-bash-and-shell-scripting
title: Introduction to Bash and Shell Scripting
sequence_order: 1
estimated_minutes: 2
difficulty: easy
key_concepts: []
content_md: "# Introduction to Bash and Shell Scripting \U0001F680\n\n# Introduction\
  \ to Bash and Shell Scripting\n\n    Bash (Bourne Again Shell) is the default shell\
  \ on most Linux and macOS systems. It's both a command-line interface and a powerful\
  \ scripting language.\n\n    ## What is a Shell?\n\n    A **shell** is a program\
  \ that:\n    - Provides an interface between the user and the operating system\n\
  \    - Interprets commands typed by the user\n    - Executes programs and scripts\n\
  \    - Manages input/output redirection\n\n    ### Types of Shells\n\n    | Shell\
  \ | Description |\n    |-------|-------------|\n    | **sh** | Bourne Shell (original)\
  \ |\n    | **bash** | Bourne Again Shell (most popular) |\n    | **zsh** | Z Shell\
  \ (macOS default since Catalina) |\n    | **fish** | Friendly Interactive Shell\
  \ |\n    | **ksh** | Korn Shell |\n    | **csh/tcsh** | C Shell / TENEX C Shell\
  \ |\n\n    ## Why Learn Bash?\n\n    ### 1. Automation\n    - Automate repetitive\
  \ tasks\n    - Schedule jobs with cron\n    - Batch process files\n    - System\
  \ maintenance scripts\n\n    ### 2. System Administration\n    - Manage users and\
  \ permissions\n    - Monitor system resources\n    - Configure services\n    - Deploy\
  \ applications\n\n    ### 3. DevOps & CI/CD\n    - Build and deployment scripts\n\
  \    - Infrastructure automation\n    - Docker and Kubernetes workflows\n    - Git\
  \ hooks\n\n    ### 4. Data Processing\n    - Parse log files\n    - Transform text\
  \ data\n    - ETL pipelines\n    - Report generation\n\n    ## Your First Shell\
  \ Script\n\n    ### Hello World\n\n    Create a file named `hello.sh`:\n\n    ```bash\n\
  \    #!/bin/bash\n    # My first shell script\n\n    echo \"Hello, World!\"\n  \
  \  ```\n\n    ### Make it Executable\n\n    ```bash\n    chmod +x hello.sh\n   \
  \ ```\n\n    ### Run it\n\n    ```bash\n    ./hello.sh\n    # Output: Hello, World!\n\
  \    ```\n\n    ## The Shebang (#!)\n\n    The first line `#!/bin/bash` is called\
  \ the **shebang**:\n\n    ```bash\n    #!/bin/bash         # Use bash\n    #!/bin/sh\
  \           # Use sh (POSIX shell)\n    #!/usr/bin/env bash # Use bash from PATH\
  \ (portable)\n    #!/usr/bin/python3  # Use Python 3\n    ```\n\n    **Best Practice:**\
  \ Use `#!/usr/bin/env bash` for portability.\n\n    ## Basic Commands\n\n    ###\
  \ Navigation\n\n    ```bash\n    pwd          # Print working directory\n    cd\
  \ /path     # Change directory\n    cd ~         # Go to home directory\n    cd\
  \ -         # Go to previous directory\n    ls           # List files\n    ls -la\
  \       # List all files (long format, including hidden)\n    ```\n\n    ### File\
  \ Operations\n\n    ```bash\n    touch file.txt       # Create empty file\n    mkdir\
  \ directory      # Create directory\n    mkdir -p dir1/dir2   # Create nested directories\n\
  \    cp file1 file2       # Copy file\n    cp -r dir1 dir2      # Copy directory\
  \ recursively\n    mv file1 file2       # Move/rename file\n    rm file.txt    \
  \      # Remove file\n    rm -r directory      # Remove directory recursively\n\
  \    rm -rf directory     # Force remove (be careful!)\n    ```\n\n    ### Viewing\
  \ Files\n\n    ```bash\n    cat file.txt         # Display entire file\n    less\
  \ file.txt        # View file page by page (q to quit)\n    head file.txt      \
  \  # Show first 10 lines\n    head -n 5 file.txt   # Show first 5 lines\n    tail\
  \ file.txt        # Show last 10 lines\n    tail -n 5 file.txt   # Show last 5 lines\n\
  \    tail -f log.txt      # Follow file (live updates)\n    ```\n\n    ### Searching\n\
  \n    ```bash\n    grep \"pattern\" file.txt          # Search for pattern\n   \
  \ grep -i \"pattern\" file.txt       # Case-insensitive search\n    grep -r \"pattern\"\
  \ directory/     # Recursive search\n    grep -n \"pattern\" file.txt       # Show\
  \ line numbers\n    find . -name \"*.txt\"             # Find files by name\n  \
  \  find . -type f -mtime -7         # Files modified in last 7 days\n    ```\n\n\
  \    ## Input and Output\n\n    ### Standard Streams\n\n    - **stdin (0)**: Standard\
  \ input (keyboard)\n    - **stdout (1)**: Standard output (terminal)\n    - **stderr\
  \ (2)**: Standard error (terminal)\n\n    ### Output with echo\n\n    ```bash\n\
  \    echo \"Hello\"              # Print to stdout\n    echo -n \"No newline\" \
  \     # No trailing newline\n    echo -e \"Line1\\\\nLine2\"   # Enable escape sequences\n\
  \    ```\n\n    ### Output with printf\n\n    ```bash\n    printf \"Hello, %s!\\\
  \\n\" \"World\"      # Formatted output\n    printf \"%d + %d = %d\\\\n\" 1 2 3\
  \      # Integer formatting\n    printf \"%.2f\\\\n\" 3.14159            # Float\
  \ with 2 decimals\n    ```\n\n    ## Redirection\n\n    ### Output Redirection\n\
  \n    ```bash\n    echo \"Hello\" > file.txt         # Overwrite file\n    echo\
  \ \"World\" >> file.txt        # Append to file\n    command 2> error.log      \
  \      # Redirect stderr\n    command > output.log 2>&1       # Redirect both stdout\
  \ and stderr\n    command &> all.log              # Redirect both (shorthand)\n\
  \    ```\n\n    ### Input Redirection\n\n    ```bash\n    command < input.txt  \
  \           # Read from file\n    cat < file.txt                  # Same as: cat\
  \ file.txt\n    ```\n\n    ### Here Documents\n\n    ```bash\n    cat << EOF\n \
  \   Line 1\n    Line 2\n    EOF\n    # Outputs multiple lines\n    ```\n\n    ###\
  \ Here Strings\n\n    ```bash\n    grep \"pattern\" <<< \"string to search\"\n \
  \   ```\n\n    ## Pipes\n\n    Pipes (`|`) connect the output of one command to\
  \ the input of another:\n\n    ```bash\n    ls -la | grep \".txt\"             \
  \  # List only .txt files\n    cat file.txt | sort | uniq         # Sort and remove\
  \ duplicates\n    ps aux | grep nginx                # Find nginx processes\n  \
  \  cat access.log | wc -l             # Count lines in file\n    ```\n\n    ###\
  \ Common Pipeline Patterns\n\n    ```bash\n    # Count files in directory\n    ls\
  \ | wc -l\n\n    # Top 10 largest files\n    du -sh * | sort -rh | head -10\n\n\
  \    # Find most common words\n    cat file.txt | tr ' ' '\\\\n' | sort | uniq -c\
  \ | sort -rn | head -10\n\n    # Monitor log file in real-time\n    tail -f /var/log/syslog\
  \ | grep error\n    ```\n\n    ## Command Substitution\n\n    Capture command output\
  \ in a variable:\n\n    ```bash\n    # Modern syntax (preferred)\n    current_date=$(date)\n\
  \    file_count=$(ls | wc -l)\n\n    # Old syntax (backticks)\n    current_date=`date`\n\
  \    file_count=`ls | wc -l`\n    ```\n\n    ### Example\n\n    ```bash\n    #!/bin/bash\n\
  \    echo \"Current user: $(whoami)\"\n    echo \"Current directory: $(pwd)\"\n\
  \    echo \"Number of files: $(ls | wc -l)\"\n    ```\n\n    ## Exit Status\n\n\
  \    Every command returns an **exit status** (0 = success, non-zero = error):\n\
  \n    ```bash\n    command\n    echo $?  # Print exit status of last command\n\n\
  \    # Common exit codes\n    # 0   = Success\n    # 1   = General error\n    #\
  \ 2   = Misuse of command\n    # 126 = Command not executable\n    # 127 = Command\
  \ not found\n    # 130 = Ctrl+C pressed\n    ```\n\n    ### Using Exit Status\n\n\
  \    ```bash\n    if ls /nonexistent 2>/dev/null; then\n        echo \"Directory\
  \ exists\"\n    else\n        echo \"Directory does not exist\"\n    fi\n\n    #\
  \ Short-circuit evaluation\n    command1 && command2  # Run command2 only if command1\
  \ succeeds\n    command1 || command2  # Run command2 only if command1 fails\n  \
  \  ```\n\n    ## Common Utilities\n\n    ### Text Processing\n\n    ```bash\n  \
  \  sort file.txt              # Sort lines\n    uniq file.txt              # Remove\
  \ adjacent duplicates\n    cut -d: -f1 /etc/passwd    # Extract first field (delimiter\
  \ :)\n    tr 'a-z' 'A-Z'             # Translate lowercase to uppercase\n    sed\
  \ 's/old/new/g' file     # Replace text\n    awk '{print $1}' file      # Print\
  \ first column\n    ```\n\n    ### File Information\n\n    ```bash\n    wc file.txt\
  \                # Count lines, words, bytes\n    wc -l file.txt             # Count\
  \ lines only\n    du -sh directory           # Disk usage\n    df -h           \
  \           # Filesystem disk space\n    file document.pdf          # Determine\
  \ file type\n    ```\n\n    ### Process Management\n\n    ```bash\n    ps aux  \
  \                   # List all processes\n    top                        # Interactive\
  \ process viewer\n    htop                       # Better alternative to top\n \
  \   kill <PID>                 # Send SIGTERM to process\n    kill -9 <PID>    \
  \          # Force kill process\n    killall process_name       # Kill all matching\
  \ processes\n    ```\n\n    ## Practical Examples\n\n    ### Example 1: Backup Script\n\
  \n    ```bash\n    #!/bin/bash\n    # Simple backup script\n\n    SOURCE=\"/home/user/documents\"\
  \n    DEST=\"/backup\"\n    DATE=$(date +%Y-%m-%d)\n\n    tar -czf \"$DEST/backup-$DATE.tar.gz\"\
  \ \"$SOURCE\"\n    echo \"Backup completed: backup-$DATE.tar.gz\"\n    ```\n\n \
  \   ### Example 2: System Information\n\n    ```bash\n    #!/bin/bash\n    # Display\
  \ system information\n\n    echo \"=== System Information ===\"\n    echo \"Hostname:\
  \ $(hostname)\"\n    echo \"OS: $(uname -s)\"\n    echo \"Kernel: $(uname -r)\"\n\
  \    echo \"Uptime: $(uptime -p)\"\n    echo \"Load Average: $(uptime | awk -F'load\
  \ average:' '{print $2}')\"\n    echo \"Disk Usage:\"\n    df -h | grep -v tmpfs\n\
  \    ```\n\n    ### Example 3: Log Analyzer\n\n    ```bash\n    #!/bin/bash\n  \
  \  # Analyze nginx access log\n\n    LOG_FILE=\"/var/log/nginx/access.log\"\n\n\
  \    echo \"Top 10 IP addresses:\"\n    awk '{print $1}' \"$LOG_FILE\" | sort |\
  \ uniq -c | sort -rn | head -10\n\n    echo \"\"\n    echo \"Top 10 requested URLs:\"\
  \n    awk '{print $7}' \"$LOG_FILE\" | sort | uniq -c | sort -rn | head -10\n\n\
  \    echo \"\"\n    echo \"HTTP status codes:\"\n    awk '{print $9}' \"$LOG_FILE\"\
  \ | sort | uniq -c | sort -rn\n    ```\n\n    ## Best Practices\n\n    ### 1. Always\
  \ Use Shebang\n\n    ```bash\n    #!/usr/bin/env bash\n    ```\n\n    ### 2. Add\
  \ Comments\n\n    ```bash\n    # This script does something important\n    # Author:\
  \ Your Name\n    # Date: 2024-01-01\n    ```\n\n    ### 3. Quote Variables\n\n \
  \   ```bash\n    # ❌ Bad - can break with spaces\n    echo $variable\n\n    # ✅\
  \ Good\n    echo \"$variable\"\n    ```\n\n    ### 4. Use `set -e`\n\n    Exit immediately\
  \ if any command fails:\n\n    ```bash\n    #!/bin/bash\n    set -e  # Exit on error\n\
  \n    mkdir /path/to/dir\n    cd /path/to/dir\n    # If mkdir fails, script stops\n\
  \    ```\n\n    ### 5. Use `set -u`\n\n    Treat unset variables as errors:\n\n\
  \    ```bash\n    #!/bin/bash\n    set -u  # Error on undefined variable\n\n   \
  \ echo \"$undefined_var\"  # This will cause an error\n    ```\n\n    ### 6. Use\
  \ `set -x`\n\n    Print commands before executing (debugging):\n\n    ```bash\n\
  \    #!/bin/bash\n    set -x  # Debug mode\n\n    echo \"Hello\"\n    # Output:\
  \ + echo Hello\n    #         Hello\n    ```\n\n    ### Combine Options\n\n    ```bash\n\
  \    #!/bin/bash\n    set -euo pipefail  # Exit on error, undefined var, pipe failure\n\
  \    ```\n\n    ## Key Takeaways\n\n    1. **Bash is powerful** - Automate tasks,\
  \ manage systems\n    2. **Shebang matters** - Use `#!/usr/bin/env bash`\n    3.\
  \ **Pipes are your friend** - Chain commands together\n    4. **Quote variables**\
  \ - Prevent word splitting and globbing\n    5. **Check exit status** - Use `$?`\
  \ or `&&` / `||`\n    6. **Use set options** - `set -euo pipefail` for robust scripts\n\
  \    7. **Learn core utilities** - grep, sed, awk, find, etc.\n    8. **Practice\
  \ regularly** - The more you use it, the better you get"
exercises:
- type: mcq
  slug: introduction-to-bash-and-shell-scripting-mcq-1
  sequence_order: 1
  question: What is the purpose of the shebang line (#!/bin/bash) at the beginning of a shell script?
  options:
  - It specifies which interpreter to use to execute the script
  - It makes the file executable
  - It comments out the first line
  - It imports bash functions
  correct_answer_index: 0
  explanation: The shebang tells the system which interpreter (bash, python, etc.) should be used to execute the script. It's the first line and starts with #! followed by the path to the interpreter.
- type: mcq
  slug: introduction-to-bash-and-shell-scripting-mcq-2
  sequence_order: 2
  question: What does the pipe operator (|) do in Bash?
  options:
  - Connects the output of one command to the input of another
  - Creates a new file
  - Runs commands in parallel
  - Comments out a line of code
  correct_answer_index: 0
  explanation: The pipe operator (|) takes the standard output (stdout) of the command on the left and feeds it as standard input (stdin) to the command on the right, enabling powerful command chaining like "cat file.txt | grep pattern | sort".
- type: mcq
  slug: introduction-to-bash-and-shell-scripting-mcq-3
  sequence_order: 3
  question: What is the difference between > and >> when redirecting output in Bash?
  options:
  - '> overwrites the file, >> appends to the file'
  - '> appends to the file, >> overwrites the file'
  - Both do the same thing
  - '> redirects stdout, >> redirects stderr'
  correct_answer_index: 0
  explanation: The > operator overwrites the target file with new output, while >> appends to the existing file. For example, "echo hello > file.txt" replaces file contents, but "echo world >> file.txt" adds to the end.
- type: mcq
  slug: introduction-to-bash-and-shell-scripting-mcq-4
  sequence_order: 4
  question: What does the exit status $? represent in Bash?
  options:
  - The exit code of the last executed command (0 for success, non-zero for error)
  - The process ID of the current shell
  - The number of arguments passed to a script
  - The current line number in a script
  correct_answer_index: 0
  explanation: '$? contains the exit status of the last command. By convention, 0 means success and any non-zero value indicates an error. This allows you to check if a command succeeded with "if command; then" or "command && next_command".'
objectives:
- Understand what a shell is and why Bash is important
- Write and execute basic shell scripts with proper shebang
- Use pipes and redirection to combine commands effectively
- Navigate the filesystem and perform file operations
- Check command exit status for error handling
next_recommended:
- control
- data-structures
