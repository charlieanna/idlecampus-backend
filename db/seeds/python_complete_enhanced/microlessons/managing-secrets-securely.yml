slug: managing-secrets-securely
title: Managing Secrets Securely
sequence_order: 6
estimated_minutes: 2
difficulty: easy
key_concepts: []
content_md: "# Managing Secrets Securely \U0001F680\n\n# Managing Secrets Securely\n\
  \n    Secrets include passwords, API keys, tokens, certificates - anything that\
  \ grants access.\n\n    ## Common Mistakes âŒ\n\n    ### 1. Hardcoding Secrets\n\
  \    ```python\n    # BAD - Never do this!\n    API_KEY = \"sk_live_abc123xyz789\"\
  \n    DATABASE_URL = \"postgres://user:password@host/db\"\n    ```\n\n    ### 2.\
  \ Committing Secrets to Git\n    ```bash\n    # BAD - Secrets in repository\n  \
  \  git add config.json\n    git commit -m \"Add API keys\"  # Now in git history\
  \ forever!\n    ```\n\n    ### 3. Logging Secrets\n    ```bash\n    # BAD - Secrets\
  \ in logs\n    echo \"Connecting with password: $DB_PASSWORD\"\n    ```\n\n    ###\
  \ 4. Sharing Secrets via Email/Chat\n    Insecure channels = compromised secrets.\n\
  \n    ## Environment Variables\n\n    ### Setting Environment Variables\n    ```bash\n\
  \    # Temporary (current session only)\n    export DATABASE_URL=\"postgres://localhost/mydb\"\
  \n    export API_KEY=\"secret_key_here\"\n\n    # In application\n    python app.py\n\
  \    ```\n\n    ### .env Files\n    ```bash\n    # .env file (NEVER commit this!)\n\
  \    DATABASE_URL=postgres://user:pass@localhost/db\n    API_KEY=sk_live_abc123\n\
  \    STRIPE_SECRET=sk_test_xyz789\n    JWT_SECRET=my_super_secret_key\n    ```\n\
  \n    **Always add .env to .gitignore:**\n    ```bash\n    echo \".env\" >> .gitignore\n\
  \    ```\n\n    ### .env.example Template\n    ```bash\n    # .env.example (safe\
  \ to commit)\n    DATABASE_URL=postgres://user:password@localhost/dbname\n    API_KEY=your_api_key_here\n\
  \    STRIPE_SECRET=your_stripe_secret_key\n    JWT_SECRET=generate_a_random_secret\n\
  \    ```\n\n    ## Docker Secrets\n\n    ### Environment Variables in Docker\n \
  \   ```bash\n    # Pass at runtime\n    docker run -e DATABASE_URL=\"postgres://...\"\
  \ myapp\n\n    # From .env file\n    docker run --env-file .env myapp\n    ```\n\
  \n    ### Docker Compose\n    ```yaml\n    version: '3.8'\n    services:\n     \
  \ app:\n        image: myapp\n        environment:\n          - DATABASE_URL=${DATABASE_URL}\n\
  \          - API_KEY=${API_KEY}\n        # Or use env_file\n        env_file:\n\
  \          - .env\n    ```\n\n    ### Docker Swarm Secrets\n    ```bash\n    # Create\
  \ secret\n    echo \"my_secret_password\" | docker secret create db_password -\n\
  \n    # Use in service\n    docker service create \\\\\n      --name myapp \\\\\n\
  \      --secret db_password \\\\\n      myimage\n\n    # Access in container: /run/secrets/db_password\n\
  \    ```\n\n    ## Kubernetes Secrets\n\n    ### Create Secret\n    ```bash\n  \
  \  # From literal\n    kubectl create secret generic db-creds \\\\\n      --from-literal=username=admin\
  \ \\\\\n      --from-literal=password=secret123\n\n    # From file\n    kubectl\
  \ create secret generic api-keys \\\\\n      --from-file=api-key.txt\n\n    # From\
  \ .env file\n    kubectl create secret generic app-secrets --from-env-file=.env\n\
  \    ```\n\n    ### Use Secret in Pod\n    ```yaml\n    apiVersion: v1\n    kind:\
  \ Pod\n    metadata:\n      name: myapp\n    spec:\n      containers:\n      - name:\
  \ app\n        image: myapp:latest\n        env:\n        - name: DB_PASSWORD\n\
  \          valueFrom:\n            secretKeyRef:\n              name: db-creds\n\
  \              key: password\n        volumeMounts:\n        - name: secrets-volume\n\
  \          mountPath: /etc/secrets\n          readOnly: true\n      volumes:\n \
  \     - name: secrets-volume\n        secret:\n          secretName: api-keys\n\
  \    ```\n\n    ## Secrets Management Tools\n\n    ### HashiCorp Vault\n    Industry\
  \ standard for secrets management.\n\n    ```bash\n    # Start Vault dev server\n\
  \    vault server -dev\n\n    # Store secret\n    vault kv put secret/myapp/db password=\"\
  secret123\" username=\"admin\"\n\n    # Read secret\n    vault kv get secret/myapp/db\n\
  \n    # Use in application\n    export VAULT_ADDR='http://127.0.0.1:8200'\n    export\
  \ VAULT_TOKEN='dev-token'\n    vault kv get -field=password secret/myapp/db\n  \
  \  ```\n\n    ### AWS Secrets Manager\n    ```bash\n    # Store secret\n    aws\
  \ secretsmanager create-secret \\\\\n      --name myapp/db \\\\\n      --secret-string\
  \ '{\"username\":\"admin\",\"password\":\"secret\"}'\n\n    # Retrieve secret\n\
  \    aws secretsmanager get-secret-value --secret-id myapp/db\n    ```\n\n    ###\
  \ Azure Key Vault\n    ```bash\n    # Create secret\n    az keyvault secret set\
  \ \\\\\n      --vault-name myvault \\\\\n      --name db-password \\\\\n      --value\
  \ \"secret123\"\n\n    # Get secret\n    az keyvault secret show --vault-name myvault\
  \ --name db-password\n    ```\n\n    ## Best Practices\n\n    ### 1. Never Commit\
  \ Secrets\n    - Use .gitignore for .env files\n    - Scan repos: `git-secrets`,\
  \ `truffleHog`\n    - Use pre-commit hooks\n\n    ### 2. Rotate Secrets Regularly\n\
  \    - API keys: every 90 days\n    - Passwords: every 60-90 days\n    - Certificates:\
  \ before expiry\n\n    ### 3. Principle of Least Privilege\n    - Grant minimum\
  \ permissions needed\n    - Separate dev/staging/prod secrets\n    - Use service\
  \ accounts, not personal credentials\n\n    ### 4. Encrypt at Rest\n    - Database\
  \ encryption\n    - Encrypted filesystems\n    - Secrets encrypted in etcd (Kubernetes)\n\
  \n    ### 5. Audit Access\n    - Log who accessed which secrets\n    - Monitor for\
  \ anomalies\n    - Set up alerts for unauthorized access\n\n    ### 6. Use Secure\
  \ Channels\n    - Share secrets via encrypted tools\n    - Use password managers\
  \ (1Password, LastPass, Bitwarden)\n    - Never email/Slack secrets in plain text\n\
  \n    ## Emergency Response\n\n    ### If Secret is Compromised:\n    1. **Rotate\
  \ immediately** - generate new secret\n    2. **Revoke old secret** - invalidate\
  \ compromised credential\n    3. **Audit access** - check who used the secret\n\
  \    4. **Update all systems** - deploy new secret\n    5. **Investigate** - how\
  \ was it compromised?\n    6. **Document** - post-mortem, lessons learned"
exercises:
- type: mcq
  slug: managing-secrets-securely-mcq-1
  sequence_order: 1
  question: Why should you NEVER commit .env files containing secrets to Git?
  options:
  - Git history is permanent; secrets would be exposed forever even if deleted later
  - .env files are too large for Git
  - Git doesn't support .env file format
  - It makes the repository slower
  correct_answer_index: 0
  explanation: Once committed to Git, secrets remain in the repository's history forever,
    even if you delete the file in a later commit. Attackers can access old commits.
    Always add .env to .gitignore and use .env.example templates with placeholder
    values instead.
- type: mcq
  slug: managing-secrets-securely-mcq-2
  sequence_order: 2
  question: What is the purpose of a salt when hashing passwords?
  options:
  - To make each hash unique, preventing rainbow table attacks and making identical
    passwords have different hashes
  - To make passwords taste better
  - To encrypt the password
  - To compress the password for storage
  correct_answer_index: 0
  explanation: A salt is random data added to each password before hashing. This ensures
    identical passwords produce different hashes, defeats pre-computed rainbow table
    attacks, and makes each password hash unique. Modern password hashing functions
    like bcrypt and argon2 automatically handle salting.
- type: mcq
  slug: managing-secrets-securely-mcq-3
  sequence_order: 3
  question: What is the advantage of using a secrets management tool (like HashiCorp
    Vault, AWS Secrets Manager) over environment variables?
  options:
  - Centralized management, automatic rotation, audit logs, and fine-grained access
    control
  - It's faster to access secrets
  - Environment variables don't work in production
  - Secrets management tools are free
  correct_answer_index: 0
  explanation: Secrets management tools provide centralized secret storage, automatic
    rotation, detailed audit logs of who accessed what, fine-grained permissions,
    encryption at rest, and integration with various platforms. While environment
    variables work, they lack these enterprise features needed for production security.
- type: terminal
  slug: managing-secrets-securely-term
  sequence_order: 4
  description: Access environment variables securely in Python
  command: 'python - << "PY" import os os.environ["DEMO_API_KEY"] = "demo_key_12345"
    os.environ["DEMO_DB_URL"] = "postgres://localhost/mydb" api_key = os.getenv("DEMO_API_KEY")
    db_url = os.getenv("DEMO_DB_URL") missing = os.getenv("NONEXISTENT", "default_value")
    print(f"API Key (first 10 chars): {api_key[:10]}...") print(f"DB URL present:
    {bool(db_url)}") print(f"Missing key with default: {missing}") PY'
  validation:
    must_not_include:
    - Traceback
    - SyntaxError
  hints:
  - If `python` is not available, try `python3`.
  - The os module is part of Python's standard library.
objectives:
- Understand why hardcoding secrets and committing them to Git is dangerous
- Use environment variables and .env files to manage secrets locally
- Always add .env to .gitignore and provide .env.example templates
- Access environment variables programmatically using os.getenv()
- Implement Docker and Kubernetes secrets for containerized applications
- Use secrets management tools (Vault, AWS Secrets Manager) for production
- Follow best practices - rotation, least privilege, encryption at rest, audit logging
next_recommended:
- control
- data-structures
