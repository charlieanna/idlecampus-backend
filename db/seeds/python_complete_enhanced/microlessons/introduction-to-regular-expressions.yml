slug: introduction-to-regular-expressions
title: Introduction to Regular Expressions
sequence_order: 1
estimated_minutes: 2
difficulty: easy
key_concepts: []
content_md: "# Introduction to Regular Expressions \U0001F680\n\n# Introduction to\
  \ Regular Expressions\n\n    Regular expressions (regex) are powerful patterns used\
  \ for matching and manipulating text. They're supported in virtually every programming\
  \ language and are essential for text processing tasks.\n\n    ## What are Regular\
  \ Expressions?\n\n    A regular expression is a sequence of characters that defines\
  \ a search pattern. When you run a regex against text, it returns matches or allows\
  \ you to perform substitutions.\n\n    ### Common Use Cases\n\n    - **Validation**:\
  \ Email addresses, phone numbers, passwords\n    - **Parsing**: Log files, data\
  \ extraction, web scraping\n    - **Search & Replace**: Text editors, IDEs, code\
  \ refactoring\n    - **Data Cleaning**: Removing whitespace, formatting\n    - **Tokenization**:\
  \ Breaking text into words or sentences\n\n    ## Your First Regex\n\n    ### Literal\
  \ Matches\n\n    The simplest regex matches exact text:\n\n    ```python\n    import\
  \ re\n\n    text = \"The cat sat on the mat\"\n    pattern = \"cat\"\n\n    match\
  \ = re.search(pattern, text)\n    print(match.group())  # Output: cat\n    ```\n\
  \n    ## Basic Metacharacters\n\n    Metacharacters are special characters with\
  \ special meanings:\n\n    | Character | Meaning | Example |\n    |-----------|---------|---------|\n\
  \    | `.` | Any character except newline | `c.t` matches \"cat\", \"cot\", \"cut\"\
  \ |\n    | `^` | Start of string | `^The` matches \"The\" at beginning |\n    |\
  \ `$` | End of string | `end$` matches \"end\" at end |\n    | `*` | 0 or more repetitions\
  \ | `ca*t` matches \"ct\", \"cat\", \"caat\" |\n    | `+` | 1 or more repetitions\
  \ | `ca+t` matches \"cat\", \"caat\" but not \"ct\" |\n    | `?` | 0 or 1 repetition\
  \ (optional) | `colou?r` matches \"color\" and \"colour\" |\n    | `|` | OR operator\
  \ | `cat|dog` matches \"cat\" or \"dog\" |\n    | `\\\\` | Escape special character\
  \ | `\\\\.` matches literal \".\" |\n\n    ### The Dot (.) - Universal Wildcard\n\
  \n    ```python\n    pattern = \"c.t\"\n    # Matches: cat, cot, cut, c9t, c@t,\
  \ etc.\n    # Does NOT match: ct (no character between c and t)\n    ```\n\n   \
  \ ### Escape Characters (\\\\)\n\n    To match special characters literally, escape\
  \ them:\n\n    ```python\n    pattern = \"\\\\.\"      # Matches literal \".\"\n\
  \    pattern = \"\\\\$\"      # Matches literal \"$\"\n    pattern = \"\\\\?\" \
  \     # Matches literal \"?\"\n    pattern = \"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\
  \      # Matches literal \"\\\\\\\\\\\\\\\\\"\n    ```\n\n    ## Character Classes\n\
  \n    Character classes match one character from a set:\n\n    ### Basic Syntax:\
  \ [...]\n\n    ```python\n    pattern = \"[aeiou]\"      # Matches any vowel\n \
  \   pattern = \"[0-9]\"        # Matches any digit\n    pattern = \"[a-z]\"    \
  \    # Matches any lowercase letter\n    pattern = \"[A-Z]\"        # Matches any\
  \ uppercase letter\n    pattern = \"[a-zA-Z]\"     # Matches any letter\n    pattern\
  \ = \"[a-zA-Z0-9]\"  # Matches alphanumeric\n    ```\n\n    ### Negated Character\
  \ Classes: [^...]\n\n    ```python\n    pattern = \"[^0-9]\"   # Matches any NON-digit\n\
  \    pattern = \"[^aeiou]\" # Matches any NON-vowel\n    ```\n\n    ### Predefined\
  \ Character Classes\n\n    | Class | Equivalent | Meaning |\n    |-------|------------|---------|\n\
  \    | `\\\\d` | `[0-9]` | Any digit |\n    | `\\\\D` | `[^0-9]` | Any non-digit\
  \ |\n    | `\\\\w` | `[a-zA-Z0-9_]` | Any word character |\n    | `\\\\W` | `[^a-zA-Z0-9_]`\
  \ | Any non-word character |\n    | `\\\\s` | `[ \\\\t\\\\n\\\\r\\\\f\\\\v]` | Any\
  \ whitespace |\n    | `\\\\S` | `[^ \\\\t\\\\n\\\\r\\\\f\\\\v]` | Any non-whitespace\
  \ |\n\n    ### Examples\n\n    ```python\n    # Match a 3-digit number\n    pattern\
  \ = \"\\\\d\\\\d\\\\d\"\n    # Matches: 123, 456, 999\n\n    # Match a word\n  \
  \  pattern = \"\\\\w+\"\n    # Matches: hello, world123, test_case\n\n    # Match\
  \ whitespace-separated words\n    pattern = \"\\\\w+\\\\s+\\\\w+\"\n    # Matches:\
  \ \"hello world\", \"foo bar\"\n    ```\n\n    ## Quantifiers\n\n    Quantifiers\
  \ specify how many times a character or group should appear:\n\n    | Quantifier\
  \ | Meaning | Example |\n    |------------|---------|---------|\n    | `*` | 0 or\
  \ more | `a*` matches \"\", \"a\", \"aa\", \"aaa\" |\n    | `+` | 1 or more | `a+`\
  \ matches \"a\", \"aa\", \"aaa\" (not \"\") |\n    | `?` | 0 or 1 | `a?` matches\
  \ \"\", \"a\" |\n    | `{n}` | Exactly n | `a{3}` matches \"aaa\" |\n    | `{n,}`\
  \ | n or more | `a{2,}` matches \"aa\", \"aaa\", \"aaaa\" |\n    | `{n,m}` | Between\
  \ n and m | `a{2,4}` matches \"aa\", \"aaa\", \"aaaa\" |\n\n    ### Practical Examples\n\
  \n    ```python\n    # Phone number: 3 digits, dash, 4 digits\n    pattern = \"\\\
  \\d{3}-\\\\d{4}\"\n    # Matches: 555-1234\n\n    # Flexible phone: optional area\
  \ code\n    pattern = \"(\\\\d{3}-)?\\\\d{3}-\\\\d{4}\"\n    # Matches: 555-1234\
  \ or 800-555-1234\n\n    # One or more words\n    pattern = \"\\\\w+\"\n    # Matches:\
  \ hello, world123, test\n\n    # Optional plural\n    pattern = \"cats?\"\n    #\
  \ Matches: cat or cats\n    ```\n\n    ## Anchors and Boundaries\n\n    Anchors\
  \ don't match characters—they match positions:\n\n    | Anchor | Meaning | Example\
  \ |\n    |--------|---------|---------|\n    | `^` | Start of string/line | `^Hello`\
  \ matches \"Hello\" at start |\n    | `$` | End of string/line | `world$` matches\
  \ \"world\" at end |\n    | `\\\\b` | Word boundary | `\\\\bcat\\\\b` matches \"\
  cat\" but not \"category\" |\n    | `\\\\B` | Non-word boundary | `\\\\Bcat\\\\\
  B` matches \"category\" but not \"cat\" |\n\n    ### Examples\n\n    ```python\n\
  \    # Entire string must be digits\n    pattern = \"^\\\\d+$\"\n    # Matches:\
  \ \"12345\" (entire string)\n    # Does NOT match: \"abc123\" or \"123abc\"\n\n\
  \    # Match \"cat\" as a whole word\n    pattern = \"\\\\bcat\\\\b\"\n    # Matches:\
  \ \"the cat sat\" (matches \"cat\")\n    # Does NOT match: \"category\" or \"scattered\"\
  \n\n    # Email validation (simplified)\n    pattern = \"^[\\\\w.-]+@[\\\\w.-]+\\\
  \\.\\\\w+$\"\n    # Matches: user@example.com\n    ```\n\n    ## Greedy vs Lazy\
  \ Matching\n\n    ### Greedy (Default)\n    Quantifiers are greedy by default—they\
  \ match as much as possible:\n\n    ```python\n    text = \"<html><body></body></html>\"\
  \n    pattern = \"<.*>\"\n    # Matches: \"<html><body></body></html>\" (everything!)\n\
  \    ```\n\n    ### Lazy (Non-Greedy)\n    Add `?` after quantifier to make it lazy—match\
  \ as little as possible:\n\n    ```python\n    text = \"<html><body></body></html>\"\
  \n    pattern = \"<.*?>\"\n    # Matches: \"<html>\", \"<body>\", \"</body>\", \"\
  </html>\" (separately)\n    ```\n\n    | Greedy | Lazy | Meaning |\n    |--------|------|---------|\n\
  \    | `*` | `*?` | 0 or more (lazy) |\n    | `+` | `+?` | 1 or more (lazy) |\n\
  \    | `?` | `??` | 0 or 1 (lazy) |\n    | `{n,m}` | `{n,m}?` | Between n and m\
  \ (lazy) |\n\n    ## Practical Examples\n\n    ### Validate Email Address (Simple)\n\
  \    ```python\n    pattern = \"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$\"\
  \n    ```\n\n    ### Extract URLs\n    ```python\n    pattern = \"https?://[\\\\\
  w.-]+\\\\.[a-zA-Z]{2,}(/[\\\\w.-]*)*\"\n    ```\n\n    ### Match Phone Numbers\n\
  \    ```python\n    # Format: (123) 456-7890 or 123-456-7890\n    pattern = \"\\\
  \\(?(\\\\d{3})\\\\)?[- ]?(\\\\d{3})[- ]?(\\\\d{4})\"\n    ```\n\n    ### Extract\
  \ Hashtags\n    ```python\n    pattern = \"#\\\\w+\"\n    # Matches: #python, #regex,\
  \ #coding\n    ```\n\n    ## Testing Your Regex\n\n    ### Online Tools\n    - **regex101.com**\
  \ - Best for learning (explanations + testing)\n    - **regexr.com** - Interactive\
  \ with cheat sheet\n    - **regexpal.com** - Simple and fast\n\n    ### In Python\n\
  \    ```python\n    import re\n\n    pattern = r\"\\\\d{3}-\\\\d{4}\"\n    text\
  \ = \"Call me at 555-1234\"\n\n    # Search for first match\n    match = re.search(pattern,\
  \ text)\n    if match:\n        print(f\"Found: {match.group()}\")\n\n    # Find\
  \ all matches\n    matches = re.findall(pattern, text)\n    print(f\"All matches:\
  \ {matches}\")\n    ```\n\n    ## Common Pitfalls\n\n    ### 1. Forgetting to Escape\
  \ Special Characters\n    ```python\n    # ❌ Wrong - tries to match any character\n\
  \    pattern = \".\"\n\n    # ✅ Correct - matches literal period\n    pattern =\
  \ \"\\\\.\"\n    ```\n\n    ### 2. Greedy Matching\n    ```python\n    # ❌ Matches\
  \ too much\n    pattern = \"\\\".*\\\"\"\n    text = '\"Hello\" and \"World\"'\n\
  \    # Matches: \"Hello\" and \"World\" (entire string!)\n\n    # ✅ Use lazy quantifier\n\
  \    pattern = \"\\\".*?\\\"\"\n    # Matches: \"Hello\" and \"World\" (separately)\n\
  \    ```\n\n    ### 3. Not Using Raw Strings (Python)\n    ```python\n    # ❌ Need\
  \ double backslashes\n    pattern = \"\\\\\\\\d+\"\n\n    # ✅ Use raw string\n \
  \   pattern = r\"\\\\d+\"\n    ```\n\n    ## Key Takeaways\n\n    1. **Start simple**\
  \ - Build complex patterns incrementally\n    2. **Test frequently** - Use online\
  \ tools to visualize matches\n    3. **Use raw strings** - `r\"...\"` in Python\
  \ to avoid double escaping\n    4. **Character classes** - `[...]` for sets, `\\\
  \\d \\\\w \\\\s` for common patterns\n    5. **Quantifiers** - `* + ? {n,m}` for\
  \ repetition\n    6. **Anchors** - `^ $ \\\\b` for position matching\n    7. **Lazy\
  \ matching** - Add `?` after quantifiers when needed\n    8. **Practice** - The\
  \ best way to learn is by doing!"
exercises:
- type: mcq
  slug: introduction-to-regular-expressions-mcq-1
  sequence_order: 1
  question: What does the dot (.) metacharacter match in a regex pattern?
  options:
  - Any single character except newline
  - Only alphabetic characters
  - A literal period/dot
  - Zero or more characters
  correct_answer_index: 0
  explanation: The dot (.) is a wildcard that matches any single character except newline. For example, c.t matches "cat", "cot", "c9t", etc. To match a literal dot, you must escape it as \.
- type: mcq
  slug: introduction-to-regular-expressions-mcq-2
  sequence_order: 2
  question: What is the difference between * and + quantifiers in regex?
  options:
  - "*" matches 0 or more occurrences; "+" matches 1 or more occurrences
  - "*" is faster than "+"
  - "*" matches only numbers; "+" matches only letters
  - They are identical in functionality
  correct_answer_index: 0
  explanation: The * quantifier matches zero or more occurrences (so "ca*t" matches "ct", "cat", "caat"). The + quantifier requires at least one occurrence (so "ca+t" matches "cat", "caat" but NOT "ct").
- type: mcq
  slug: introduction-to-regular-expressions-mcq-3
  sequence_order: 3
  question: Why should you use raw strings (r"...") for regex patterns in Python?
  options:
  - To avoid double-escaping backslashes in patterns like \d or \w
  - Raw strings make regex execute faster
  - Raw strings are required by the re module
  - To make patterns case-insensitive
  correct_answer_index: 0
  explanation: Raw strings treat backslashes literally, so r"\d" is interpreted as \d (digit pattern). Without the r prefix, you'd need "\\d" (double backslash) because Python would otherwise interpret \d as an escape sequence. Raw strings make regex patterns much more readable.
- type: terminal
  slug: introduction-to-regular-expressions-term
  sequence_order: 4
  description: Test basic regex patterns with Python
  command: 'python - << "PY"
    import re
    text = "The phone number is 555-1234"
    pattern = r"\d{3}-\d{4}"
    match = re.search(pattern, text)
    if match:
        print(f"Found phone number: {match.group()}")
    words = re.findall(r"\w+", text)
    print(f"Words found: {words}")
    PY'
  validation:
    must_not_include:
    - Traceback
    - SyntaxError
  hints:
  - If `python` is not available, try `python3`.
  - The re module is part of Python's standard library.
- type: reflection
  slug: introduction-to-regular-expressions-reflect
  sequence_order: 5
  prompt: Consider a text validation or parsing task you've encountered (validating emails, extracting data from logs, cleaning user input). How could regular expressions simplify this task? What specific pattern would you need to match?
- type: checkpoint
  slug: introduction-to-regular-expressions-checkpoint
  sequence_order: 6
  prompt: Write a regex pattern to match US phone numbers in the format 123-456-7890 or (123) 456-7890. Use \d for digits and optional groups. Test your pattern with sample inputs and explain each component.
objectives:
- Understand what regular expressions are and their common use cases
- Use basic metacharacters (., ^, $, *, +, ?, |, \)
- Apply predefined character classes (\d, \w, \s)
- Distinguish between greedy and lazy quantifiers
- Use anchors (^, $, \b) for position matching
- Write patterns using raw strings in Python (r"...")
next_recommended:
- control
- data-structures
