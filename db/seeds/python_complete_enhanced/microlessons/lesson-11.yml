slug: lesson-11
title: Lesson 11
sequence_order: 11
estimated_minutes: 2
difficulty: easy
key_concepts: []
content_md: "# Microlesson \U0001F680\n\n# Sorting Algorithms\n\n    ## Comparison\
  \ of Sorting Algorithms\n\n    | Algorithm | Time (Best) | Time (Avg) | Time (Worst)\
  \ | Space | Stable |\n    |-----------|-------------|------------|--------------|-------|--------|\n\
  \    | Bubble Sort | O(n) | O(n²) | O(n²) | O(1) | Yes |\n    | Selection Sort |\
  \ O(n²) | O(n²) | O(n²) | O(1) | No |\n    | Insertion Sort | O(n) | O(n²) | O(n²)\
  \ | O(1) | Yes |\n    | Merge Sort | O(n log n) | O(n log n) | O(n log n) | O(n)\
  \ | Yes |\n    | Quick Sort | O(n log n) | O(n log n) | O(n²) | O(log n) | No |\n\
  \    | Heap Sort | O(n log n) | O(n log n) | O(n log n) | O(1) | No |\n\n    ##\
  \ Quick Sort\n\n    **Divide and conquer, pick pivot, partition**\n\n    ```python\n\
  \    def quick_sort(arr):\n        if len(arr) <= 1:\n            return arr\n\n\
  \        pivot = arr[len(arr) // 2]\n        left = [x for x in arr if x < pivot]\n\
  \        middle = [x for x in arr if x == pivot]\n        right = [x for x in arr\
  \ if x > pivot]\n\n        return quick_sort(left) + middle + quick_sort(right)\n\
  \n    # Average: O(n log n), Worst: O(n²)\n    # Space: O(log n) for recursion\n\
  \    ```\n\n    **In-place Quick Sort**\n\n    ```python\n    def quick_sort_inplace(arr,\
  \ low=0, high=None):\n        if high is None:\n            high = len(arr) - 1\n\
  \n        if low < high:\n            pi = partition(arr, low, high)\n         \
  \   quick_sort_inplace(arr, low, pi - 1)\n            quick_sort_inplace(arr, pi\
  \ + 1, high)\n\n        return arr\n\n    def partition(arr, low, high):\n     \
  \   pivot = arr[high]\n        i = low - 1\n\n        for j in range(low, high):\n\
  \            if arr[j] <= pivot:\n                i += 1\n                arr[i],\
  \ arr[j] = arr[j], arr[i]\n\n        arr[i + 1], arr[high] = arr[high], arr[i +\
  \ 1]\n        return i + 1\n    ```\n\n    ## Merge Sort\n\n    **Divide and conquer,\
  \ always O(n log n)**\n\n    ```python\n    def merge_sort(arr):\n        if len(arr)\
  \ <= 1:\n            return arr\n\n        mid = len(arr) // 2\n        left = merge_sort(arr[:mid])\n\
  \        right = merge_sort(arr[mid:])\n\n        return merge(left, right)\n\n\
  \    def merge(left, right):\n        result = []\n        i = j = 0\n\n       \
  \ while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n\
  \                result.append(left[i])\n                i += 1\n            else:\n\
  \                result.append(right[j])\n                j += 1\n\n        result.extend(left[i:])\n\
  \        result.extend(right[j:])\n        return result\n\n    # Time: O(n log\
  \ n), Space: O(n)\n    # Stable sort!\n    ```\n\n    ## Binary Search\n\n    **Search\
  \ in sorted array**\n\n    ```python\n    def binary_search(arr, target):\n    \
  \    left, right = 0, len(arr) - 1\n\n        while left <= right:\n           \
  \ mid = left + (right - left) // 2  # Avoid overflow\n\n            if arr[mid]\
  \ == target:\n                return mid\n            elif arr[mid] < target:\n\
  \                left = mid + 1\n            else:\n                right = mid\
  \ - 1\n\n        return -1\n\n    # Time: O(log n), Space: O(1)\n    ```\n\n   \
  \ **Binary Search Variations**\n\n    ```python\n    # Find first occurrence\n \
  \   def find_first(arr, target):\n        left, right = 0, len(arr) - 1\n      \
  \  result = -1\n\n        while left <= right:\n            mid = left + (right\
  \ - left) // 2\n\n            if arr[mid] == target:\n                result = mid\n\
  \                right = mid - 1  # Continue searching left\n            elif arr[mid]\
  \ < target:\n                left = mid + 1\n            else:\n               \
  \ right = mid - 1\n\n        return result\n\n    # Find insertion position\n  \
  \  def search_insert(arr, target):\n        left, right = 0, len(arr)\n\n      \
  \  while left < right:\n            mid = left + (right - left) // 2\n         \
  \   if arr[mid] < target:\n                left = mid + 1\n            else:\n \
  \               right = mid\n\n        return left\n    ```\n\n    ## Interview\
  \ Tips\n\n    1. **Always ask if input is sorted** - enables binary search\n   \
  \ 2. **For small datasets**: Simple sorts (insertion) are fine\n    3. **For large\
  \ datasets**: Use O(n log n) sorts\n    4. **Need stable sort?** Use merge sort\
  \ or insertion sort\n    5. **Limited memory?** Use in-place sorts (quick sort,\
  \ heap sort)\n\n    **Next**: Dynamic Programming!"
exercises:
- type: mcq
  slug: lesson-11-mcq-1
  sequence_order: 1
  question: What is the difference between a list and a tuple in Python?
  options:
  - Lists are mutable (can be modified), tuples are immutable (cannot be changed)
  - Lists are faster than tuples
  - Tuples can only store strings
  - Lists use less memory
  correct_answer_index: 0
  explanation: Lists are mutable - you can add, remove, or modify elements after creation using methods like append(), remove(), etc. Tuples are immutable - once created, they cannot be modified. Tuples are slightly faster and use less memory, making them ideal for fixed collections of data.
- type: mcq
  slug: lesson-11-mcq-2
  sequence_order: 2
  question: What is a list comprehension in Python?
  options:
  - A concise way to create lists using a single line of code with optional filtering
  - A method to compress lists
  - A way to compare two lists
  - A list sorting algorithm
  correct_answer_index: 0
  explanation: List comprehensions provide a concise syntax to create lists: [expression for item in iterable if condition]. For example, [x**2 for x in range(10) if x % 2 == 0] creates a list of squares of even numbers. This is more readable and often faster than traditional loops.
- type: mcq
  slug: lesson-11-mcq-3
  sequence_order: 3
  question: What does the try-except block do in Python?
  options:
  - Handles exceptions (errors) gracefully without crashing the program
  - Tries to optimize code performance
  - Tests if code syntax is correct
  - Executes code multiple times until it succeeds
  correct_answer_index: 0
  explanation: try-except blocks catch and handle exceptions, preventing program crashes. Code in the try block is executed, and if an exception occurs, the except block handles it. For example, catching ValueError when converting user input to int prevents crashes from invalid input.
objectives:
- Understand core concepts of Sorting Algorithms
- Apply learned concepts in practical scenarios
- Identify best practices and common patterns
- Recognize trade-offs in different approaches
next_recommended:
- control
- data-structures
