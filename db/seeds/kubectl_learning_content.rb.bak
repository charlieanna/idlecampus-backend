# Kubectl Learning Content for Kubernetes Fundamentals
# Creates instructional lessons for each module

puts "Creating kubectl learning lessons..."

k8s_course = Course.find_by(slug: 'kubernetes-fundamentals')

unless k8s_course
  puts "❌ Kubernetes Fundamentals course not found!"
  exit
end

# Module 1: Pods & Basic Workloads
mod1 = k8s_course.course_modules.find_by(slug: 'pods-workloads')
if mod1
  lesson1 = CourseLesson.find_or_create_by!(title: "Working with Pods") do |l|
    l.key_commands = [
      "kubectl run - Create a pod - kubectl run nginx --image=nginx:1.25",
      "kubectl get pods - List all pods - kubectl get pods -o wide",
      "kubectl describe pod - Get pod details - kubectl describe pod nginx",
      "kubectl logs - View pod logs - kubectl logs nginx",
      "kubectl exec - Execute command in pod - kubectl exec -it nginx -- bash",
      "kubectl delete pod - Delete a pod - kubectl delete pod nginx"
    ]
    l.content = <<~MARKDOWN
      # Working with Pods

      Pods are the smallest deployable units in Kubernetes. They encapsulate one or more containers that share storage and network resources.

      ## Key Commands

      ### Creating Pods

      ```bash
      # Create a pod from a YAML file
      kubectl apply -f pod.yaml

      # Create a pod imperatively
      kubectl run nginx --image=nginx:1.25
      ```

      ### Viewing Pods

      ```bash
      # List all pods in current namespace
      kubectl get pods

      # List pods with more details
      kubectl get pods -o wide

      # Get detailed information about a pod
      kubectl describe pod nginx
      ```

      ### Managing Pods

      ```bash
      # Delete a pod
      kubectl delete pod nginx

      # View pod logs
      kubectl logs nginx

      # Execute commands in a pod
      kubectl exec -it nginx -- bash
      ```

      ## Pod Lifecycle

      Pods go through these phases:
      - **Pending**: Pod is created but containers aren't running yet
      - **Running**: All containers are running
      - **Succeeded**: All containers terminated successfully
      - **Failed**: At least one container terminated with failure
      - **Unknown**: Pod state cannot be determined

      ## Multi-Container Pods

      Pods can run multiple containers that work together:

      ```yaml
      apiVersion: v1
      kind: Pod
      metadata:
        name: multi-container-pod
      spec:
        containers:
        - name: app
          image: nginx
        - name: sidecar
          image: busybox
          args: ['sh', '-c', 'while true; do echo hello; sleep 10; done']
      ```

      ### Common Patterns

      1. **Sidecar**: Helper container that enhances main container
      2. **Ambassador**: Proxy container that simplifies network access
      3. **Adapter**: Transforms output of main container

      Try these commands in the hands-on lab!
    MARKDOWN
    l.reading_time_minutes = 8
  end

  # Link lesson to module
  ModuleItem.find_or_create_by!(
    course_module: mod1,
    item_type: 'CourseLesson',
    item: lesson1,
    sequence_order: 2
  ) { |item| item.required = true }

  puts "  ✅ Created 'Working with Pods' lesson"
end

# Module 2: Services & Networking
mod2 = k8s_course.course_modules.find_by(slug: 'services-networking')
if mod2
  lesson2 = CourseLesson.find_or_create_by!(title: "Kubernetes Services & Networking") do |l|
    l.key_commands = [
      "kubectl get services - List all services - kubectl get svc",
      "kubectl expose - Create a service - kubectl expose deployment nginx --port=80",
      "kubectl create service - Create service imperatively - kubectl create service clusterip my-svc --tcp=80:8080",
      "kubectl describe service - Get service details - kubectl describe svc my-service",
      "kubectl get ingress - List ingress resources - kubectl get ing",
      "kubectl get networkpolicies - List network policies - kubectl get netpol"
    ]
    l.content = <<~MARKDOWN
      # Kubernetes Services & Networking

      Services expose Pods to network traffic and enable load balancing across multiple Pod replicas.

      ## Service Types

      ### 1. ClusterIP (Default)
      Exposes service on cluster-internal IP.

      ```bash
      kubectl create service clusterip my-service --tcp=80:8080
      ```

      ### 2. NodePort
      Exposes service on each Node's IP at a static port.

      ```bash
      kubectl create service nodeport my-service --tcp=80:8080
      ```

      ### 3. LoadBalancer
      Exposes service externally using cloud provider's load balancer.

      ```bash
      kubectl expose deployment nginx --type=LoadBalancer --port=80
      ```

      ### 4. ExternalName
      Maps service to external DNS name.

      ## Key Commands

      ```bash
      # List services
      kubectl get services
      kubectl get svc

      # Describe a service
      kubectl describe service my-service

      # Expose a deployment as a service
      kubectl expose deployment nginx --port=80 --target-port=8080

      # Delete a service
      kubectl delete service my-service
      ```

      ## Ingress

      Ingress manages external HTTP/HTTPS access to services.

      ```yaml
      apiVersion: networking.k8s.io/v1
      kind: Ingress
      metadata:
        name: my-ingress
      spec:
        rules:
        - host: myapp.example.com
          http:
            paths:
            - path: /
              pathType: Prefix
              backend:
                service:
                  name: my-service
                  port:
                    number: 80
      ```

      ### Ingress Commands

      ```bash
      # List ingress resources
      kubectl get ingress

      # Describe ingress
      kubectl describe ingress my-ingress
      ```

      ## Network Policies

      Control traffic flow between Pods.

      ```bash
      # List network policies
      kubectl get networkpolicies
      kubectl get netpol

      # Describe network policy
      kubectl describe networkpolicy my-policy
      ```

      Practice these concepts in the hands-on labs!
    MARKDOWN
    l.reading_time_minutes = 10
  end

  ModuleItem.find_or_create_by!(
    course_module: mod2,
    item_type: 'CourseLesson',
    item: lesson2,
    sequence_order: 2
  ) { |item| item.required = true }

  puts "  ✅ Created 'Kubernetes Services & Networking' lesson"
end

# Module 3: Configuration & Storage
mod3 = k8s_course.course_modules.find_by(slug: 'configuration-storage')
if mod3
  lesson3 = CourseLesson.find_or_create_by!(title: "ConfigMaps, Secrets & Volumes") do |l|
    l.key_commands = [
      "kubectl create configmap - Create ConfigMap - kubectl create configmap app-config --from-literal=ENV=prod",
      "kubectl get configmaps - List ConfigMaps - kubectl get cm",
      "kubectl create secret - Create Secret - kubectl create secret generic db-pass --from-literal=password=secret",
      "kubectl get secrets - List Secrets - kubectl get secrets",
      "kubectl get pv - List persistent volumes - kubectl get pv",
      "kubectl get pvc - List persistent volume claims - kubectl get pvc"
    ]
    l.content = <<~MARKDOWN
      # ConfigMaps, Secrets & Volumes

      Manage application configuration and persistent storage in Kubernetes.

      ## ConfigMaps

      Store non-sensitive configuration data as key-value pairs.

      ### Creating ConfigMaps

      ```bash
      # From literal values
      kubectl create configmap app-config --from-literal=ENV=production

      # From file
      kubectl create configmap app-config --from-file=config.properties

      # From directory
      kubectl create configmap app-config --from-file=./config/
      ```

      ### Using ConfigMaps

      ```yaml
      apiVersion: v1
      kind: Pod
      metadata:
        name: app-pod
      spec:
        containers:
        - name: app
          image: nginx
          envFrom:
          - configMapRef:
              name: app-config
      ```

      ### ConfigMap Commands

      ```bash
      # List configmaps
      kubectl get configmaps
      kubectl get cm

      # View configmap data
      kubectl describe configmap app-config
      kubectl get configmap app-config -o yaml
      ```

      ## Secrets

      Store sensitive information like passwords, tokens, keys.

      ### Creating Secrets

      ```bash
      # Generic secret
      kubectl create secret generic db-secret \\
        --from-literal=username=admin \\
        --from-literal=password=secret123

      # TLS secret
      kubectl create secret tls tls-secret \\
        --cert=path/to/cert.crt \\
        --key=path/to/key.key

      # Docker registry secret
      kubectl create secret docker-registry regcred \\
        --docker-server=myregistry.com \\
        --docker-username=user \\
        --docker-password=pass
      ```

      ### Using Secrets

      ```yaml
      apiVersion: v1
      kind: Pod
      metadata:
        name: app-pod
      spec:
        containers:
        - name: app
          image: nginx
          env:
          - name: DB_PASSWORD
            valueFrom:
              secretKeyRef:
                name: db-secret
                key: password
      ```

      ### Secret Commands

      ```bash
      # List secrets
      kubectl get secrets

      # View secret (base64 encoded)
      kubectl get secret db-secret -o yaml

      # Decode secret value
      kubectl get secret db-secret -o jsonpath='{.data.password}' | base64 -d
      ```

      ## Volumes

      Provide persistent storage to Pods.

      ### Volume Types

      1. **emptyDir**: Temporary storage, deleted with Pod
      2. **hostPath**: Mounts directory from Node
      3. **persistentVolumeClaim**: Dynamically provisioned storage

      ### Persistent Volumes

      ```bash
      # List persistent volumes
      kubectl get pv

      # List persistent volume claims
      kubectl get pvc

      # Describe PVC
      kubectl describe pvc my-pvc
      ```

      ### Example: Using PVC

      ```yaml
      apiVersion: v1
      kind: PersistentVolumeClaim
      metadata:
        name: app-pvc
      spec:
        accessModes:
        - ReadWriteOnce
        resources:
          requests:
            storage: 1Gi
      ---
      apiVersion: v1
      kind: Pod
      metadata:
        name: app-pod
      spec:
        containers:
        - name: app
          image: nginx
          volumeMounts:
          - name: storage
            mountPath: /data
        volumes:
        - name: storage
          persistentVolumeClaim:
            claimName: app-pvc
      ```

      Try creating ConfigMaps, Secrets, and PVCs in the labs!
    MARKDOWN
    l.reading_time_minutes = 12
  end

  ModuleItem.find_or_create_by!(
    course_module: mod3,
    item_type: 'CourseLesson',
    item: lesson3,
    sequence_order: 2
  ) { |item| item.required = true }

  puts "  ✅ Created 'ConfigMaps, Secrets & Volumes' lesson"
end

# Module 4: Deployments & Scheduling
mod4 = k8s_course.course_modules.find_by(slug: 'deployments-scheduling')
if mod4
  lesson4 = CourseLesson.find_or_create_by!(title: "Deployments & Scheduling") do |l|
    l.key_commands = [
      "kubectl create deployment - Create deployment - kubectl create deployment nginx --image=nginx:1.25 --replicas=3",
      "kubectl get deployments - List deployments - kubectl get deploy",
      "kubectl scale - Scale deployment - kubectl scale deployment nginx --replicas=5",
      "kubectl set image - Update image - kubectl set image deployment/nginx nginx=nginx:1.26",
      "kubectl rollout status - Check rollout status - kubectl rollout status deployment/nginx",
      "kubectl rollout undo - Rollback deployment - kubectl rollout undo deployment/nginx"
    ]
    l.content = <<~MARKDOWN
      # Deployments & Scheduling

      Manage application deployments and control where Pods run.

      ## Deployments

      Deployments provide declarative updates for Pods and ReplicaSets.

      ### Creating Deployments

      ```bash
      # Imperative creation
      kubectl create deployment nginx --image=nginx:1.25 --replicas=3

      # Declarative creation
      kubectl apply -f deployment.yaml
      ```

      ### Deployment YAML

      ```yaml
      apiVersion: apps/v1
      kind: Deployment
      metadata:
        name: nginx-deployment
      spec:
        replicas: 3
        selector:
          matchLabels:
            app: nginx
        template:
          metadata:
            labels:
              app: nginx
          spec:
            containers:
            - name: nginx
              image: nginx:1.25
              ports:
              - containerPort: 80
      ```

      ### Managing Deployments

      ```bash
      # List deployments
      kubectl get deployments
      kubectl get deploy

      # Scale deployment
      kubectl scale deployment nginx --replicas=5

      # Update image
      kubectl set image deployment/nginx nginx=nginx:1.26

      # View rollout status
      kubectl rollout status deployment/nginx

      # View rollout history
      kubectl rollout history deployment/nginx

      # Rollback to previous version
      kubectl rollout undo deployment/nginx

      # Rollback to specific revision
      kubectl rollout undo deployment/nginx --to-revision=2
      ```

      ## ReplicaSets

      Ensure specified number of Pod replicas are running.

      ```bash
      # List replicasets
      kubectl get replicasets
      kubectl get rs

      # Describe replicaset
      kubectl describe rs nginx-deployment-5d59d67564
      ```

      ## StatefulSets

      For stateful applications that require stable network IDs and persistent storage.

      ```bash
      # List statefulsets
      kubectl get statefulsets
      kubectl get sts

      # Scale statefulset
      kubectl scale statefulset mysql --replicas=3
      ```

      ## DaemonSets

      Ensure all (or some) Nodes run a copy of a Pod.

      ```bash
      # List daemonsets
      kubectl get daemonsets
      kubectl get ds
      ```

      ## Pod Scheduling

      Control where Pods run using node selectors and affinity rules.

      ### Node Selectors

      ```yaml
      apiVersion: v1
      kind: Pod
      metadata:
        name: nginx
      spec:
        nodeSelector:
          disktype: ssd
        containers:
        - name: nginx
          image: nginx
      ```

      ### Node Affinity

      ```yaml
      apiVersion: v1
      kind: Pod
      metadata:
        name: nginx
      spec:
        affinity:
          nodeAffinity:
            requiredDuringSchedulingIgnoredDuringExecution:
              nodeSelectorTerms:
              - matchExpressions:
                - key: kubernetes.io/os
                  operator: In
                  values:
                  - linux
        containers:
        - name: nginx
          image: nginx
      ```

      ### Taints and Tolerations

      ```bash
      # Taint a node
      kubectl taint nodes node1 key=value:NoSchedule

      # Remove taint
      kubectl taint nodes node1 key=value:NoSchedule-
      ```

      Practice deployments and scheduling in the labs!
    MARKDOWN
    l.reading_time_minutes = 12
  end

  ModuleItem.find_or_create_by!(
    course_module: mod4,
    item_type: 'CourseLesson',
    item: lesson4,
    sequence_order: 2
  ) { |item| item.required = true }

  puts "  ✅ Created 'Deployments & Scheduling' lesson"
end

# Module 5: Observability & Troubleshooting
mod5 = k8s_course.course_modules.find_by(slug: 'observability-troubleshooting')
if mod5
  lesson5 = CourseLesson.find_or_create_by!(title: "Monitoring & Debugging") do |l|
    l.key_commands = [
      "kubectl logs - View pod logs - kubectl logs pod-name -f",
      "kubectl describe - Describe resource - kubectl describe pod pod-name",
      "kubectl exec - Execute in container - kubectl exec -it pod-name -- bash",
      "kubectl port-forward - Forward port to pod - kubectl port-forward pod-name 8080:80",
      "kubectl top pods - View pod metrics - kubectl top pods --sort-by=cpu",
      "kubectl get events - View cluster events - kubectl get events --sort-by=.metadata.creationTimestamp"
    ]
    l.content = <<~MARKDOWN
      # Monitoring & Debugging

      Monitor applications and troubleshoot issues in Kubernetes.

      ## Health Checks

      ### Liveness Probes

      Check if container is alive. Kubelet restarts failed containers.

      ```yaml
      livenessProbe:
        httpGet:
          path: /healthz
          port: 8080
        initialDelaySeconds: 3
        periodSeconds: 3
      ```

      ### Readiness Probes

      Check if container is ready to serve traffic.

      ```yaml
      readinessProbe:
        exec:
          command:
          - cat
          - /tmp/healthy
        initialDelaySeconds: 5
        periodSeconds: 5
      ```

      ### Startup Probes

      Check if application has started.

      ```yaml
      startupProbe:
        httpGet:
          path: /healthz
          port: 8080
        failureThreshold: 30
        periodSeconds: 10
      ```

      ## Logging

      ### View Logs

      ```bash
      # View pod logs
      kubectl logs pod-name

      # Follow logs (tail -f)
      kubectl logs -f pod-name

      # Logs from specific container in pod
      kubectl logs pod-name -c container-name

      # Previous container logs (if restarted)
      kubectl logs pod-name --previous

      # Logs from all pods with label
      kubectl logs -l app=nginx

      # Timestamp logs
      kubectl logs pod-name --timestamps
      ```

      ## Debugging

      ### Describe Resources

      ```bash
      # Describe pod (shows events)
      kubectl describe pod pod-name

      # Describe node
      kubectl describe node node-name

      # Describe deployment
      kubectl describe deployment deploy-name
      ```

      ### Execute Commands

      ```bash
      # Open shell in container
      kubectl exec -it pod-name -- /bin/bash

      # Run single command
      kubectl exec pod-name -- ls /app

      # Execute in specific container
      kubectl exec -it pod-name -c container-name -- bash
      ```

      ### Port Forwarding

      ```bash
      # Forward local port to pod
      kubectl port-forward pod-name 8080:80

      # Forward to service
      kubectl port-forward service/my-service 8080:80
      ```

      ### Copy Files

      ```bash
      # Copy from pod to local
      kubectl cp pod-name:/path/to/file ./local-file

      # Copy from local to pod
      kubectl cp ./local-file pod-name:/path/to/file

      # Copy from specific container
      kubectl cp pod-name:/file ./file -c container-name
      ```

      ## Resource Metrics

      ### View Resource Usage

      ```bash
      # Node resource usage
      kubectl top nodes

      # Pod resource usage
      kubectl top pods

      # Pod usage in namespace
      kubectl top pods -n kube-system

      # Specific pod
      kubectl top pod pod-name

      # Sort by CPU
      kubectl top pods --sort-by=cpu

      # Sort by memory
      kubectl top pods --sort-by=memory
      ```

      ## Resource Limits

      ### Set Resource Requests and Limits

      ```yaml
      apiVersion: v1
      kind: Pod
      metadata:
        name: app
      spec:
        containers:
        - name: app
          image: nginx
          resources:
            requests:
              memory: "64Mi"
              cpu: "250m"
            limits:
              memory: "128Mi"
              cpu: "500m"
      ```

      ### Commands

      ```bash
      # View resource quotas
      kubectl get resourcequotas

      # View limit ranges
      kubectl get limitranges

      # Describe quota
      kubectl describe resourcequota my-quota
      ```

      ## Events

      ```bash
      # View all events
      kubectl get events

      # Events sorted by timestamp
      kubectl get events --sort-by=.metadata.creationTimestamp

      # Watch events
      kubectl get events --watch

      # Events for specific pod
      kubectl get events --field-selector involvedObject.name=pod-name
      ```

      ## Common Troubleshooting Scenarios

      ### Pod not starting

      ```bash
      kubectl describe pod pod-name  # Check events
      kubectl logs pod-name          # Check logs
      kubectl get pod pod-name -o yaml  # Check configuration
      ```

      ### ImagePullBackOff

      - Check image name and tag
      - Verify image registry is accessible
      - Check imagePullSecrets if private registry

      ### CrashLoopBackOff

      - Check application logs: `kubectl logs pod-name --previous`
      - Verify liveness/readiness probes
      - Check resource limits

      Try debugging techniques in the labs!
    MARKDOWN
    l.reading_time_minutes = 15
  end

  ModuleItem.find_or_create_by!(
    course_module: mod5,
    item_type: 'CourseLesson',
    item: lesson5,
    sequence_order: 2
  ) { |item| item.required = true }

  puts "  ✅ Created 'Monitoring & Debugging' lesson"
end

puts "✅ Kubectl learning lessons created successfully!"
puts ""
puts "Run: rails db:seed:kubectl_learning_content"
puts "Or include in main seeds.rb file"
