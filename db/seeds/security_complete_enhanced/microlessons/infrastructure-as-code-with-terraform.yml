slug: infrastructure-as-code-with-terraform
title: Infrastructure as Code with Terraform
sequence_order: 1
estimated_minutes: 2
difficulty: easy
content_md: "# Infrastructure as Code with Terraform \U0001F680\n\n# Infrastructure\
  \ as Code with Terraform\n\n    ## Why Infrastructure as Code?\n\n    Infrastructure\
  \ as Code (IaC) treats infrastructure the same way developers treat application\
  \ code - version controlled, tested, and automated.\n\n    ### Traditional Problems\n\
  \    - **Manual provisioning**: Error-prone, slow, not repeatable\n    - **Configuration\
  \ drift**: Servers diverge from standards over time\n    - **No audit trail**: Hard\
  \ to track who changed what\n    - **Scaling challenges**: Can't quickly replicate\
  \ environments\n    - **Documentation**: Often outdated or incomplete\n\n    ###\
  \ Benefits of IaC\n    1. **Reproducibility**: Same code = same infrastructure every\
  \ time\n    2. **Version control**: Track every change, rollback if needed\n   \
  \ 3. **Automation**: Deploy faster and more reliably\n    4. **Documentation as\
  \ code**: Infrastructure is self-documenting\n    5. **Cost optimization**: Tear\
  \ down and recreate environments easily\n    6. **Testing**: Test infrastructure\
  \ changes before production\n\n    ## Terraform Overview\n\n    Terraform is an\
  \ open-source IaC tool by HashiCorp that provisions and manages infrastructure across\
  \ cloud providers.\n\n    ### Key Features\n    - **Provider agnostic**: AWS, Azure,\
  \ GCP, Kubernetes, and 1000+ providers\n    - **Declarative**: Describe desired\
  \ state, Terraform figures out how\n    - **Plan before apply**: Preview changes\
  \ before making them\n    - **Resource graph**: Understands dependencies between\
  \ resources\n    - **State management**: Tracks actual infrastructure state\n\n\
  \    ## The Terraform Workflow\n\n    ### 1. Write Configuration\n    ```hcl\n \
  \   # main.tf\n    terraform {\n      required_version = \">= 1.0\"\n      required_providers\
  \ {\n        aws = {\n          source  = \"hashicorp/aws\"\n          version =\
  \ \"~> 5.0\"\n        }\n      }\n    }\n\n    provider \"aws\" {\n      region\
  \ = var.aws_region\n    }\n\n    resource \"aws_instance\" \"web\" {\n      ami\
  \           = \"ami-0c55b159cbfafe1f0\"\n      instance_type = \"t2.micro\"\n\n\
  \      tags = {\n        Name = \"WebServer\"\n      }\n    }\n    ```\n\n    ###\
  \ 2. Initialize (`terraform init`)\n    - Downloads provider plugins\n    - Initializes\
  \ backend for state storage\n    - Prepares working directory\n\n    ```bash\n \
  \   terraform init\n    ```\n\n    ### 3. Plan (`terraform plan`)\n    - Shows what\
  \ will be created, modified, or destroyed\n    - No actual changes made\n    - Safety\
  \ check before applying\n\n    ```bash\n    terraform plan\n    ```\n\n    Output\
  \ shows:\n    ```\n    Terraform will perform the following actions:\n\n      #\
  \ aws_instance.web will be created\n      + resource \"aws_instance\" \"web\" {\n\
  \          + ami           = \"ami-0c55b159cbfafe1f0\"\n          + instance_type\
  \ = \"t2.micro\"\n          ...\n        }\n\n    Plan: 1 to add, 0 to change, 0\
  \ to destroy.\n    ```\n\n    ### 4. Apply (`terraform apply`)\n    - Creates/modifies\
  \ infrastructure to match configuration\n    - Updates state file\n    - Shows execution\
  \ plan and asks for confirmation\n\n    ```bash\n    terraform apply\n    ```\n\n\
  \    ### 5. Destroy (when needed)\n    ```bash\n    terraform destroy\n    ```\n\
  \n    ## Understanding Providers\n\n    Providers are plugins that interact with\
  \ APIs of cloud platforms and services.\n\n    ### AWS Provider\n    ```hcl\n  \
  \  provider \"aws\" {\n      region     = \"us-west-2\"\n      access_key = var.aws_access_key\n\
  \      secret_key = var.aws_secret_key\n    }\n    ```\n\n    ### Azure Provider\n\
  \    ```hcl\n    provider \"azurerm\" {\n      features {}\n      subscription_id\
  \ = var.subscription_id\n    }\n    ```\n\n    ### GCP Provider\n    ```hcl\n  \
  \  provider \"google\" {\n      project = \"my-project-id\"\n      region  = \"\
  us-central1\"\n    }\n    ```\n\n    ### Multiple Provider Instances\n    ```hcl\n\
  \    provider \"aws\" {\n      alias  = \"west\"\n      region = \"us-west-2\"\n\
  \    }\n\n    provider \"aws\" {\n      alias  = \"east\"\n      region = \"us-east-1\"\
  \n    }\n\n    resource \"aws_instance\" \"west_server\" {\n      provider = aws.west\n\
  \      ami      = \"ami-0c55b159cbfafe1f0\"\n      instance_type = \"t2.micro\"\n\
  \    }\n    ```\n\n    ## Resources vs Data Sources\n\n    ### Resources\n    Resources\
  \ create, modify, and delete infrastructure objects.\n\n    ```hcl\n    resource\
  \ \"aws_s3_bucket\" \"assets\" {\n      bucket = \"my-app-assets\"\n\n      tags\
  \ = {\n        Environment = \"Production\"\n      }\n    }\n\n    resource \"aws_s3_bucket_versioning\"\
  \ \"assets_versioning\" {\n      bucket = aws_s3_bucket.assets.id\n\n      versioning_configuration\
  \ {\n        status = \"Enabled\"\n      }\n    }\n    ```\n\n    ### Data Sources\n\
  \    Data sources fetch information about existing resources (read-only).\n\n  \
  \  ```hcl\n    # Get latest Amazon Linux 2 AMI\n    data \"aws_ami\" \"amazon_linux\"\
  \ {\n      most_recent = true\n      owners      = [\"amazon\"]\n\n      filter\
  \ {\n        name   = \"name\"\n        values = [\"amzn2-ami-hvm-*-x86_64-gp2\"\
  ]\n      }\n    }\n\n    # Use data source in resource\n    resource \"aws_instance\"\
  \ \"web\" {\n      ami           = data.aws_ami.amazon_linux.id\n      instance_type\
  \ = \"t2.micro\"\n    }\n\n    # Get existing VPC\n    data \"aws_vpc\" \"default\"\
  \ {\n      default = true\n    }\n\n    # Get availability zones\n    data \"aws_availability_zones\"\
  \ \"available\" {\n      state = \"available\"\n    }\n    ```\n\n    ## Variables\
  \ and Outputs\n\n    ### Variables (Inputs)\n    ```hcl\n    # variables.tf\n  \
  \  variable \"aws_region\" {\n      description = \"AWS region for resources\"\n\
  \      type        = string\n      default     = \"us-west-2\"\n    }\n\n    variable\
  \ \"instance_type\" {\n      description = \"EC2 instance type\"\n      type   \
  \     = string\n      default     = \"t2.micro\"\n    }\n\n    variable \"environment\"\
  \ {\n      description = \"Environment name\"\n      type        = string\n    \
  \  validation {\n        condition     = contains([\"dev\", \"staging\", \"prod\"\
  ], var.environment)\n        error_message = \"Environment must be dev, staging,\
  \ or prod.\"\n      }\n    }\n\n    variable \"tags\" {\n      description = \"\
  Common tags for all resources\"\n      type        = map(string)\n      default\
  \     = {}\n    }\n    ```\n\n    ### Using Variables\n    ```hcl\n    resource\
  \ \"aws_instance\" \"web\" {\n      ami           = data.aws_ami.amazon_linux.id\n\
  \      instance_type = var.instance_type\n\n      tags = merge(var.tags, {\n   \
  \     Name = \"web-${var.environment}\"\n      })\n    }\n    ```\n\n    ### Variable\
  \ Files\n    ```hcl\n    # terraform.tfvars\n    aws_region    = \"us-east-1\"\n\
  \    instance_type = \"t2.small\"\n    environment   = \"production\"\n\n    tags\
  \ = {\n      Project = \"MyApp\"\n      Team    = \"Platform\"\n    }\n    ```\n\
  \n    ```hcl\n    # dev.tfvars\n    environment   = \"dev\"\n    instance_type =\
  \ \"t2.micro\"\n    ```\n\n    Apply with specific file:\n    ```bash\n    terraform\
  \ apply -var-file=\"dev.tfvars\"\n    ```\n\n    ### Outputs\n    ```hcl\n    #\
  \ outputs.tf\n    output \"instance_id\" {\n      description = \"ID of the EC2\
  \ instance\"\n      value       = aws_instance.web.id\n    }\n\n    output \"instance_public_ip\"\
  \ {\n      description = \"Public IP of the instance\"\n      value       = aws_instance.web.public_ip\n\
  \    }\n\n    output \"vpc_id\" {\n      description = \"VPC ID\"\n      value \
  \      = aws_vpc.main.id\n    }\n\n    output \"db_connection_string\" {\n     \
  \ description = \"Database connection string\"\n      value       = \"postgresql://${aws_db_instance.main.endpoint}/${aws_db_instance.main.db_name}\"\
  \n      sensitive   = true\n    }\n    ```\n\n    View outputs:\n    ```bash\n \
  \   terraform output\n    terraform output instance_public_ip\n    terraform output\
  \ -json  # JSON format\n    ```\n\n    ## Complete AWS Infrastructure Example\n\n\
  \    This example creates a complete AWS infrastructure with VPC, subnets, security\
  \ groups, EC2 instance, and RDS database.\n\n    ### Project Structure\n    ```\n\
  \    infrastructure/\n    ├── main.tf\n    ├── variables.tf\n    ├── outputs.tf\n\
  \    ├── terraform.tfvars\n    └── modules/\n    ```\n\n    ### main.tf\n    ```hcl\n\
  \    terraform {\n      required_version = \">= 1.0\"\n      required_providers\
  \ {\n        aws = {\n          source  = \"hashicorp/aws\"\n          version =\
  \ \"~> 5.0\"\n        }\n      }\n    }\n\n    provider \"aws\" {\n      region\
  \ = var.aws_region\n    }\n\n    # VPC\n    resource \"aws_vpc\" \"main\" {\n  \
  \    cidr_block           = var.vpc_cidr\n      enable_dns_hostnames = true\n  \
  \    enable_dns_support   = true\n\n      tags = {\n        Name        = \"${var.project_name}-vpc\"\
  \n        Environment = var.environment\n      }\n    }\n\n    # Internet Gateway\n\
  \    resource \"aws_internet_gateway\" \"main\" {\n      vpc_id = aws_vpc.main.id\n\
  \n      tags = {\n        Name = \"${var.project_name}-igw\"\n      }\n    }\n\n\
  \    # Public Subnets\n    resource \"aws_subnet\" \"public\" {\n      count   \
  \                = length(var.availability_zones)\n      vpc_id                \
  \  = aws_vpc.main.id\n      cidr_block              = cidrsubnet(var.vpc_cidr, 8,\
  \ count.index)\n      availability_zone       = var.availability_zones[count.index]\n\
  \      map_public_ip_on_launch = true\n\n      tags = {\n        Name = \"${var.project_name}-public-${count.index\
  \ + 1}\"\n        Type = \"Public\"\n      }\n    }\n\n    # Private Subnets\n \
  \   resource \"aws_subnet\" \"private\" {\n      count             = length(var.availability_zones)\n\
  \      vpc_id            = aws_vpc.main.id\n      cidr_block        = cidrsubnet(var.vpc_cidr,\
  \ 8, count.index + 100)\n      availability_zone = var.availability_zones[count.index]\n\
  \n      tags = {\n        Name = \"${var.project_name}-private-${count.index + 1}\"\
  \n        Type = \"Private\"\n      }\n    }\n\n    # Public Route Table\n    resource\
  \ \"aws_route_table\" \"public\" {\n      vpc_id = aws_vpc.main.id\n\n      route\
  \ {\n        cidr_block = \"0.0.0.0/0\"\n        gateway_id = aws_internet_gateway.main.id\n\
  \      }\n\n      tags = {\n        Name = \"${var.project_name}-public-rt\"\n \
  \     }\n    }\n\n    # Associate Public Subnets with Public Route Table\n    resource\
  \ \"aws_route_table_association\" \"public\" {\n      count          = length(aws_subnet.public)\n\
  \      subnet_id      = aws_subnet.public[count.index].id\n      route_table_id\
  \ = aws_route_table.public.id\n    }\n\n    # Security Group for Web Server\n  \
  \  resource \"aws_security_group\" \"web\" {\n      name        = \"${var.project_name}-web-sg\"\
  \n      description = \"Security group for web servers\"\n      vpc_id      = aws_vpc.main.id\n\
  \n      ingress {\n        description = \"HTTP\"\n        from_port   = 80\n  \
  \      to_port     = 80\n        protocol    = \"tcp\"\n        cidr_blocks = [\"\
  0.0.0.0/0\"]\n      }\n\n      ingress {\n        description = \"HTTPS\"\n    \
  \    from_port   = 443\n        to_port     = 443\n        protocol    = \"tcp\"\
  \n        cidr_blocks = [\"0.0.0.0/0\"]\n      }\n\n      ingress {\n        description\
  \ = \"SSH\"\n        from_port   = 22\n        to_port     = 22\n        protocol\
  \    = \"tcp\"\n        cidr_blocks = [var.admin_cidr]\n      }\n\n      egress\
  \ {\n        description = \"Allow all outbound\"\n        from_port   = 0\n   \
  \     to_port     = 0\n        protocol    = \"-1\"\n        cidr_blocks = [\"0.0.0.0/0\"\
  ]\n      }\n\n      tags = {\n        Name = \"${var.project_name}-web-sg\"\n  \
  \    }\n    }\n\n    # Security Group for RDS\n    resource \"aws_security_group\"\
  \ \"db\" {\n      name        = \"${var.project_name}-db-sg\"\n      description\
  \ = \"Security group for RDS database\"\n      vpc_id      = aws_vpc.main.id\n\n\
  \      ingress {\n        description     = \"PostgreSQL from web servers\"\n  \
  \      from_port       = 5432\n        to_port         = 5432\n        protocol\
  \        = \"tcp\"\n        security_groups = [aws_security_group.web.id]\n    \
  \  }\n\n      egress {\n        description = \"Allow all outbound\"\n        from_port\
  \   = 0\n        to_port     = 0\n        protocol    = \"-1\"\n        cidr_blocks\
  \ = [\"0.0.0.0/0\"]\n      }\n\n      tags = {\n        Name = \"${var.project_name}-db-sg\"\
  \n      }\n    }\n\n    # Get Latest Amazon Linux 2 AMI\n    data \"aws_ami\" \"\
  amazon_linux\" {\n      most_recent = true\n      owners      = [\"amazon\"]\n\n\
  \      filter {\n        name   = \"name\"\n        values = [\"amzn2-ami-hvm-*-x86_64-gp2\"\
  ]\n      }\n\n      filter {\n        name   = \"virtualization-type\"\n       \
  \ values = [\"hvm\"]\n      }\n    }\n\n    # EC2 Instance\n    resource \"aws_instance\"\
  \ \"web\" {\n      ami                    = data.aws_ami.amazon_linux.id\n     \
  \ instance_type          = var.instance_type\n      subnet_id              = aws_subnet.public[0].id\n\
  \      vpc_security_group_ids = [aws_security_group.web.id]\n      key_name    \
  \           = var.key_name\n\n      user_data = <<-EOF\n                  #!/bin/bash\n\
  \                  yum update -y\n                  yum install -y httpd\n     \
  \             systemctl start httpd\n                  systemctl enable httpd\n\
  \                  echo \"<h1>Hello from Terraform!</h1>\" > /var/www/html/index.html\n\
  \                  EOF\n\n      root_block_device {\n        volume_size = 20\n\
  \        volume_type = \"gp3\"\n        encrypted   = true\n      }\n\n      tags\
  \ = {\n        Name        = \"${var.project_name}-web-server\"\n        Environment\
  \ = var.environment\n      }\n    }\n\n    # DB Subnet Group\n    resource \"aws_db_subnet_group\"\
  \ \"main\" {\n      name       = \"${var.project_name}-db-subnet-group\"\n     \
  \ subnet_ids = aws_subnet.private[*].id\n\n      tags = {\n        Name = \"${var.project_name}-db-subnet-group\"\
  \n      }\n    }\n\n    # RDS Instance\n    resource \"aws_db_instance\" \"main\"\
  \ {\n      identifier             = \"${var.project_name}-db\"\n      engine   \
  \              = \"postgres\"\n      engine_version         = \"15.3\"\n      instance_class\
  \         = var.db_instance_class\n      allocated_storage      = 20\n      storage_type\
  \           = \"gp3\"\n      storage_encrypted      = true\n\n      db_name  = var.db_name\n\
  \      username = var.db_username\n      password = var.db_password\n\n      db_subnet_group_name\
  \   = aws_db_subnet_group.main.name\n      vpc_security_group_ids = [aws_security_group.db.id]\n\
  \n      backup_retention_period = 7\n      backup_window          = \"03:00-04:00\"\
  \n      maintenance_window     = \"mon:04:00-mon:05:00\"\n\n      skip_final_snapshot\
  \ = var.environment != \"production\"\n      final_snapshot_identifier = var.environment\
  \ == \"production\" ? \"${var.project_name}-final-snapshot-${formatdate(\"YYYY-MM-DD-hhmm\"\
  , timestamp())}\" : null\n\n      tags = {\n        Name        = \"${var.project_name}-database\"\
  \n        Environment = var.environment\n      }\n    }\n    ```\n\n    ### variables.tf\n\
  \    ```hcl\n    variable \"aws_region\" {\n      description = \"AWS region\"\n\
  \      type        = string\n      default     = \"us-west-2\"\n    }\n\n    variable\
  \ \"project_name\" {\n      description = \"Project name for resource naming\"\n\
  \      type        = string\n    }\n\n    variable \"environment\" {\n      description\
  \ = \"Environment (dev, staging, prod)\"\n      type        = string\n    }\n\n\
  \    variable \"vpc_cidr\" {\n      description = \"CIDR block for VPC\"\n     \
  \ type        = string\n      default     = \"10.0.0.0/16\"\n    }\n\n    variable\
  \ \"availability_zones\" {\n      description = \"List of availability zones\"\n\
  \      type        = list(string)\n      default     = [\"us-west-2a\", \"us-west-2b\"\
  ]\n    }\n\n    variable \"instance_type\" {\n      description = \"EC2 instance\
  \ type\"\n      type        = string\n      default     = \"t3.micro\"\n    }\n\n\
  \    variable \"key_name\" {\n      description = \"SSH key pair name\"\n      type\
  \        = string\n    }\n\n    variable \"admin_cidr\" {\n      description = \"\
  CIDR block for admin SSH access\"\n      type        = string\n    }\n\n    variable\
  \ \"db_instance_class\" {\n      description = \"RDS instance class\"\n      type\
  \        = string\n      default     = \"db.t3.micro\"\n    }\n\n    variable \"\
  db_name\" {\n      description = \"Database name\"\n      type        = string\n\
  \    }\n\n    variable \"db_username\" {\n      description = \"Database admin username\"\
  \n      type        = string\n      sensitive   = true\n    }\n\n    variable \"\
  db_password\" {\n      description = \"Database admin password\"\n      type   \
  \     = string\n      sensitive   = true\n    }\n    ```\n\n    ### outputs.tf\n\
  \    ```hcl\n    output \"vpc_id\" {\n      description = \"VPC ID\"\n      value\
  \       = aws_vpc.main.id\n    }\n\n    output \"public_subnet_ids\" {\n      description\
  \ = \"Public subnet IDs\"\n      value       = aws_subnet.public[*].id\n    }\n\n\
  \    output \"private_subnet_ids\" {\n      description = \"Private subnet IDs\"\
  \n      value       = aws_subnet.private[*].id\n    }\n\n    output \"web_instance_id\"\
  \ {\n      description = \"Web server instance ID\"\n      value       = aws_instance.web.id\n\
  \    }\n\n    output \"web_public_ip\" {\n      description = \"Web server public\
  \ IP\"\n      value       = aws_instance.web.public_ip\n    }\n\n    output \"web_url\"\
  \ {\n      description = \"Web server URL\"\n      value       = \"http://${aws_instance.web.public_ip}\"\
  \n    }\n\n    output \"db_endpoint\" {\n      description = \"RDS endpoint\"\n\
  \      value       = aws_db_instance.main.endpoint\n    }\n\n    output \"db_connection_string\"\
  \ {\n      description = \"Database connection string\"\n      value       = \"\
  postgresql://${var.db_username}@${aws_db_instance.main.endpoint}/${var.db_name}\"\
  \n      sensitive   = true\n    }\n    ```\n\n    ### terraform.tfvars\n    ```hcl\n\
  \    project_name = \"myapp\"\n    environment  = \"dev\"\n    aws_region   = \"\
  us-west-2\"\n    key_name     = \"my-key-pair\"\n    admin_cidr   = \"203.0.113.0/24\"\
  \  # Replace with your IP\n\n    db_name     = \"myappdb\"\n    db_username = \"\
  dbadmin\"\n    db_password = \"SuperSecret123!\"  # Use AWS Secrets Manager in production\n\
  \    ```\n\n    ## Deployment Commands\n\n    ```bash\n    # Initialize Terraform\n\
  \    terraform init\n\n    # Validate configuration\n    terraform validate\n\n\
  \    # Format code\n    terraform fmt\n\n    # Preview changes\n    terraform plan\n\
  \n    # Apply changes\n    terraform apply\n\n    # View outputs\n    terraform\
  \ output\n\n    # Get specific output\n    terraform output web_public_ip\n\n  \
  \  # Access the web server\n    curl $(terraform output -raw web_public_ip)\n\n\
  \    # Connect to database\n    psql $(terraform output -raw db_connection_string)\n\
  \n    # Destroy everything\n    terraform destroy\n    ```\n\n    ## Best Practices\n\
  \n    1. **Use version control**: Always commit Terraform code to Git\n    2. **Never\
  \ commit secrets**: Use variables, environment variables, or secret managers\n \
  \   3. **Use remote state**: Store state in S3, Terraform Cloud, or other backends\n\
  \    4. **Lock state**: Prevent concurrent modifications\n    5. **Use workspaces\
  \ or separate state**: Isolate environments\n    6. **Tag resources**: Make tracking\
  \ and cost allocation easier\n    7. **Use data sources**: Reference existing resources\
  \ instead of hardcoding\n    8. **Enable encryption**: Encrypt volumes, databases,\
  \ and state files\n    9. **Plan before apply**: Always review changes\n    10.\
  \ **Automate with CI/CD**: Integrate Terraform into pipelines\n\n    ## Summary\n\
  \n    Infrastructure as Code with Terraform enables:\n    - Automated, reproducible\
  \ infrastructure provisioning\n    - Version-controlled infrastructure changes\n\
  \    - Multi-cloud and provider-agnostic deployments\n    - Predictable and testable\
  \ infrastructure changes\n    - Complete infrastructure lifecycle management\n\n\
  \    The basic workflow is: write configuration → init → plan → apply → manage state."
exercises:
- type: mcq
  slug: infrastructure-as-code-with-terraform-mcq
  sequence_order: 1
  question: What is the purpose of terraform plan before applying changes?
  options:
  - It shows exactly what resources will be created, modified, or destroyed without
    making actual changes, providing a safety preview
  - It automatically applies all changes to infrastructure
  - It generates documentation for your infrastructure
  - It backs up your current infrastructure configuration
  correct_answer_index: 0
  explanation: The terraform plan command is a crucial safety step that shows you
    exactly what Terraform will do before making any actual changes to your infrastructure.
    It displays which resources will be created (+), modified (~), or destroyed (-),
    allowing you to review and verify changes before applying them. This preview helps
    prevent costly mistakes and unexpected infrastructure changes. Always run terraform
    plan before terraform apply in production.
objectives:
- Define the control
- Choose tooling
- Integrate checks in CI/CD
next_recommended: []
