# Go/Golang Code Labs - Seed Data
# These are coding editor-based labs for learning Go

puts "Creating Go Code Labs..."

# Lab 1: Slices and Arrays
golang_lab_1 = HandsOnLab.create!(
  title: 'Go Slices and Arrays',
  description: 'Master Go slices and learn to manipulate collections efficiently',
  lab_type: 'golang',
  lab_format: 'code_editor',
  programming_language: 'golang',
  difficulty: 'easy',
  estimated_minutes: 20,
  points_reward: 100,
  max_attempts: 10,
  time_limit_seconds: 10,
  memory_limit_mb: 256,
  published: true,
  sequence_order: 1,

  starter_code: <<~GOLANG,
    package main

    import "fmt"

    // FilterEvenNumbers returns a new slice containing only even numbers
    // from the input slice.
    //
    // Example:
    //   input: []int{1, 2, 3, 4, 5, 6}
    //   output: []int{2, 4, 6}
    func FilterEvenNumbers(numbers []int) []int {
        // Your code here
        return nil
    }

    func main() {
        result := FilterEvenNumbers([]int{1, 2, 3, 4, 5, 6})
        fmt.Println(result)
    }
  GOLANG

  solution_code: <<~GOLANG,
    package main

    import "fmt"

    func FilterEvenNumbers(numbers []int) []int {
        result := []int{}
        for _, num := range numbers {
            if num%2 == 0 {
                result = append(result, num)
            }
        }
        return result
    }

    func main() {
        result := FilterEvenNumbers([]int{1, 2, 3, 4, 5, 6})
        fmt.Println(result)
    }
  GOLANG

  test_cases: [
    {
      description: 'Filter even numbers from mixed slice',
      input: nil,
      expected_output: '[2 4 6]',
      hidden: false
    },
    {
      description: 'Empty slice',
      input: nil,
      expected_output: '[]',
      hidden: false
    },
    {
      description: 'All odd numbers',
      input: nil,
      expected_output: '[]',
      hidden: false
    },
    {
      description: 'Large numbers with negatives',
      input: nil,
      expected_output: '[-4 -2 0 2 100 200]',
      hidden: true
    }
  ],

  steps: [
    {
      step_number: 1,
      instruction: 'Implement FilterEvenNumbers function using a for range loop',
      hint: 'Create an empty slice, iterate through input, and use modulo operator (%) to check if number is even',
      description: 'Filter even numbers using Go slices'
    }
  ],

  allowed_imports: ['fmt'],
  is_active: true
)

# Lab 2: Maps and Structs
golang_lab_2 = HandsOnLab.create!(
  title: 'Go Maps and Data Structures',
  description: 'Work with Go maps to count and organize data',
  lab_type: 'golang',
  lab_format: 'code_editor',
  programming_language: 'golang',
  difficulty: 'medium',
  estimated_minutes: 25,
  points_reward: 150,
  max_attempts: 10,
  time_limit_seconds: 10,
  memory_limit_mb: 256,
  published: true,
  sequence_order: 2,

  starter_code: <<~GOLANG,
    package main

    import (
        "fmt"
        "strings"
    )

    // CountWords counts the frequency of each word in the given text.
    // Words should be case-insensitive.
    //
    // Example:
    //   input: "Hello world hello"
    //   output: map[string]int{"hello": 2, "world": 1}
    func CountWords(text string) map[string]int {
        // Your code here
        return nil
    }

    func main() {
        result := CountWords("Hello world hello")
        fmt.Println(result)
    }
  GOLANG

  solution_code: <<~GOLANG,
    package main

    import (
        "fmt"
        "strings"
    )

    func CountWords(text string) map[string]int {
        // Convert to lowercase and split into words
        words := strings.Fields(strings.ToLower(text))

        // Count frequencies
        frequency := make(map[string]int)
        for _, word := range words {
            frequency[word]++
        }

        return frequency
    }

    func main() {
        result := CountWords("Hello world hello")
        fmt.Println(result)
    }
  GOLANG

  test_cases: [
    {
      description: 'Count words in simple text',
      input: nil,
      expected_output: 'map[hello:2 world:1]',
      hidden: false
    },
    {
      description: 'Empty string',
      input: nil,
      expected_output: 'map[]',
      hidden: false
    },
    {
      description: 'Single word',
      input: nil,
      expected_output: 'map[go:1]',
      hidden: false
    },
    {
      description: 'Multiple occurrences',
      input: nil,
      expected_output: 'map[brown:1 dog:1 fox:1 jumps:1 lazy:1 over:1 quick:1 the:2]',
      hidden: true
    }
  ],

  steps: [
    {
      step_number: 1,
      instruction: 'Convert text to lowercase and split into words',
      hint: 'Use strings.ToLower() and strings.Fields() to parse words',
      description: 'Parse text into words'
    },
    {
      step_number: 2,
      instruction: 'Count word frequencies using a map',
      hint: 'Create a map with make(map[string]int) and increment counts',
      description: 'Build frequency map'
    }
  ],

  allowed_imports: ['fmt', 'strings'],
  is_active: true
)

# Lab 3: Concurrency with Goroutines
golang_lab_3 = HandsOnLab.create!(
  title: 'Go Concurrency Basics',
  description: 'Learn Go concurrency with goroutines and channels',
  lab_type: 'golang',
  lab_format: 'code_editor',
  programming_language: 'golang',
  difficulty: 'hard',
  estimated_minutes: 35,
  points_reward: 200,
  max_attempts: 15,
  time_limit_seconds: 10,
  memory_limit_mb: 256,
  published: true,
  sequence_order: 3,

  starter_code: <<~GOLANG,
    package main

    import (
        "fmt"
    )

    // SumConcurrent calculates the sum of numbers in a slice using multiple goroutines.
    // Split the work across numWorkers goroutines and aggregate results using channels.
    //
    // Example:
    //   input: []int{1, 2, 3, 4, 5, 6}, numWorkers: 2
    //   output: 21
    func SumConcurrent(numbers []int, numWorkers int) int {
        // Your code here
        return 0
    }

    func main() {
        result := SumConcurrent([]int{1, 2, 3, 4, 5, 6}, 2)
        fmt.Println(result)
    }
  GOLANG

  solution_code: <<~GOLANG,
    package main

    import (
        "fmt"
    )

    func SumConcurrent(numbers []int, numWorkers int) int {
        if len(numbers) == 0 {
            return 0
        }

        resultChan := make(chan int, numWorkers)
        chunkSize := (len(numbers) + numWorkers - 1) / numWorkers

        // Launch workers
        for i := 0; i < numWorkers; i++ {
            start := i * chunkSize
            end := start + chunkSize
            if end > len(numbers) {
                end = len(numbers)
            }

            go func(chunk []int) {
                sum := 0
                for _, num := range chunk {
                    sum += num
                }
                resultChan <- sum
            }(numbers[start:end])
        }

        // Aggregate results
        total := 0
        for i := 0; i < numWorkers; i++ {
            total += <-resultChan
        }

        return total
    }

    func main() {
        result := SumConcurrent([]int{1, 2, 3, 4, 5, 6}, 2)
        fmt.Println(result)
    }
  GOLANG

  test_cases: [
    {
      description: 'Sum with 2 workers',
      input: nil,
      expected_output: '21',
      hidden: false
    },
    {
      description: 'Sum with 3 workers',
      input: nil,
      expected_output: '21',
      hidden: false
    },
    {
      description: 'Empty slice',
      input: nil,
      expected_output: '0',
      hidden: false
    },
    {
      description: 'Large slice with 4 workers',
      input: nil,
      expected_output: '5050',
      hidden: true
    }
  ],

  steps: [
    {
      step_number: 1,
      instruction: 'Create a buffered channel for results',
      hint: 'Use make(chan int, numWorkers) to create a channel',
      description: 'Set up communication channel'
    },
    {
      step_number: 2,
      instruction: 'Split work and launch goroutines',
      hint: 'Calculate chunk size and use go keyword to launch worker functions',
      description: 'Implement concurrent workers'
    },
    {
      step_number: 3,
      instruction: 'Aggregate results from channel',
      hint: 'Use <-resultChan to receive values from all workers',
      description: 'Collect and sum results'
    }
  ],

  allowed_imports: ['fmt'],
  is_active: true
)

# Lab 4: Error Handling
golang_lab_4 = HandsOnLab.create!(
  title: 'Go Error Handling',
  description: 'Master proper error handling patterns in Go',
  lab_type: 'golang',
  lab_format: 'code_editor',
  programming_language: 'golang',
  difficulty: 'medium',
  estimated_minutes: 20,
  points_reward: 150,
  max_attempts: 10,
  time_limit_seconds: 10,
  memory_limit_mb: 256,
  published: true,
  sequence_order: 4,

  starter_code: <<~GOLANG,
    package main

    import (
        "errors"
        "fmt"
    )

    // Divide performs division of two integers.
    // Returns an error if the divisor is zero.
    //
    // Example:
    //   Divide(10, 2) => 5, nil
    //   Divide(10, 0) => 0, error("division by zero")
    func Divide(a, b int) (int, error) {
        // Your code here
        return 0, nil
    }

    func main() {
        result, err := Divide(10, 2)
        if err != nil {
            fmt.Println("Error:", err)
        } else {
            fmt.Println("Result:", result)
        }
    }
  GOLANG

  solution_code: <<~GOLANG,
    package main

    import (
        "errors"
        "fmt"
    )

    func Divide(a, b int) (int, error) {
        if b == 0 {
            return 0, errors.New("division by zero")
        }
        return a / b, nil
    }

    func main() {
        result, err := Divide(10, 2)
        if err != nil {
            fmt.Println("Error:", err)
        } else {
            fmt.Println("Result:", result)
        }
    }
  GOLANG

  test_cases: [
    {
      description: 'Valid division',
      input: nil,
      expected_output: 'Result: 5',
      hidden: false
    },
    {
      description: 'Division by zero',
      input: nil,
      expected_output: 'Error: division by zero',
      hidden: false
    },
    {
      description: 'Negative numbers',
      input: nil,
      expected_output: 'Result: -5',
      hidden: false
    },
    {
      description: 'Large numbers',
      input: nil,
      expected_output: 'Result: 100',
      hidden: true
    }
  ],

  steps: [
    {
      step_number: 1,
      instruction: 'Check if divisor is zero',
      hint: 'Use an if statement to check if b == 0',
      description: 'Validate input'
    },
    {
      step_number: 2,
      instruction: 'Return error for division by zero',
      hint: 'Use errors.New("division by zero") to create an error',
      description: 'Handle error case'
    },
    {
      step_number: 3,
      instruction: 'Return result for valid division',
      hint: 'Return a / b, nil for successful division',
      description: 'Return success result'
    }
  ],

  allowed_imports: ['errors', 'fmt'],
  is_active: true
)

# Lab 5: Struct Manipulation
golang_lab_5 = HandsOnLab.create!(
  title: 'Go Structs - Person Manager',
  description: 'Practice creating and manipulating Go structs',
  lab_type: 'golang',
  lab_format: 'code_editor',
  programming_language: 'golang',
  difficulty: 'easy',
  estimated_minutes: 25,
  points_reward: 120,
  max_attempts: 10,
  time_limit_seconds: 10,
  memory_limit_mb: 256,
  published: true,
  sequence_order: 5,

  starter_code: <<~GOLANG,
    package main

    import "fmt"

    // Person represents a person with name and age
    type Person struct {
        Name string
        Age  int
    }

    // NewPerson creates a new Person with the given name and age.
    // It should return a pointer to the Person.
    //
    // Example:
    //   NewPerson("Alice", 30) returns &Person{Name: "Alice", Age: 30}
    func NewPerson(name string, age int) *Person {
        // Your code here
        return nil
    }

    // GetOlder increases the person's age by the given years.
    // Example:
    //   person := &Person{Name: "Bob", Age: 25}
    //   person.GetOlder(5)  // Bob is now 30
    func (p *Person) GetOlder(years int) {
        // Your code here
    }

    // Greet returns a greeting message with the person's name.
    // Example:
    //   person := &Person{Name: "Alice", Age: 30}
    //   person.Greet() returns "Hello, my name is Alice"
    func (p *Person) Greet() string {
        // Your code here
        return ""
    }

    func main() {
        person := NewPerson("Alice", 30)
        fmt.Println(person.Greet())
        person.GetOlder(5)
        fmt.Printf("%s is now %d years old\\n", person.Name, person.Age)
    }
  GOLANG

  solution_code: <<~GOLANG,
    package main

    import "fmt"

    type Person struct {
        Name string
        Age  int
    }

    func NewPerson(name string, age int) *Person {
        return &Person{
            Name: name,
            Age:  age,
        }
    }

    func (p *Person) GetOlder(years int) {
        p.Age += years
    }

    func (p *Person) Greet() string {
        return fmt.Sprintf("Hello, my name is %s", p.Name)
    }

    func main() {
        person := NewPerson("Alice", 30)
        fmt.Println(person.Greet())
        person.GetOlder(5)
        fmt.Printf("%s is now %d years old\\n", person.Name, person.Age)
    }
  GOLANG

  test_cases: [
    {
      description: 'Create person and greet',
      input: nil,
      expected_output: 'Hello, my name is Alice',
      hidden: false
    },
    {
      description: 'Person ages correctly',
      input: nil,
      expected_output: 'Alice is now 35 years old',
      hidden: false
    },
    {
      description: 'Multiple people work independently',
      input: nil,
      expected_output: 'Bob is now 40 years old',
      hidden: true
    }
  ],

  learning_objectives: [
    'Define custom struct types in Go',
    'Create constructor functions',
    'Implement methods with pointer receivers',
    'Understand value vs pointer semantics'
  ],

  steps: [
    {
      step_number: 1,
      instruction: 'Implement NewPerson constructor that returns a pointer',
      hint: 'Use &Person{...} to create and return a pointer to a Person struct',
      description: 'Create Person constructor'
    },
    {
      step_number: 2,
      instruction: 'Implement GetOlder method to increment age',
      hint: 'Use pointer receiver (p *Person) and modify p.Age directly',
      description: 'Add method to modify struct'
    },
    {
      step_number: 3,
      instruction: 'Implement Greet method that returns formatted string',
      hint: 'Use fmt.Sprintf to create a formatted greeting string',
      description: 'Return greeting message'
    }
  ],

  allowed_imports: ['fmt'],
  is_active: true
)

# Lab 6: Map Operations
golang_lab_6 = HandsOnLab.create!(
  title: 'Go Maps - Word Counter',
  description: 'Count word frequencies using Go maps',
  lab_type: 'golang',
  lab_format: 'code_editor',
  programming_language: 'golang',
  difficulty: 'medium',
  estimated_minutes: 25,
  points_reward: 150,
  max_attempts: 10,
  time_limit_seconds: 10,
  memory_limit_mb: 256,
  published: true,
  sequence_order: 6,

  starter_code: <<~GOLANG,
    package main

    import (
        "fmt"
        "strings"
    )

    // CountWords takes a sentence and returns a map of word frequencies.
    // Words should be converted to lowercase.
    //
    // Example:
    //   input: "Hello world hello"
    //   output: map[string]int{"hello": 2, "world": 1}
    func CountWords(sentence string) map[string]int {
        // Your code here
        return nil
    }

    // MostFrequentWord returns the word that appears most often.
    // If there's a tie, return any of the most frequent words.
    //
    // Example:
    //   input: map[string]int{"hello": 3, "world": 1, "go": 2}
    //   output: "hello"
    func MostFrequentWord(counts map[string]int) string {
        // Your code here
        return ""
    }

    func main() {
        sentence := "Go is great Go is awesome Go rocks"
        counts := CountWords(sentence)
        fmt.Println("Word counts:", counts)
        fmt.Println("Most frequent:", MostFrequentWord(counts))
    }
  GOLANG

  solution_code: <<~GOLANG,
    package main

    import (
        "fmt"
        "strings"
    )

    func CountWords(sentence string) map[string]int {
        counts := make(map[string]int)
        words := strings.Fields(sentence)

        for _, word := range words {
            word = strings.ToLower(word)
            counts[word]++
        }

        return counts
    }

    func MostFrequentWord(counts map[string]int) string {
        maxCount := 0
        maxWord := ""

        for word, count := range counts {
            if count > maxCount {
                maxCount = count
                maxWord = word
            }
        }

        return maxWord
    }

    func main() {
        sentence := "Go is great Go is awesome Go rocks"
        counts := CountWords(sentence)
        fmt.Println("Word counts:", counts)
        fmt.Println("Most frequent:", MostFrequentWord(counts))
    }
  GOLANG

  test_cases: [
    {
      description: 'Count words in simple sentence',
      input: nil,
      expected_output: 'map[awesome:1 go:3 great:1 is:2 rocks:1]',
      hidden: false
    },
    {
      description: 'Find most frequent word',
      input: nil,
      expected_output: 'Most frequent: go',
      hidden: false
    },
    {
      description: 'Handle case insensitivity',
      input: nil,
      expected_output: 'map[hello:3 world:2]',
      hidden: true
    }
  ],

  learning_objectives: [
    'Create and manipulate Go maps',
    'Use strings package for text processing',
    'Iterate over map key-value pairs',
    'Find maximum value in a map'
  ],

  steps: [
    {
      step_number: 1,
      instruction: 'Implement CountWords using make(map[string]int) and strings.Fields',
      hint: 'Split sentence with strings.Fields, convert to lowercase, and increment count for each word',
      description: 'Count word frequencies'
    },
    {
      step_number: 2,
      instruction: 'Implement MostFrequentWord by iterating through the map',
      hint: 'Track maxCount and maxWord while ranging over the map',
      description: 'Find most common word'
    }
  ],

  allowed_imports: ['fmt', 'strings'],
  is_active: true
)

puts "Created #{HandsOnLab.where(lab_format: 'code_editor', programming_language: 'golang').count} Go code labs"
