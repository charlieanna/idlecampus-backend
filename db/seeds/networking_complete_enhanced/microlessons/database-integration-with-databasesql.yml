slug: database-integration-with-databasesql
title: Database Integration with database/sql
sequence_order: 1
estimated_minutes: 2
difficulty: easy
content_md: "# Database Integration with database/sql \U0001F680\n\n# Database Integration\
  \ with database/sql\n\n    Go's `database/sql` package provides a generic interface\
  \ for working with SQL databases. It works with PostgreSQL, MySQL, SQLite, and others.\n\
  \n    ## Installing Database Driver\n\n    For PostgreSQL, use the `pq` driver:\n\
  \n    ```bash\n    go get github.com/lib/pq\n    ```\n\n    For SQLite (lightweight,\
  \ great for learning):\n    ```bash\n    go get github.com/mattn/go-sqlite3\n  \
  \  ```\n\n    ## Connecting to a Database\n\n    ```go\n    package main\n\n   \
  \ import (\n        \"database/sql\"\n        \"fmt\"\n        \"log\"\n\n     \
  \   _ \"github.com/lib/pq\" // PostgreSQL driver\n    )\n\n    func main() {\n \
  \       // Connection string format:\n        // \"postgres://user:password@localhost/dbname?sslmode=disable\"\
  \n        connStr := \"postgres://user:pass@localhost/mydb?sslmode=disable\"\n\n\
  \        db, err := sql.Open(\"postgres\", connStr)\n        if err != nil {\n \
  \           log.Fatal(err)\n        }\n        defer db.Close()\n\n        // Test\
  \ connection\n        err = db.Ping()\n        if err != nil {\n            log.Fatal(\"\
  Cannot connect to database:\", err)\n        }\n\n        fmt.Println(\"Successfully\
  \ connected to database!\")\n    }\n    ```\n\n    ## SQLite (for local development)\n\
  \n    ```go\n    import (\n        \"database/sql\"\n        _ \"github.com/mattn/go-sqlite3\"\
  \n    )\n\n    func main() {\n        db, err := sql.Open(\"sqlite3\", \"./myapp.db\"\
  )\n        if err != nil {\n            log.Fatal(err)\n        }\n        defer\
  \ db.Close()\n    }\n    ```\n\n    ## Creating Tables\n\n    ```go\n    func createTables(db\
  \ *sql.DB) error {\n        query := `\n        CREATE TABLE IF NOT EXISTS users\
  \ (\n            id SERIAL PRIMARY KEY,\n            name VARCHAR(100) NOT NULL,\n\
  \            email VARCHAR(100) UNIQUE NOT NULL,\n            created_at TIMESTAMP\
  \ DEFAULT CURRENT_TIMESTAMP\n        );\n\n        CREATE TABLE IF NOT EXISTS tasks\
  \ (\n            id SERIAL PRIMARY KEY,\n            user_id INTEGER REFERENCES\
  \ users(id),\n            title VARCHAR(200) NOT NULL,\n            description\
  \ TEXT,\n            completed BOOLEAN DEFAULT FALSE,\n            created_at TIMESTAMP\
  \ DEFAULT CURRENT_TIMESTAMP\n        );\n        `\n\n        _, err := db.Exec(query)\n\
  \        return err\n    }\n    ```\n\n    ## INSERT - Creating Records\n\n    ```go\n\
  \    type User struct {\n        ID        int\n        Name      string\n     \
  \   Email     string\n        CreatedAt time.Time\n    }\n\n    func createUser(db\
  \ *sql.DB, name, email string) (int, error) {\n        query := `\n            INSERT\
  \ INTO users (name, email)\n            VALUES ($1, $2)\n            RETURNING id\n\
  \        `\n\n        var userID int\n        err := db.QueryRow(query, name, email).Scan(&userID)\n\
  \        if err != nil {\n            return 0, err\n        }\n\n        return\
  \ userID, nil\n    }\n\n    // Usage\n    userID, err := createUser(db, \"Alice\"\
  , \"alice@example.com\")\n    if err != nil {\n        log.Fatal(err)\n    }\n \
  \   fmt.Printf(\"Created user with ID: %d\\\\n\", userID)\n    ```\n\n    ## SELECT\
  \ - Reading Records\n\n    ### Query Single Row\n\n    ```go\n    func getUserByID(db\
  \ *sql.DB, id int) (*User, error) {\n        query := `\n            SELECT id,\
  \ name, email, created_at\n            FROM users\n            WHERE id = $1\n \
  \       `\n\n        user := &User{}\n        err := db.QueryRow(query, id).Scan(\n\
  \            &user.ID,\n            &user.Name,\n            &user.Email,\n    \
  \        &user.CreatedAt,\n        )\n\n        if err == sql.ErrNoRows {\n    \
  \        return nil, fmt.Errorf(\"user not found\")\n        }\n        if err !=\
  \ nil {\n            return nil, err\n        }\n\n        return user, nil\n  \
  \  }\n    ```\n\n    ### Query Multiple Rows\n\n    ```go\n    func getAllUsers(db\
  \ *sql.DB) ([]User, error) {\n        query := `\n            SELECT id, name, email,\
  \ created_at\n            FROM users\n            ORDER BY created_at DESC\n   \
  \     `\n\n        rows, err := db.Query(query)\n        if err != nil {\n     \
  \       return nil, err\n        }\n        defer rows.Close()\n\n        var users\
  \ []User\n\n        for rows.Next() {\n            var user User\n            err\
  \ := rows.Scan(\n                &user.ID,\n                &user.Name,\n      \
  \          &user.Email,\n                &user.CreatedAt,\n            )\n     \
  \       if err != nil {\n                return nil, err\n            }\n      \
  \      users = append(users, user)\n        }\n\n        // Check for errors during\
  \ iteration\n        if err = rows.Err(); err != nil {\n            return nil,\
  \ err\n        }\n\n        return users, nil\n    }\n    ```\n\n    ## UPDATE -\
  \ Modifying Records\n\n    ```go\n    func updateUser(db *sql.DB, id int, name,\
  \ email string) error {\n        query := `\n            UPDATE users\n        \
  \    SET name = $1, email = $2\n            WHERE id = $3\n        `\n\n       \
  \ result, err := db.Exec(query, name, email, id)\n        if err != nil {\n    \
  \        return err\n        }\n\n        rowsAffected, err := result.RowsAffected()\n\
  \        if err != nil {\n            return err\n        }\n\n        if rowsAffected\
  \ == 0 {\n            return fmt.Errorf(\"user not found\")\n        }\n\n     \
  \   return nil\n    }\n    ```\n\n    ## DELETE - Removing Records\n\n    ```go\n\
  \    func deleteUser(db *sql.DB, id int) error {\n        query := `DELETE FROM\
  \ users WHERE id = $1`\n\n        result, err := db.Exec(query, id)\n        if\
  \ err != nil {\n            return err\n        }\n\n        rowsAffected, err :=\
  \ result.RowsAffected()\n        if err != nil {\n            return err\n     \
  \   }\n\n        if rowsAffected == 0 {\n            return fmt.Errorf(\"user not\
  \ found\")\n        }\n\n        return nil\n    }\n    ```\n\n    ## Transactions\n\
  \n    Use transactions for operations that must succeed or fail together:\n\n  \
  \  ```go\n    func transferTask(db *sql.DB, taskID, fromUserID, toUserID int) error\
  \ {\n        // Begin transaction\n        tx, err := db.Begin()\n        if err\
  \ != nil {\n            return err\n        }\n\n        // Defer rollback in case\
  \ of error\n        defer tx.Rollback()\n\n        // Verify task belongs to fromUser\n\
  \        var ownerID int\n        err = tx.QueryRow(\n            \"SELECT user_id\
  \ FROM tasks WHERE id = $1\",\n            taskID,\n        ).Scan(&ownerID)\n\n\
  \        if err != nil {\n            return err\n        }\n\n        if ownerID\
  \ != fromUserID {\n            return fmt.Errorf(\"task does not belong to user\"\
  )\n        }\n\n        // Transfer task\n        _, err = tx.Exec(\n          \
  \  \"UPDATE tasks SET user_id = $1 WHERE id = $2\",\n            toUserID, taskID,\n\
  \        )\n        if err != nil {\n            return err\n        }\n\n     \
  \   // Commit transaction\n        return tx.Commit()\n    }\n    ```\n\n    ##\
  \ Connection Pooling\n\n    The `sql.DB` object is a connection pool, not a single\
  \ connection:\n\n    ```go\n    func initDB(connStr string) (*sql.DB, error) {\n\
  \        db, err := sql.Open(\"postgres\", connStr)\n        if err != nil {\n \
  \           return nil, err\n        }\n\n        // Set connection pool settings\n\
  \        db.SetMaxOpenConns(25)                 // Max open connections\n      \
  \  db.SetMaxIdleConns(5)                  // Max idle connections\n        db.SetConnMaxLifetime(5\
  \ * time.Minute) // Max connection lifetime\n\n        // Test connection\n    \
  \    if err = db.Ping(); err != nil {\n            return nil, err\n        }\n\n\
  \        return db, nil\n    }\n    ```\n\n    ## Integrating with HTTP Handlers\n\
  \n    ```go\n    type Server struct {\n        db *sql.DB\n    }\n\n    func (s\
  \ *Server) createUserHandler(w http.ResponseWriter, r *http.Request) {\n       \
  \ if r.Method != http.MethodPost {\n            http.Error(w, \"Method not allowed\"\
  , http.StatusMethodNotAllowed)\n            return\n        }\n\n        var req\
  \ struct {\n            Name  string `json:\"name\"`\n            Email string `json:\"\
  email\"`\n        }\n\n        if err := json.NewDecoder(r.Body).Decode(&req); err\
  \ != nil {\n            http.Error(w, \"Invalid JSON\", http.StatusBadRequest)\n\
  \            return\n        }\n\n        // Create user in database\n        userID,\
  \ err := createUser(s.db, req.Name, req.Email)\n        if err != nil {\n      \
  \      http.Error(w, \"Failed to create user\", http.StatusInternalServerError)\n\
  \            log.Println(\"Database error:\", err)\n            return\n       \
  \ }\n\n        // Return created user\n        user := User{\n            ID:  \
  \  userID,\n            Name:  req.Name,\n            Email: req.Email,\n      \
  \  }\n\n        w.Header().Set(\"Content-Type\", \"application/json\")\n       \
  \ w.WriteHeader(http.StatusCreated)\n        json.NewEncoder(w).Encode(user)\n \
  \   }\n\n    func main() {\n        db, err := initDB(\"postgres://user:pass@localhost/mydb?sslmode=disable\"\
  )\n        if err != nil {\n            log.Fatal(err)\n        }\n        defer\
  \ db.Close()\n\n        server := &Server{db: db}\n\n        http.HandleFunc(\"\
  /api/users\", server.createUserHandler)\n        http.ListenAndServe(\":8080\",\
  \ nil)\n    }\n    ```\n\n    ## Best Practices\n\n    1. **Always use prepared\
  \ statements** - Prevents SQL injection\n    2. **Use placeholders ($1, $2)** -\
  \ Never concatenate SQL strings\n    3. **Close resources** - `defer rows.Close()`\
  \ and `defer tx.Rollback()`\n    4. **Handle sql.ErrNoRows** - Distinguish \"not\
  \ found\" from errors\n    5. **Use transactions** - For multi-step operations\n\
  \    6. **Configure connection pool** - Set appropriate limits\n    7. **Log database\
  \ errors** - But don't expose them to clients\n    8. **Use context** - For timeouts\
  \ and cancellation"
exercises:
- type: mcq
  slug: database-integration-with-databasesql-mcq
  sequence_order: 1
  question: Why should you use prepared statements with database/sql in Go?
  options:
  - To prevent SQL injection and improve performance through query plan caching
  - To make queries run faster only
  - To automatically create database tables
  - To enable concurrent database access
  correct_answer_index: 0
  explanation: Prepared statements (db.Prepare) prevent SQL injection by separating
    query structure from data, and improve performance by allowing the database to
    cache the query execution plan. They're essential for security when using user
    input in queries.
objectives:
- Understand the fundamental concepts and mechanisms of database integration with
  databasesql
- Apply chemical principles to solve related problems
- Identify key reactions, equations, and chemical behaviors
next_recommended: []
