slug: middleware-and-logging
title: Middleware and Logging
sequence_order: 2
estimated_minutes: 2
difficulty: easy
content_md: "# Middleware and Logging \U0001F680\n\n# Middleware and Logging\n\n \
  \   Middleware is code that runs before or after your handlers, perfect for cross-cutting\
  \ concerns like logging, authentication, and CORS.\n\n    ## What is Middleware?\n\
  \n    Middleware wraps around HTTP handlers to add functionality:\n\n    ```\n \
  \   Request → Middleware 1 → Middleware 2 → Handler → Response\n              (logging)\
  \      (auth)          (business logic)\n    ```\n\n    ## Basic Middleware Pattern\n\
  \n    ```go\n    func loggingMiddleware(next http.HandlerFunc) http.HandlerFunc\
  \ {\n        return func(w http.ResponseWriter, r *http.Request) {\n           \
  \ // Code before handler\n            log.Printf(\"%s %s\", r.Method, r.URL.Path)\n\
  \n            // Call next handler\n            next(w, r)\n\n            // Code\
  \ after handler\n            log.Println(\"Request completed\")\n        }\n   \
  \ }\n\n    // Usage\n    http.HandleFunc(\"/api/users\", loggingMiddleware(usersHandler))\n\
  \    ```\n\n    ## Logging Middleware\n\n    Log every request with timing information:\n\
  \n    ```go\n    func loggingMiddleware(next http.HandlerFunc) http.HandlerFunc\
  \ {\n        return func(w http.ResponseWriter, r *http.Request) {\n           \
  \ start := time.Now()\n\n            // Log request\n            log.Printf(\"Started\
  \ %s %s\", r.Method, r.URL.Path)\n\n            // Call handler\n            next(w,\
  \ r)\n\n            // Log completion with duration\n            duration := time.Since(start)\n\
  \            log.Printf(\"Completed %s %s in %v\", r.Method, r.URL.Path, duration)\n\
  \        }\n    }\n    ```\n\n    ## Response Status Capture\n\n    Capture response\
  \ status codes for logging:\n\n    ```go\n    type responseWriter struct {\n   \
  \     http.ResponseWriter\n        status int\n    }\n\n    func (rw *responseWriter)\
  \ WriteHeader(code int) {\n        rw.status = code\n        rw.ResponseWriter.WriteHeader(code)\n\
  \    }\n\n    func loggingMiddleware(next http.HandlerFunc) http.HandlerFunc {\n\
  \        return func(w http.ResponseWriter, r *http.Request) {\n            start\
  \ := time.Now()\n\n            // Wrap response writer\n            wrapped := &responseWriter{\n\
  \                ResponseWriter: w,\n                status:         http.StatusOK,\
  \ // default\n            }\n\n            next(wrapped, r)\n\n            duration\
  \ := time.Since(start)\n            log.Printf(\"%s %s - %d (%v)\",\n          \
  \      r.Method,\n                r.URL.Path,\n                wrapped.status,\n\
  \                duration,\n            )\n        }\n    }\n    ```\n\n    ## Authentication\
  \ Middleware\n\n    ```go\n    func authMiddleware(next http.HandlerFunc) http.HandlerFunc\
  \ {\n        return func(w http.ResponseWriter, r *http.Request) {\n           \
  \ // Get API key from header\n            apiKey := r.Header.Get(\"X-API-Key\")\n\
  \n            if apiKey == \"\" {\n                http.Error(w, \"Missing API key\"\
  , http.StatusUnauthorized)\n                return\n            }\n\n          \
  \  // Validate API key\n            if !isValidAPIKey(apiKey) {\n              \
  \  http.Error(w, \"Invalid API key\", http.StatusUnauthorized)\n               \
  \ return\n            }\n\n            // Authentication successful, continue\n\
  \            next(w, r)\n        }\n    }\n\n    func isValidAPIKey(key string)\
  \ bool {\n        // In production, check against database\n        validKeys :=\
  \ map[string]bool{\n            \"secret-key-123\": true,\n            \"api-key-456\"\
  :    true,\n        }\n        return validKeys[key]\n    }\n\n    // Usage\n  \
  \  http.HandleFunc(\"/api/protected\",\n        authMiddleware(loggingMiddleware(protectedHandler)))\n\
  \    ```\n\n    ## CORS Middleware\n\n    Enable Cross-Origin Resource Sharing:\n\
  \n    ```go\n    func corsMiddleware(next http.HandlerFunc) http.HandlerFunc {\n\
  \        return func(w http.ResponseWriter, r *http.Request) {\n            // Set\
  \ CORS headers\n            w.Header().Set(\"Access-Control-Allow-Origin\", \"*\"\
  )\n            w.Header().Set(\"Access-Control-Allow-Methods\",\n              \
  \  \"GET, POST, PUT, DELETE, OPTIONS\")\n            w.Header().Set(\"Access-Control-Allow-Headers\"\
  ,\n                \"Content-Type, Authorization\")\n\n            // Handle preflight\
  \ request\n            if r.Method == \"OPTIONS\" {\n                w.WriteHeader(http.StatusOK)\n\
  \                return\n            }\n\n            next(w, r)\n        }\n  \
  \  }\n    ```\n\n    ## Chaining Multiple Middleware\n\n    ```go\n    func chain(handler\
  \ http.HandlerFunc, middlewares ...func(http.HandlerFunc) http.HandlerFunc) http.HandlerFunc\
  \ {\n        for i := len(middlewares) - 1; i >= 0; i-- {\n            handler =\
  \ middlewares[i](handler)\n        }\n        return handler\n    }\n\n    // Usage\n\
  \    http.HandleFunc(\"/api/users\",\n        chain(usersHandler,\n            loggingMiddleware,\n\
  \            authMiddleware,\n            corsMiddleware,\n        ),\n    )\n \
  \   ```\n\n    ## Middleware with http.Handler Interface\n\n    For more flexibility,\
  \ use the http.Handler interface:\n\n    ```go\n    func loggingMiddleware(next\
  \ http.Handler) http.Handler {\n        return http.HandlerFunc(func(w http.ResponseWriter,\
  \ r *http.Request) {\n            start := time.Now()\n            log.Printf(\"\
  %s %s\", r.Method, r.URL.Path)\n\n            next.ServeHTTP(w, r)\n\n         \
  \   log.Printf(\"Completed in %v\", time.Since(start))\n        })\n    }\n\n  \
  \  // Usage with mux\n    mux := http.NewServeMux()\n    mux.HandleFunc(\"/api/users\"\
  , usersHandler)\n\n    // Wrap entire mux with middleware\n    http.ListenAndServe(\"\
  :8080\", loggingMiddleware(mux))\n    ```\n\n    ## Structured Logging\n\n    Use\
  \ structured logging for better log analysis:\n\n    ```go\n    import \"log/slog\"\
  \n\n    func loggingMiddleware(next http.HandlerFunc) http.HandlerFunc {\n     \
  \   return func(w http.ResponseWriter, r *http.Request) {\n            start :=\
  \ time.Now()\n\n            wrapped := &responseWriter{ResponseWriter: w, status:\
  \ 200}\n            next(wrapped, r)\n\n            slog.Info(\"request\",\n   \
  \             \"method\", r.Method,\n                \"path\", r.URL.Path,\n   \
  \             \"status\", wrapped.status,\n                \"duration_ms\", time.Since(start).Milliseconds(),\n\
  \                \"user_agent\", r.UserAgent(),\n            )\n        }\n    }\n\
  \    ```\n\n    ## Recovery Middleware\n\n    Catch panics to prevent server crashes:\n\
  \n    ```go\n    func recoveryMiddleware(next http.HandlerFunc) http.HandlerFunc\
  \ {\n        return func(w http.ResponseWriter, r *http.Request) {\n           \
  \ defer func() {\n                if err := recover(); err != nil {\n          \
  \          log.Printf(\"PANIC: %v\", err)\n\n                    // Return 500 error\n\
  \                    http.Error(w,\n                        \"Internal Server Error\"\
  ,\n                        http.StatusInternalServerError,\n                   \
  \ )\n                }\n            }()\n\n            next(w, r)\n        }\n \
  \   }\n    ```\n\n    ## Complete Server with Middleware\n\n    ```go\n    package\
  \ main\n\n    import (\n        \"log\"\n        \"net/http\"\n        \"time\"\n\
  \    )\n\n    func main() {\n        mux := http.NewServeMux()\n\n        // Register\
  \ handlers with middleware\n        mux.HandleFunc(\"/api/users\",\n           \
  \ chain(usersHandler,\n                recoveryMiddleware,\n                loggingMiddleware,\n\
  \                corsMiddleware,\n            ),\n        )\n\n        mux.HandleFunc(\"\
  /api/protected\",\n            chain(protectedHandler,\n                recoveryMiddleware,\n\
  \                loggingMiddleware,\n                authMiddleware,\n         \
  \   ),\n        )\n\n        log.Println(\"Server starting on :8080...\")\n    \
  \    log.Fatal(http.ListenAndServe(\":8080\", mux))\n    }\n\n    func usersHandler(w\
  \ http.ResponseWriter, r *http.Request) {\n        w.Header().Set(\"Content-Type\"\
  , \"application/json\")\n        w.Write([]byte(`{\"message\": \"Users endpoint\"\
  }`))\n    }\n\n    func protectedHandler(w http.ResponseWriter, r *http.Request)\
  \ {\n        w.Header().Set(\"Content-Type\", \"application/json\")\n        w.Write([]byte(`{\"\
  message\": \"Protected data\"}`))\n    }\n    ```\n\n    ## Best Practices\n\n \
  \   1. **Order matters** - Recovery should be first, logging second\n    2. **Keep\
  \ middleware focused** - Each does one thing well\n    3. **Make middleware reusable**\
  \ - Don't hard-code values\n    4. **Log important events** - Requests, errors,\
  \ slow operations\n    5. **Use structured logging** - Better for analysis and monitoring\n\
  \    6. **Handle panics** - Recovery middleware prevents crashes\n    7. **Document\
  \ middleware chain** - Make it clear what runs when"
exercises:
- type: mcq
  slug: middleware-and-logging-mcq
  sequence_order: 1
  question: What is middleware in the context of HTTP servers?
  options:
  - A function that wraps HTTP handlers to add functionality like logging or authentication
  - A database management tool
  - A frontend framework
  - A type of HTTP response
  correct_answer_index: 0
  explanation: Middleware wraps HTTP handlers to add cross-cutting functionality like
    logging, authentication, or CORS handling. Middleware functions take a handler
    as input and return a new handler, allowing you to chain multiple middleware together.
objectives:
- Understand the fundamental concepts and mechanisms of middleware and logging
- Apply chemical principles to solve related problems
- Identify key reactions, equations, and chemical behaviors
next_recommended: []
