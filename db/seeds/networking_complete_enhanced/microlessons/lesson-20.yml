slug: lesson-20
title: Lesson 20
sequence_order: 20
estimated_minutes: 2
difficulty: easy
content_md: "# Microlesson \U0001F680\n\n# Advanced Functions: Closures, Defer, and\
  \ More\n\n    ### Functions are First-Class Citizens\n\n    In Go, **functions are\
  \ values**. You can:\n    - Assign them to variables\n    - Pass them as arguments\n\
  \    - Return them from other functions\n    - Store them in data structures\n\n\
  \    ### Function Types\n\n    **Functions have types:**\n    ```go\n    // Function\
  \ type: takes two ints, returns int\n    type BinaryOperation func(int, int) int\n\
  \n    func add(a, b int) int {\n        return a + b\n    }\n\n    func multiply(a,\
  \ b int) int {\n        return a * b\n    }\n\n    // Use function type\n    var\
  \ operation BinaryOperation\n    operation = add\n    fmt.Println(operation(5, 3))\
  \  // 8\n\n    operation = multiply\n    fmt.Println(operation(5, 3))  // 15\n \
  \   ```\n\n    ### Anonymous Functions\n\n    **Functions without names:**\n   \
  \ ```go\n    // Assign to variable\n    square := func(x int) int {\n        return\
  \ x * x\n    }\n    fmt.Println(square(5))  // 25\n\n    // Call immediately\n \
  \   result := func(a, b int) int {\n        return a + b\n    }(3, 4)\n    fmt.Println(result)\
  \  // 7\n    ```\n\n    ### Closures: Functions that Capture Variables\n\n    **What\
  \ is a closure?**\n\n    A **closure** is a function that references variables from\
  \ outside its body. The function \"closes over\" these variables, keeping them alive.\n\
  \n    **Basic closure example:**\n    ```go\n    func makeCounter() func() int {\n\
  \        count := 0  // This variable is captured\n\n        return func() int {\n\
  \            count++         // Closure modifies captured variable\n           \
  \ return count\n        }\n    }\n\n    counter := makeCounter()\n    fmt.Println(counter())\
  \  // 1\n    fmt.Println(counter())  // 2\n    fmt.Println(counter())  // 3\n\n\
  \    // Each counter has its own captured variable\n    counter2 := makeCounter()\n\
  \    fmt.Println(counter2())  // 1\n    fmt.Println(counter())   // 4\n    ```\n\
  \n    **How it works:**\n    - `count` is declared in `makeCounter()`\n    - The\
  \ returned function \"closes over\" `count`\n    - Even after `makeCounter()` returns,\
  \ `count` stays alive\n    - Each call to `makeCounter()` creates a new `count`\n\
  \n    ### Practical Closure Examples\n\n    **1. Configuration wrapper:**\n    ```go\n\
  \    func makeGreeter(greeting string) func(string) string {\n        return func(name\
  \ string) string {\n            return greeting + \", \" + name + \"!\"\n      \
  \  }\n    }\n\n    englishGreeter := makeGreeter(\"Hello\")\n    spanishGreeter\
  \ := makeGreeter(\"Hola\")\n\n    fmt.Println(englishGreeter(\"Alice\"))  // \"\
  Hello, Alice!\"\n    fmt.Println(spanishGreeter(\"Bob\"))    // \"Hola, Bob!\"\n\
  \    ```\n\n    **2. Filtering with closures:**\n    ```go\n    func filter(numbers\
  \ []int, predicate func(int) bool) []int {\n        result := []int{}\n        for\
  \ _, num := range numbers {\n            if predicate(num) {\n                result\
  \ = append(result, num)\n            }\n        }\n        return result\n    }\n\
  \n    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\n    // Filter even numbers\n\
  \    evens := filter(numbers, func(n int) bool {\n        return n%2 == 0\n    })\n\
  \    fmt.Println(evens)  // [2, 4, 6, 8, 10]\n\n    // Filter numbers > 5 (closure\
  \ captures threshold)\n    threshold := 5\n    large := filter(numbers, func(n int)\
  \ bool {\n        return n > threshold  // Closes over 'threshold'\n    })\n   \
  \ fmt.Println(large)  // [6, 7, 8, 9, 10]\n    ```\n\n    **3. Memoization (caching):**\n\
  \    ```go\n    func memoize(fn func(int) int) func(int) int {\n        cache :=\
  \ make(map[int]int)\n\n        return func(n int) int {\n            // Check cache\n\
  \            if result, found := cache[n]; found {\n                fmt.Println(\"\
  (from cache)\")\n                return result\n            }\n\n            //\
  \ Compute and cache\n            result := fn(n)\n            cache[n] = result\n\
  \            return result\n        }\n    }\n\n    // Expensive fibonacci calculation\n\
  \    var fibonacci func(int) int\n    fibonacci = func(n int) int {\n        if\
  \ n <= 1 {\n            return n\n        }\n        return fibonacci(n-1) + fibonacci(n-2)\n\
  \    }\n\n    // Wrap with memoization\n    fastFib := memoize(fibonacci)\n\n  \
  \  fmt.Println(fastFib(10))  // Computes\n    fmt.Println(fastFib(10))  // (from\
  \ cache)\n    ```\n\n    ### Variadic Functions\n\n    **Functions that accept variable\
  \ number of arguments:**\n    ```go\n    func sum(numbers ...int) int {\n      \
  \  total := 0\n        for _, num := range numbers {\n            total += num\n\
  \        }\n        return total\n    }\n\n    // Call with any number of arguments\n\
  \    fmt.Println(sum())           // 0\n    fmt.Println(sum(1))          // 1\n\
  \    fmt.Println(sum(1, 2, 3))    // 6\n    fmt.Println(sum(1, 2, 3, 4, 5))  //\
  \ 15\n\n    // Pass slice with ...\n    numbers := []int{10, 20, 30}\n    fmt.Println(sum(numbers...))\
  \  // 60\n    ```\n\n    **Variadic with other parameters:**\n    ```go\n    func\
  \ printf(format string, args ...interface{}) {\n        // format is required, args\
  \ is variadic\n        fmt.Printf(format, args...)\n    }\n\n    printf(\"Hello,\
  \ %s! You are %d years old\\\\n\", \"Alice\", 25)\n    ```\n\n    **Important: Variadic\
  \ parameter must be last:**\n    ```go\n    // ✅ OK\n    func foo(a int, b string,\
  \ rest ...int)\n\n    // ❌ ERROR: variadic must be last\n    func bar(rest ...int,\
  \ a int)\n    ```\n\n    ### Defer: Delaying Execution\n\n    **defer schedules\
  \ a function call to run after the surrounding function returns:**\n\n    **Basic\
  \ defer:**\n    ```go\n    func example() {\n        fmt.Println(\"Start\")\n  \
  \      defer fmt.Println(\"Deferred\")\n        fmt.Println(\"End\")\n    }\n\n\
  \    // Output:\n    // Start\n    // End\n    // Deferred\n    ```\n\n    **Why\
  \ defer is useful:**\n\n    **1. Resource cleanup:**\n    ```go\n    func readFile(path\
  \ string) ([]byte, error) {\n        file, err := os.Open(path)\n        if err\
  \ != nil {\n            return nil, err\n        }\n        defer file.Close() \
  \ // Always closes, even on error!\n\n        return io.ReadAll(file)\n    }\n \
  \   ```\n\n    **2. Unlock mutexes:**\n    ```go\n    var mu sync.Mutex\n\n    func\
  \ criticalSection() {\n        mu.Lock()\n        defer mu.Unlock()  // Guaranteed\
  \ to unlock\n\n        // Complex logic with multiple return paths\n        if condition1\
  \ {\n            return\n        }\n        if condition2 {\n            return\n\
  \        }\n        // mu.Unlock() called automatically\n    }\n    ```\n\n    **3.\
  \ Timing functions:**\n    ```go\n    func measureTime(name string) func() {\n \
  \       start := time.Now()\n        return func() {\n            fmt.Printf(\"\
  %s took %v\\\\n\", name, time.Since(start))\n        }\n    }\n\n    func slowOperation()\
  \ {\n        defer measureTime(\"slowOperation\")()\n\n        // Do work...\n \
  \       time.Sleep(2 * time.Second)\n    }\n\n    // Output: \"slowOperation took\
  \ 2.001s\"\n    ```\n\n    ### Defer: Order of Execution (LIFO)\n\n    **Defers\
  \ run in LIFO order (Last In, First Out):**\n    ```go\n    func example() {\n \
  \       defer fmt.Println(\"First defer\")\n        defer fmt.Println(\"Second defer\"\
  )\n        defer fmt.Println(\"Third defer\")\n        fmt.Println(\"Function body\"\
  )\n    }\n\n    // Output:\n    // Function body\n    // Third defer\n    // Second\
  \ defer\n    // First defer\n    ```\n\n    **Think of it as a stack:**\n    ```\n\
  \    Push: defer A\n    Push: defer B\n    Push: defer C\n    Function returns\n\
  \    Pop: C executes\n    Pop: B executes\n    Pop: A executes\n    ```\n\n    ###\
  \ Defer: Argument Evaluation\n\n    **⚠️ Important: Defer arguments are evaluated\
  \ immediately!**\n    ```go\n    func example() {\n        x := 10\n        defer\
  \ fmt.Println(\"x is\", x)  // x evaluated NOW (10)\n\n        x = 20\n        fmt.Println(\"\
  x changed to\", x)\n    }\n\n    // Output:\n    // x changed to 20\n    // x is\
  \ 10  ← Still 10!\n    ```\n\n    **Use closure to capture latest value:**\n   \
  \ ```go\n    func example() {\n        x := 10\n        defer func() {\n       \
  \     fmt.Println(\"x is\", x)  // Closure captures x\n        }()\n\n        x\
  \ = 20\n        fmt.Println(\"x changed to\", x)\n    }\n\n    // Output:\n    //\
  \ x changed to 20\n    // x is 20  ← Updated value!\n    ```\n\n    ### Panic and\
  \ Recover\n\n    **panic: Stop normal execution**\n\n    **When something goes terribly\
  \ wrong:**\n    ```go\n    func mustConnect(url string) *Connection {\n        conn,\
  \ err := connect(url)\n        if err != nil {\n            panic(\"failed to connect:\
  \ \" + err.Error())\n        }\n        return conn\n    }\n    ```\n\n    **What\
  \ panic does:**\n    1. Stops current function execution\n    2. Runs all deferred\
  \ functions (LIFO order)\n    3. Returns to caller, which also panics\n    4. Continues\
  \ up the call stack\n    5. Program crashes if not recovered\n\n    **recover: Catch\
  \ a panic**\n\n    **Must be called inside a deferred function:**\n    ```go\n \
  \   func safeDivide(a, b int) (result int, err error) {\n        defer func() {\n\
  \            if r := recover(); r != nil {\n                err = fmt.Errorf(\"\
  panic occurred: %v\", r)\n            }\n        }()\n\n        return a / b, nil\
  \  // May panic if b == 0\n    }\n\n    result, err := safeDivide(10, 0)\n    if\
  \ err != nil {\n        fmt.Println(\"Error:\", err)\n        // Error: panic occurred:\
  \ runtime error: integer divide by zero\n    }\n    ```\n\n    **Practical panic/recover\
  \ pattern:**\n    ```go\n    func parseJSON(data []byte) (result map[string]interface{},\
  \ err error) {\n        defer func() {\n            if r := recover(); r != nil\
  \ {\n                err = fmt.Errorf(\"JSON parse panic: %v\", r)\n           \
  \ }\n        }()\n\n        // This might panic on malformed JSON\n        json.Unmarshal(data,\
  \ &result)\n        return result, nil\n    }\n    ```\n\n    ### When to Use Panic\
  \ vs Error\n\n    **Use errors (return error):**\n    - ✅ Expected failures (file\
  \ not found, network timeout)\n    - ✅ Recoverable situations\n    - ✅ Public API\
  \ functions\n    - ✅ Most of the time\n\n    **Use panic:**\n    - ✅ Programming\
  \ errors (nil pointer, index out of bounds)\n    - ✅ Unrecoverable situations (can't\
  \ allocate memory)\n    - ✅ Initialization failures (config must be valid)\n   \
  \ - ✅ Rare edge cases\n\n    **Example:**\n    ```go\n    // ✅ GOOD: Return error\
  \ for expected cases\n    func readFile(path string) ([]byte, error) {\n       \
  \ data, err := os.ReadFile(path)\n        if err != nil {\n            return nil,\
  \ err\n        }\n        return data, nil\n    }\n\n    // ✅ GOOD: Panic for programming\
  \ errors\n    func divide(a, b int) int {\n        if b == 0 {\n            panic(\"\
  divide by zero\")  // This should never happen\n        }\n        return a / b\n\
  \    }\n\n    // ❌ BAD: Don't panic for normal errors\n    func getUser(id int)\
  \ User {\n        user, err := db.Query(id)\n        if err != nil {\n         \
  \   panic(err)  // DON'T DO THIS!\n        }\n        return user\n    }\n    ```\n\
  \n    ### Higher-Order Functions\n\n    **Functions that take or return functions:**\n\
  \    ```go\n    // Function that returns a function\n    func multiplier(factor\
  \ int) func(int) int {\n        return func(x int) int {\n            return x *\
  \ factor\n        }\n    }\n\n    double := multiplier(2)\n    triple := multiplier(3)\n\
  \n    fmt.Println(double(5))  // 10\n    fmt.Println(triple(5))  // 15\n    ```\n\
  \n    **Function that takes a function:**\n    ```go\n    func apply(nums []int,\
  \ fn func(int) int) []int {\n        result := make([]int, len(nums))\n        for\
  \ i, num := range nums {\n            result[i] = fn(num)\n        }\n        return\
  \ result\n    }\n\n    numbers := []int{1, 2, 3, 4, 5}\n\n    // Square all numbers\n\
  \    squared := apply(numbers, func(x int) int {\n        return x * x\n    })\n\
  \    fmt.Println(squared)  // [1, 4, 9, 16, 25]\n    ```\n\n    ### Practical Example:\
  \ Middleware Pattern\n\n    ```go\n    type Handler func(string) string\n\n    //\
  \ Middleware adds logging\n    func withLogging(h Handler) Handler {\n        return\
  \ func(input string) string {\n            fmt.Printf(\"Input: %s\\\\n\", input)\n\
  \            result := h(input)\n            fmt.Printf(\"Output: %s\\\\n\", result)\n\
  \            return result\n        }\n    }\n\n    // Middleware adds timing\n\
  \    func withTiming(h Handler) Handler {\n        return func(input string) string\
  \ {\n            start := time.Now()\n            defer func() {\n             \
  \   fmt.Printf(\"Took: %v\\\\n\", time.Since(start))\n            }()\n        \
  \    return h(input)\n        }\n    }\n\n    // Core handler\n    func uppercase(s\
  \ string) string {\n        return strings.ToUpper(s)\n    }\n\n    // Compose middleware\n\
  \    handler := withLogging(withTiming(uppercase))\n\n    result := handler(\"hello\"\
  )\n    // Output:\n    // Input: hello\n    // Output: HELLO\n    // Took: 123µs\n\
  \    ```\n\n    ### Best Practices\n\n    **1. Use defer for cleanup:**\n    ```go\n\
  \    func process() error {\n        f, err := os.Open(\"file.txt\")\n        if\
  \ err != nil {\n            return err\n        }\n        defer f.Close()  // Always\
  \ cleaned up\n\n        // Work with f...\n        return nil\n    }\n    ```\n\n\
  \    **2. Keep closures simple:**\n    ```go\n    // ✅ GOOD: Clear closure\n   \
  \ func makeAdder(x int) func(int) int {\n        return func(y int) int {\n    \
  \        return x + y\n        }\n    }\n\n    // ❌ BAD: Too complex\n    func makeComplexClosure()\
  \ func() {\n        var a, b, c, d, e int\n        // Closes over many variables\n\
  \        // Complex logic\n    }\n    ```\n\n    **3. Don't defer in loops (usually):**\n\
  \    ```go\n    // ❌ BAD: Defers accumulate\n    for _, file := range files {\n\
  \        f, _ := os.Open(file)\n        defer f.Close()  // Won't run until function\
  \ ends!\n    }\n\n    // ✅ GOOD: Use helper function\n    for _, file := range files\
  \ {\n        processFile(file)\n    }\n\n    func processFile(path string) error\
  \ {\n        f, err := os.Open(path)\n        if err != nil {\n            return\
  \ err\n        }\n        defer f.Close()  // Runs after each file\n        // process\
  \ file...\n        return nil\n    }\n    ```\n\n    **4. Use recover sparingly:**\n\
  \    ```go\n    // ✅ GOOD: Protect from external panics\n    func safeHandler(w\
  \ http.ResponseWriter, r *http.Request) {\n        defer func() {\n            if\
  \ r := recover(); r != nil {\n                log.Printf(\"panic: %v\", r)\n   \
  \             http.Error(w, \"Internal Server Error\", 500)\n            }\n   \
  \     }()\n        handle(w, r)  // Might panic\n    }\n\n    // ❌ BAD: Using panic/recover\
  \ for control flow\n    func find(items []string, target string) string {\n    \
  \    defer func() {\n            recover()  // Catch panic\n        }()\n      \
  \  for _, item := range items {\n            if item == target {\n             \
  \   panic(item)  // DON'T DO THIS!\n            }\n        }\n        return \"\"\
  \n    }\n    ```\n\n    ### Key Takeaways\n\n    1. **Functions are values** - can\
  \ be assigned, passed, returned\n    2. **Closures capture variables** - keep outer\
  \ variables alive\n    3. **Variadic functions** - accept variable arguments with\
  \ `...`\n    4. **defer runs after return** - perfect for cleanup\n    5. **defer\
  \ is LIFO** - last defer runs first\n    6. **defer evaluates args immediately**\
  \ - use closures for late binding\n    7. **panic for unrecoverable errors** - not\
  \ for control flow\n    8. **recover in defer** - catch panics gracefully\n    9.\
  \ **Prefer errors over panic** - panic is exceptional\n    10. **Higher-order functions**\
  \ - powerful composition patterns\n\n    **Congratulations!** You now understand\
  \ Go's powerful function features!"
exercises:
- type: mcq
  slug: lesson-20-mcq
  sequence_order: 1
  question: 'What is a key consideration when working with Advanced Functions: Closures,
    Defer, and More?'
  options:
  - 'Understanding the core principles and best practices of Advanced Functions: Closures,
    Defer, and More'
  - Ignoring documentation
  - Skipping testing
  - Avoiding industry standards
  correct_answer_index: 0
  explanation: 'When working with Advanced Functions: Closures, Defer, and More, it''s
    essential to understand the fundamental principles, follow best practices, and
    stay updated with current standards to ensure effective implementation and maintenance.'
objectives:
- Understand the fundamental concepts and mechanisms of lesson 20
- Apply chemical principles to solve related problems
- Identify key reactions, equations, and chemical behaviors
next_recommended: []
