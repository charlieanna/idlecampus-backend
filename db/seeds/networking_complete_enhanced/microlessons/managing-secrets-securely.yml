slug: managing-secrets-securely
title: Managing Secrets Securely
sequence_order: 6
estimated_minutes: 2
difficulty: easy
content_md: "# Managing Secrets Securely \U0001F680\n\n# Managing Secrets Securely\n\
  \n    Secrets include passwords, API keys, tokens, certificates - anything that\
  \ grants access.\n\n    ## Common Mistakes âŒ\n\n    ### 1. Hardcoding Secrets\n\
  \    ```python\n    # BAD - Never do this!\n    API_KEY = \"sk_live_abc123xyz789\"\
  \n    DATABASE_URL = \"postgres://user:password@host/db\"\n    ```\n\n    ### 2.\
  \ Committing Secrets to Git\n    ```bash\n    # BAD - Secrets in repository\n  \
  \  git add config.json\n    git commit -m \"Add API keys\"  # Now in git history\
  \ forever!\n    ```\n\n    ### 3. Logging Secrets\n    ```bash\n    # BAD - Secrets\
  \ in logs\n    echo \"Connecting with password: $DB_PASSWORD\"\n    ```\n\n    ###\
  \ 4. Sharing Secrets via Email/Chat\n    Insecure channels = compromised secrets.\n\
  \n    ## Environment Variables\n\n    ### Setting Environment Variables\n    ```bash\n\
  \    # Temporary (current session only)\n    export DATABASE_URL=\"postgres://localhost/mydb\"\
  \n    export API_KEY=\"secret_key_here\"\n\n    # In application\n    python app.py\n\
  \    ```\n\n    ### .env Files\n    ```bash\n    # .env file (NEVER commit this!)\n\
  \    DATABASE_URL=postgres://user:pass@localhost/db\n    API_KEY=sk_live_abc123\n\
  \    STRIPE_SECRET=sk_test_xyz789\n    JWT_SECRET=my_super_secret_key\n    ```\n\
  \n    **Always add .env to .gitignore:**\n    ```bash\n    echo \".env\" >> .gitignore\n\
  \    ```\n\n    ### .env.example Template\n    ```bash\n    # .env.example (safe\
  \ to commit)\n    DATABASE_URL=postgres://user:password@localhost/dbname\n    API_KEY=your_api_key_here\n\
  \    STRIPE_SECRET=your_stripe_secret_key\n    JWT_SECRET=generate_a_random_secret\n\
  \    ```\n\n    ## Docker Secrets\n\n    ### Environment Variables in Docker\n \
  \   ```bash\n    # Pass at runtime\n    docker run -e DATABASE_URL=\"postgres://...\"\
  \ myapp\n\n    # From .env file\n    docker run --env-file .env myapp\n    ```\n\
  \n    ### Docker Compose\n    ```yaml\n    version: '3.8'\n    services:\n     \
  \ app:\n        image: myapp\n        environment:\n          - DATABASE_URL=${DATABASE_URL}\n\
  \          - API_KEY=${API_KEY}\n        # Or use env_file\n        env_file:\n\
  \          - .env\n    ```\n\n    ### Docker Swarm Secrets\n    ```bash\n    # Create\
  \ secret\n    echo \"my_secret_password\" | docker secret create db_password -\n\
  \n    # Use in service\n    docker service create \\\\\n      --name myapp \\\\\n\
  \      --secret db_password \\\\\n      myimage\n\n    # Access in container: /run/secrets/db_password\n\
  \    ```\n\n    ## Kubernetes Secrets\n\n    ### Create Secret\n    ```bash\n  \
  \  # From literal\n    kubectl create secret generic db-creds \\\\\n      --from-literal=username=admin\
  \ \\\\\n      --from-literal=password=secret123\n\n    # From file\n    kubectl\
  \ create secret generic api-keys \\\\\n      --from-file=api-key.txt\n\n    # From\
  \ .env file\n    kubectl create secret generic app-secrets --from-env-file=.env\n\
  \    ```\n\n    ### Use Secret in Pod\n    ```yaml\n    apiVersion: v1\n    kind:\
  \ Pod\n    metadata:\n      name: myapp\n    spec:\n      containers:\n      - name:\
  \ app\n        image: myapp:latest\n        env:\n        - name: DB_PASSWORD\n\
  \          valueFrom:\n            secretKeyRef:\n              name: db-creds\n\
  \              key: password\n        volumeMounts:\n        - name: secrets-volume\n\
  \          mountPath: /etc/secrets\n          readOnly: true\n      volumes:\n \
  \     - name: secrets-volume\n        secret:\n          secretName: api-keys\n\
  \    ```\n\n    ## Secrets Management Tools\n\n    ### HashiCorp Vault\n    Industry\
  \ standard for secrets management.\n\n    ```bash\n    # Start Vault dev server\n\
  \    vault server -dev\n\n    # Store secret\n    vault kv put secret/myapp/db password=\"\
  secret123\" username=\"admin\"\n\n    # Read secret\n    vault kv get secret/myapp/db\n\
  \n    # Use in application\n    export VAULT_ADDR='http://127.0.0.1:8200'\n    export\
  \ VAULT_TOKEN='dev-token'\n    vault kv get -field=password secret/myapp/db\n  \
  \  ```\n\n    ### AWS Secrets Manager\n    ```bash\n    # Store secret\n    aws\
  \ secretsmanager create-secret \\\\\n      --name myapp/db \\\\\n      --secret-string\
  \ '{\"username\":\"admin\",\"password\":\"secret\"}'\n\n    # Retrieve secret\n\
  \    aws secretsmanager get-secret-value --secret-id myapp/db\n    ```\n\n    ###\
  \ Azure Key Vault\n    ```bash\n    # Create secret\n    az keyvault secret set\
  \ \\\\\n      --vault-name myvault \\\\\n      --name db-password \\\\\n      --value\
  \ \"secret123\"\n\n    # Get secret\n    az keyvault secret show --vault-name myvault\
  \ --name db-password\n    ```\n\n    ## Best Practices\n\n    ### 1. Never Commit\
  \ Secrets\n    - Use .gitignore for .env files\n    - Scan repos: `git-secrets`,\
  \ `truffleHog`\n    - Use pre-commit hooks\n\n    ### 2. Rotate Secrets Regularly\n\
  \    - API keys: every 90 days\n    - Passwords: every 60-90 days\n    - Certificates:\
  \ before expiry\n\n    ### 3. Principle of Least Privilege\n    - Grant minimum\
  \ permissions needed\n    - Separate dev/staging/prod secrets\n    - Use service\
  \ accounts, not personal credentials\n\n    ### 4. Encrypt at Rest\n    - Database\
  \ encryption\n    - Encrypted filesystems\n    - Secrets encrypted in etcd (Kubernetes)\n\
  \n    ### 5. Audit Access\n    - Log who accessed which secrets\n    - Monitor for\
  \ anomalies\n    - Set up alerts for unauthorized access\n\n    ### 6. Use Secure\
  \ Channels\n    - Share secrets via encrypted tools\n    - Use password managers\
  \ (1Password, LastPass, Bitwarden)\n    - Never email/Slack secrets in plain text\n\
  \n    ## Emergency Response\n\n    ### If Secret is Compromised:\n    1. **Rotate\
  \ immediately** - generate new secret\n    2. **Revoke old secret** - invalidate\
  \ compromised credential\n    3. **Audit access** - check who used the secret\n\
  \    4. **Update all systems** - deploy new secret\n    5. **Investigate** - how\
  \ was it compromised?\n    6. **Document** - post-mortem, lessons learned"
exercises:
- type: mcq
  slug: managing-secrets-securely-mcq
  sequence_order: 1
  question: Why should secrets never be committed to version control?
  options:
  - Git history is permanent and public, exposing credentials even if deleted later
  - It makes the repository too large
  - Version control systems can't handle encrypted data
  - It slows down git operations
  correct_answer_index: 0
  explanation: Once committed, secrets remain in git history forever unless you rewrite
    history (which breaks collaborators' clones). Even if deleted in a new commit,
    they're still accessible in old commits. Public repositories expose these to everyone.
    Use secret management tools instead.
objectives:
- Understand the fundamental concepts and mechanisms of managing secrets securely
- Apply chemical principles to solve related problems
- Identify key reactions, equations, and chemical behaviors
next_recommended: []
