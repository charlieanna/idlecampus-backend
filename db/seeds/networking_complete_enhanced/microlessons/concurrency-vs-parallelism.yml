slug: concurrency-vs-parallelism
title: Concurrency vs Parallelism
sequence_order: 2
estimated_minutes: 2
difficulty: easy
content_md: "# Concurrency vs Parallelism \U0001F680\n\n# Concurrency vs Parallelism\n\
  \n    ## The Difference\n\n    **Concurrency** is about *dealing with* many things\
  \ at once.\n    **Parallelism** is about *doing* many things at once.\n\n    ###\
  \ Concurrency\n    - **Structure**: How you organize your program\n    - **Composition**:\
  \ Breaking down problems into independently executing tasks\n    - **Can run on**:\
  \ Single or multiple cores\n    - **Example**: A juggler juggling multiple balls\
  \ (one person, multiple tasks)\n\n    ### Parallelism\n    - **Execution**: Actually\
  \ running multiple tasks simultaneously\n    - **Performance**: Doing multiple computations\
  \ at the same time\n    - **Requires**: Multiple cores/processors\n    - **Example**:\
  \ Multiple jugglers each juggling their own balls\n\n    ## Why Go Excels at Concurrency\n\
  \n    Go was designed from the ground up with concurrency in mind:\n\n    1. **Goroutines**:\
  \ Lightweight threads managed by Go runtime\n    2. **Channels**: Safe communication\
  \ between goroutines\n    3. **Select Statement**: Multiplexing channel operations\n\
  \    4. **Race Detector**: Built-in tool to find race conditions\n    5. **Sync\
  \ Package**: Primitives for synchronization\n\n    ## Real-World Analogy\n\n   \
  \ Think of a restaurant:\n\n    ### Concurrent (Single Chef, Multiple Orders)\n\
  \    ```\n    Chef starts cooking Order 1 → While waiting for pasta to boil\n  \
  \  → Starts chopping vegetables for Order 2\n    → Pasta done, back to Order 1\n\
  \    → Continues Order 2\n    ```\n    One chef handling multiple orders by switching\
  \ between them.\n\n    ### Parallel (Multiple Chefs, Multiple Orders)\n    ```\n\
  \    Chef 1: Cooking Order 1\n    Chef 2: Cooking Order 2\n    Chef 3: Cooking Order\
  \ 3\n    (All at the same time)\n    ```\n    Multiple chefs working simultaneously.\n\
  \n    ## Go's Concurrency Model: CSP\n\n    Go uses **Communicating Sequential Processes\
  \ (CSP)**:\n\n    > \"Don't communicate by sharing memory; share memory by communicating.\"\
  \n\n    Instead of:\n    ```go\n    // BAD: Sharing memory (requires locks)\n  \
  \  var counter int\n    var mutex sync.Mutex\n\n    mutex.Lock()\n    counter++\n\
  \    mutex.Unlock()\n    ```\n\n    Do this:\n    ```go\n    // GOOD: Communicating\
  \ via channels\n    counterChan := make(chan int)\n\n    go func() {\n        counter\
  \ := 0\n        for {\n            counter++\n            counterChan <- counter\n\
  \        }\n    }()\n\n    value := <-counterChan  // Receive from channel\n   \
  \ ```\n\n    ## When to Use Concurrency\n\n    ✅ **Good Use Cases:**\n    - I/O-bound\
  \ operations (network requests, file operations)\n    - Handling multiple client\
  \ connections\n    - Processing independent tasks\n    - Event-driven systems\n\
  \    - Background workers\n\n    ❌ **Not Ideal For:**\n    - CPU-bound operations\
  \ with shared state\n    - Simple, fast operations (overhead not worth it)\n   \
  \ - Operations that must be strictly sequential\n\n    ## Performance Characteristics\n\
  \n    ### Goroutines vs OS Threads\n\n    | Feature | Goroutines | OS Threads |\n\
  \    |---------|------------|------------|\n    | Memory | 2 KB initial stack |\
  \ 1-2 MB stack |\n    | Creation | Fast (~microseconds) | Slow (~milliseconds) |\n\
  \    | Context Switch | Cheap | Expensive |\n    | Max Number | Millions | Thousands\
  \ |\n    | Managed By | Go runtime | OS kernel |\n\n    ### Example: 1 Million Goroutines\n\
  \n    ```go\n    package main\n\n    import (\n        \"fmt\"\n        \"runtime\"\
  \n        \"time\"\n    )\n\n    func main() {\n        fmt.Printf(\"Starting goroutines:\
  \ %d\\\\n\", runtime.NumGoroutine())\n\n        for i := 0; i < 1000000; i++ {\n\
  \            go func() {\n                time.Sleep(10 * time.Second)\n       \
  \     }()\n        }\n\n        time.Sleep(1 * time.Second)\n        fmt.Printf(\"\
  Active goroutines: %d\\\\n\", runtime.NumGoroutine())\n        // Output: Active\
  \ goroutines: 1000001\n        // Memory used: ~2 GB (very efficient!)\n    }\n\
  \    ```\n\n    Try doing this with OS threads - your system would crash!\n\n  \
  \  ## Key Takeaways\n\n    1. **Concurrency** = Structure (composition of independently\
  \ executing tasks)\n    2. **Parallelism** = Execution (simultaneous execution on\
  \ multiple cores)\n    3. Go makes concurrent programming **simple and safe**\n\
  \    4. Goroutines are **extremely lightweight** compared to threads\n    5. Use\
  \ **channels** to communicate between goroutines\n    6. Go's philosophy: **\"Share\
  \ memory by communicating\"**\n\n    Next, we'll dive deep into goroutines!"
exercises:
- type: mcq
  sequence_order: 1
  question: Concurrency means...
  options:
  - Structuring a program to handle multiple tasks by interleaving progress
  - Running multiple tasks strictly at the same time on multiple CPUs
  - Using threads instead of goroutines
  - Using time.Sleep to coordinate
  correct_answer_index: 0
objectives:
- Understand the fundamental concepts and mechanisms of concurrency vs parallelism
- Apply chemical principles to solve related problems
- Identify key reactions, equations, and chemical behaviors
next_recommended: []
