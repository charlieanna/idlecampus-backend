slug: introduction-to-goroutines
title: Introduction to Goroutines
sequence_order: 3
estimated_minutes: 2
difficulty: easy
content_md: "# Introduction to Goroutines \U0001F680\n\n# Introduction to Goroutines\n\
  \n    A **goroutine** is a lightweight thread of execution managed by the Go runtime.\
  \ They're one of Go's most powerful features!\n\n    ## Creating a Goroutine\n\n\
  \    Simply add `go` before a function call:\n\n    ```go\n    package main\n\n\
  \    import (\n        \"fmt\"\n        \"time\"\n    )\n\n    func sayHello() {\n\
  \        fmt.Println(\"Hello from goroutine!\")\n    }\n\n    func main() {\n  \
  \      go sayHello()  // Launch as goroutine\n\n        time.Sleep(1 * time.Second)\
  \  // Wait for goroutine to finish\n        fmt.Println(\"Main function\")\n   \
  \ }\n    ```\n\n    ## How Goroutines Work\n\n    ### Sequential Execution (Normal)\n\
  \    ```go\n    func main() {\n        task1()  // Wait for task1 to finish\n  \
  \      task2()  // Then do task2\n        task3()  // Then do task3\n    }\n   \
  \ // Timeline: [task1] → [task2] → [task3]\n    ```\n\n    ### Concurrent Execution\
  \ (With Goroutines)\n    ```go\n    func main() {\n        go task1()  // Start\
  \ task1 in background\n        go task2()  // Start task2 in background\n      \
  \  go task3()  // Start task3 in background\n\n        time.Sleep(time.Second) \
  \ // Wait for them to finish\n    }\n    // Timeline: [task1, task2, task3] all\
  \ running concurrently\n    ```\n\n    ## Anonymous Function Goroutines\n\n    You\
  \ can launch goroutines with anonymous functions:\n\n    ```go\n    func main()\
  \ {\n        // Launch inline\n        go func() {\n            fmt.Println(\"Anonymous\
  \ goroutine!\")\n        }()\n\n        // With parameters\n        message := \"\
  Hello\"\n        go func(msg string) {\n            fmt.Println(msg)\n        }(message)\
  \  // Pass by value\n\n        time.Sleep(time.Second)\n    }\n    ```\n\n    ##\
  \ Multiple Goroutines Example\n\n    ```go\n    package main\n\n    import (\n \
  \       \"fmt\"\n        \"time\"\n    )\n\n    func worker(id int) {\n        fmt.Printf(\"\
  Worker %d starting\\\\n\", id)\n        time.Sleep(time.Second)\n        fmt.Printf(\"\
  Worker %d done\\\\n\", id)\n    }\n\n    func main() {\n        // Launch 5 workers\
  \ concurrently\n        for i := 1; i <= 5; i++ {\n            go worker(i)\n  \
  \      }\n\n        // Wait for goroutines to finish\n        time.Sleep(2 * time.Second)\n\
  \        fmt.Println(\"All workers complete\")\n    }\n    ```\n\n    Output (order\
  \ may vary):\n    ```\n    Worker 1 starting\n    Worker 3 starting\n    Worker\
  \ 2 starting\n    Worker 5 starting\n    Worker 4 starting\n    Worker 2 done\n\
  \    Worker 1 done\n    Worker 4 done\n    Worker 3 done\n    Worker 5 done\n  \
  \  All workers complete\n    ```\n\n    ## Common Pitfalls\n\n    ### 1. Main Function\
  \ Exits Too Early\n\n    ❌ **Problem:**\n    ```go\n    func main() {\n        go\
  \ fmt.Println(\"Hello\")\n        // Program exits immediately, goroutine may not\
  \ run!\n    }\n    ```\n\n    ✅ **Solution:** Use synchronization (we'll learn WaitGroups\
  \ next)\n\n    ### 2. Loop Variable Closure\n\n    ❌ **Problem:**\n    ```go\n \
  \   for i := 0; i < 5; i++ {\n        go func() {\n            fmt.Println(i)  //\
  \ All goroutines see i=5!\n        }()\n    }\n    ```\n\n    ✅ **Solution:** Pass\
  \ as parameter\n    ```go\n    for i := 0; i < 5; i++ {\n        go func(num int)\
  \ {\n            fmt.Println(num)  // Each gets its own copy\n        }(i)\n   \
  \ }\n    ```\n\n    ### 3. Shared Memory Without Synchronization\n\n    ❌ **Problem:**\n\
  \    ```go\n    counter := 0\n    for i := 0; i < 1000; i++ {\n        go func()\
  \ {\n            counter++  // RACE CONDITION!\n        }()\n    }\n    ```\n\n\
  \    ✅ **Solution:** Use channels or sync primitives (coming up next)\n\n    ##\
  \ Goroutine Lifecycle\n\n    ```\n    Create → Runnable → Running → Blocked → Runnable\
  \ → ... → Dead\n                ↑                    ↓\n                └────────────────────┘\n\
  \    ```\n\n    **States:**\n    - **Runnable**: Ready to run, waiting for CPU\n\
  \    - **Running**: Currently executing on a CPU\n    - **Blocked**: Waiting for\
  \ I/O, channel, or sleep\n    - **Dead**: Finished execution\n\n    ## The Go Scheduler\n\
  \n    Go uses an **M:N scheduler**:\n    - **M goroutines** run on **N OS threads**\n\
  \    - Go runtime manages the mapping\n    - Scheduler is cooperative (goroutines\
  \ yield at function calls, channel ops, etc.)\n\n    ### GOMAXPROCS\n\n    Controls\
  \ how many OS threads can execute goroutines simultaneously:\n\n    ```go\n    import\
  \ \"runtime\"\n\n    func main() {\n        // Use all CPU cores\n        runtime.GOMAXPROCS(runtime.NumCPU())\n\
  \n        // Or set specific number\n        runtime.GOMAXPROCS(4)\n    }\n    ```\n\
  \n    By default, `GOMAXPROCS = runtime.NumCPU()`\n\n    ## Practical Example: Concurrent\
  \ Web Scraper\n\n    ```go\n    package main\n\n    import (\n        \"fmt\"\n\
  \        \"time\"\n    )\n\n    func fetchURL(url string) {\n        fmt.Printf(\"\
  Fetching %s...\\\\n\", url)\n        time.Sleep(500 * time.Millisecond)  // Simulate\
  \ network delay\n        fmt.Printf(\"Completed %s\\\\n\", url)\n    }\n\n    func\
  \ main() {\n        urls := []string{\n            \"https://golang.org\",\n   \
  \         \"https://github.com\",\n            \"https://stackoverflow.com\",\n\
  \            \"https://reddit.com\",\n        }\n\n        start := time.Now()\n\
  \n        // Sequential (slow)\n        // for _, url := range urls {\n        //\
  \     fetchURL(url)\n        // }\n        // Time: ~2 seconds (4 × 0.5s)\n\n  \
  \      // Concurrent (fast!)\n        for _, url := range urls {\n            go\
  \ fetchURL(url)\n        }\n\n        time.Sleep(1 * time.Second)\n        elapsed\
  \ := time.Since(start)\n        fmt.Printf(\"\\\\nTotal time: %s\\\\n\", elapsed)\n\
  \        // Time: ~1 second (all run concurrently)\n    }\n    ```\n\n    ## When\
  \ to Use Goroutines\n\n    ✅ **Great for:**\n    - I/O operations (network, disk,\
  \ database)\n    - Independent tasks that can run concurrently\n    - Event handling\
  \ and message processing\n    - Background workers\n    - Fan-out/fan-in patterns\n\
  \n    ❌ **Avoid for:**\n    - CPU-intensive tasks with dependencies\n    - Operations\
  \ requiring strict ordering\n    - Very short-lived tasks (overhead not worth it)\n\
  \n    ## Best Practices\n\n    1. **Always synchronize**: Never let goroutines outlive\
  \ main without coordination\n    2. **Pass data by value**: Avoid sharing pointers\
  \ between goroutines\n    3. **Know when goroutines end**: Use WaitGroups or channels\
  \ to track completion\n    4. **Limit goroutine count**: Don't create millions unnecessarily\n\
  \    5. **Use contexts**: For cancellation and timeouts\n\n    ## Next Steps\n\n\
  \    Now that you understand goroutines, let's learn how they communicate using\
  \ **channels**!\n\n    Practice what you've learned in the \"Go Concurrency Basics\"\
  \ lab!"
exercises:
- type: mcq
  slug: introduction-to-goroutines-mcq
  sequence_order: 1
  question: How do you start a goroutine in Go?
  options:
  - Use the 'go' keyword before a function call
  - Call the .start() method on a function
  - Use the 'async' keyword
  - Import the goroutine package
  correct_answer_index: 0
  explanation: Goroutines are started simply by prefixing a function call with the
    'go' keyword, e.g., 'go myFunction()'. This creates a lightweight thread managed
    by the Go runtime. Goroutines are much more lightweight than OS threads.
objectives:
- Understand the fundamental concepts and mechanisms of introduction to goroutines
- Apply chemical principles to solve related problems
- Identify key reactions, equations, and chemical behaviors
next_recommended: []
