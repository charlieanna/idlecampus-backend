slug: git-github-workflows
title: GitHub and GitLab Workflows - Pull Requests
difficulty: easy
sequence_order: 5
estimated_minutes: 25
key_concepts:
  - Pull requests
  - Code review
  - Fork workflows
  - GitHub Actions
  - Collaboration
  - Branch protection
prerequisites:
  - lesson-1
  - git-branching-strategies
  - git-merging-conflict-resolution
  - git-remote-collaboration
content_md: |
  # GitHub and GitLab Workflows - Pull Requests

  Pull Requests (GitHub) / Merge Requests (GitLab) are the heart of modern code collaboration. Master them for professional development.

  ## What is a Pull Request?

  **Pull Request (PR)**: Proposal to merge changes from one branch into another, with code review

  **Purpose:**
  - Code review before merging
  - Discussion and feedback
  - Automated testing (CI/CD)
  - Quality control gate
  - Knowledge sharing across team

  **GitLab equivalent**: Merge Request (MR) - same concept, different name

  ## Creating a Pull Request

  ### Standard Workflow

  ```bash
  # 1. Create feature branch
  git checkout main
  git pull origin main
  git checkout -b feature/user-profile

  # 2. Make changes and commit
  git add src/profile.js
  git commit -m "Add user profile page"

  git add tests/profile.test.js
  git commit -m "Add tests for user profile"

  # 3. Push branch to remote
  git push -u origin feature/user-profile

  # 4. Create Pull Request on GitHub
  # Go to: https://github.com/user/repo
  # Click "Compare & pull request" button
  # Or: gh pr create (using GitHub CLI)
  ```

  ### On GitHub Web Interface

  **Creating PR:**
  1. Navigate to repository
  2. Click "Pull requests" tab
  3. Click "New pull request"
  4. Select base branch (e.g., `main`) and compare branch (e.g., `feature/user-profile`)
  5. Review changes
  6. Click "Create pull request"
  7. Fill in details (see below)
  8. Click "Create pull request"

  ## Writing Great Pull Request Descriptions

  ### PR Title

  **Good titles:**
  - "Add user profile page with avatar upload"
  - "Fix authentication bug in login flow"
  - "Refactor database queries for performance"

  **Bad titles:**
  - "Update code"
  - "Fix bug"
  - "PR for review"

  ### PR Description Template

  ```markdown
  ## Summary
  Brief description of what this PR does (1-2 sentences)

  ## Changes
  - Added user profile page component
  - Implemented avatar upload functionality
  - Added validation for profile fields
  - Updated routing to include /profile

  ## Type of Change
  - [ ] Bug fix (non-breaking change fixing an issue)
  - [x] New feature (non-breaking change adding functionality)
  - [ ] Breaking change (fix or feature causing existing functionality to break)
  - [ ] Documentation update

  ## Testing
  - [x] Unit tests pass locally
  - [x] Integration tests pass locally
  - [x] Tested manually in browser
  - [ ] Added new tests for this feature

  ## Screenshots (if applicable)
  ![Profile Page](https://example.com/screenshot.png)

  ## Related Issues
  Closes #123
  Related to #456

  ## Checklist
  - [x] Code follows project style guidelines
  - [x] Self-reviewed my own code
  - [x] Commented complex code sections
  - [x] Updated documentation
  - [x] No new warnings generated
  - [x] Added tests covering changes
  - [x] All tests passing
  ```

  ## Code Review Process

  ### Requesting Review

  ```bash
  # After pushing branch
  gh pr create --title "Add user profile" \
               --body "Implements user profile page" \
               --reviewer @teammate1,@teammate2 \
               --label enhancement
  ```

  **On GitHub:**
  - Assign reviewers (teammates who will review)
  - Add labels (bug, enhancement, documentation)
  - Link issues (Closes #123)
  - Set milestone (v2.0 release)

  ### As a Reviewer

  **Review checklist:**

  1. **Understand the change**
     - Read PR description
     - Check linked issues
     - Understand the problem being solved

  2. **Review code quality**
     - Is code readable and maintainable?
     - Are there any obvious bugs?
     - Does it follow project conventions?
     - Is it properly tested?

  3. **Check functionality**
     - Pull branch locally and test
     - Verify it works as described
     - Check edge cases

  4. **Provide feedback**
     - Comment on specific lines
     - Ask questions for clarity
     - Suggest improvements
     - Praise good code!

  ### Review Comments

  **Good review comments:**

  ‚úÖ "Great abstraction! Consider adding a docstring explaining the algorithm."

  ‚úÖ "This could fail if `user` is null. Should we add validation?"

  ‚úÖ "Minor: could we rename `getData()` to `fetchUserData()` for clarity?"

  ‚úÖ "Love the test coverage here! üéâ"

  **Bad review comments:**

  ‚ùå "This is wrong" (no explanation)

  ‚ùå "Rewrite this" (not constructive)

  ‚ùå "I wouldn't do it this way" (no specific reason)

  ### Review Actions

  ```markdown
  **Approve**: Code looks good, ready to merge
  ‚úÖ "LGTM! (Looks Good To Me) Nice work on the validation logic."

  **Request Changes**: Issues that must be fixed before merging
  üîÑ "Please address the null pointer issue in line 45 before merging."

  **Comment**: Feedback without blocking merge
  üí¨ "FYI, we have a utility function for this in utils/string.js"
  ```

  ## Addressing Review Feedback

  ```bash
  # Reviewer left comments
  # Make requested changes locally
  git add src/profile.js
  git commit -m "Address review feedback: add null check"

  # Push changes
  git push origin feature/user-profile

  # Changes automatically appear in PR

  # Respond to comments
  # On GitHub: Reply to each comment explaining changes
  ```

  **Responding to comments:**
  - ‚úÖ "Fixed in latest commit (abc123)"
  - ‚úÖ "Good catch! Updated to use `fetchUserData()`"
  - ‚úÖ "I considered that, but chose this approach because..."
  - ‚úÖ "Filed issue #789 to address this in separate PR"

  ## Merging Pull Requests

  ### Merge Strategies

  GitHub offers three merge methods:

  #### 1. Merge Commit (Default)

  ```
  main:    A---B---E---F---M
                \         /
  feature:      C---D
  ```

  - Creates merge commit M
  - Preserves complete history
  - Shows when feature was integrated

  **Use when:** You want full history of feature branch

  #### 2. Squash and Merge

  ```
  main:    A---B---E---F---S

  (C and D are squashed into single commit S)
  ```

  - Combines all feature commits into one
  - Cleaner main branch history
  - Loses individual commit history

  **Use when:** Feature has many small "work in progress" commits

  #### 3. Rebase and Merge

  ```
  main:    A---B---E---F---C'---D'

  (C and D replayed on top of F)
  ```

  - Replays feature commits on main
  - Linear history (no merge commits)
  - Looks like you developed on latest main

  **Use when:** You want clean linear history

  ### Merging via CLI

  ```bash
  # Using GitHub CLI
  gh pr merge 123 --merge        # Merge commit
  gh pr merge 123 --squash       # Squash and merge
  gh pr merge 123 --rebase       # Rebase and merge

  # Using git (traditional)
  git checkout main
  git merge feature/user-profile
  git push origin main
  ```

  ### Post-Merge Cleanup

  ```bash
  # Delete remote branch (usually done automatically by GitHub)
  git push origin --delete feature/user-profile

  # Delete local branch
  git checkout main
  git pull origin main
  git branch -d feature/user-profile

  # Prune deleted remote branches
  git fetch --prune
  ```

  ## Draft Pull Requests

  **Draft PR**: PR that's not ready for review yet

  **Use cases:**
  - Show work in progress to team
  - Run CI tests early
  - Get early architectural feedback

  ```bash
  # Create draft PR
  gh pr create --draft --title "WIP: User profile"

  # Mark as ready for review later
  gh pr ready 123
  ```

  **On GitHub:** Create PR ‚Üí "Create draft pull request" dropdown

  ## Pull Request Best Practices

  ### Size and Scope

  ‚úÖ **Keep PRs small**: 200-400 lines of code ideal
  - Easier to review
  - Faster to merge
  - Less chance of conflicts

  ‚ùå **Avoid large PRs**: 1000+ lines
  - Hard to review thoroughly
  - Takes days to review
  - High conflict risk

  **Solution for large changes:** Break into multiple PRs
  ```
  PR #1: Refactor existing code (200 lines)
  PR #2: Add new models (150 lines)
  PR #3: Implement UI (300 lines)
  PR #4: Add tests (250 lines)
  ```

  ### Commit Quality

  ‚úÖ **Good commit history:**
  ```
  feat: Add user profile component
  test: Add tests for user profile
  docs: Update README with profile feature
  ```

  ‚ùå **Bad commit history:**
  ```
  wip
  fix
  more changes
  asdf
  final final version
  ```

  **Solution:** Squash messy commits before PR
  ```bash
  git rebase -i HEAD~5  # Interactive rebase last 5 commits
  # Squash "wip" commits into meaningful commits
  ```

  ### Testing

  ‚úÖ **Always include in PR:**
  - Tests for new functionality
  - Tests pass locally
  - CI tests pass

  ‚ùå **Never:**
  - Merge failing tests
  - Skip tests "I'll add them later"
  - Ignore CI failures

  ## Fork Workflow (Open Source)

  ### Forking a Repository

  ```bash
  # 1. Fork on GitHub
  # Click "Fork" button on repository page

  # 2. Clone your fork
  git clone https://github.com/yourname/repo.git
  cd repo

  # 3. Add upstream remote
  git remote add upstream https://github.com/original/repo.git

  # 4. Verify remotes
  git remote -v
  # origin    https://github.com/yourname/repo.git
  # upstream  https://github.com/original/repo.git
  ```

  ### Contributing to Upstream

  ```bash
  # 1. Sync fork with upstream
  git fetch upstream
  git checkout main
  git merge upstream/main
  git push origin main

  # 2. Create feature branch
  git checkout -b fix/typo-in-docs

  # 3. Make changes and commit
  git add README.md
  git commit -m "Fix typo in installation instructions"

  # 4. Push to your fork
  git push origin fix/typo-in-docs

  # 5. Create PR on GitHub
  # Go to original repo
  # Click "Compare & pull request"
  # Base: original/main ‚Üê Head: yourfork/fix/typo-in-docs
  ```

  ### Keeping Fork Synced

  ```bash
  # Regular sync (weekly or before starting new work)
  git fetch upstream
  git checkout main
  git merge upstream/main
  git push origin main

  # Update feature branch with upstream changes
  git checkout fix/my-feature
  git merge upstream/main
  # Or: git rebase upstream/main
  ```

  ## Branch Protection Rules

  **Branch protection**: Enforce rules before merging to main

  **Common protections:**

  1. **Require pull request reviews**: At least 1-2 approvals before merge

  2. **Require status checks**: CI tests must pass

  3. **Require branches to be up to date**: Must merge latest main before merging PR

  4. **Require signed commits**: Cryptographic signature verification

  5. **Restrict who can push**: Only maintainers can push directly

  6. **Require linear history**: No merge commits (rebase or squash only)

  **Setting up on GitHub:**
  - Settings ‚Üí Branches ‚Üí Add rule
  - Branch name pattern: `main`
  - Enable desired protections
  - Save changes

  ## GitHub Actions and CI/CD

  ### Automatic Testing

  `.github/workflows/test.yml`:
  ```yaml
  name: Run Tests
  on:
    pull_request:
      branches: [main]

  jobs:
    test:
      runs-on: ubuntu-latest
      steps:
        - uses: actions/checkout@v3
        - name: Install dependencies
          run: npm install
        - name: Run tests
          run: npm test
        - name: Run linter
          run: npm run lint
  ```

  **Result:** Every PR automatically runs tests and linting

  ### Status Checks

  PR shows status checks:
  - ‚úÖ Tests passed (20/20)
  - ‚úÖ Lint passed
  - ‚úÖ Build successful
  - ‚ùå Coverage decreased

  **Merge blocked if any check fails** (when branch protection enabled)

  ## Common PR Workflows

  ### Workflow 1: Simple Feature

  ```bash
  Day 1:
  - Create branch: git checkout -b feature/add-search
  - Code and commit
  - Push: git push -u origin feature/add-search
  - Create PR

  Day 2:
  - Address review feedback
  - Push changes
  - Reviewer approves
  - Merge PR
  - Delete branch
  ```

  ### Workflow 2: Complex Feature (Multiple PRs)

  ```bash
  PR #1 (Backend):
  - Add API endpoints
  - Merge to main

  PR #2 (Frontend):
  - Add UI components
  - Merge to main

  PR #3 (Integration):
  - Connect UI to API
  - Merge to main
  ```

  ### Workflow 3: Urgent Hotfix

  ```bash
  - Create hotfix branch: git checkout -b hotfix/security-patch main
  - Fix and test thoroughly
  - Push: git push -u origin hotfix/security-patch
  - Create PR with "URGENT" label
  - Request immediate review
  - Fast-track merge (still require 1 approval)
  - Deploy immediately
  ```

  ## GitLab Merge Requests

  **Same concept as GitHub PR, slightly different interface:**

  ### Creating MR on GitLab

  ```bash
  # Push branch
  git push -u origin feature/new-feature

  # GitLab shows message with MR link
  # Or use GitLab CLI:
  glab mr create --title "Add feature" --description "Description"
  ```

  ### GitLab-Specific Features

  - **Approvals**: Set required approver count
  - **Merge trains**: Queue MRs to prevent conflicts
  - **Squash commits**: Option during merge
  - **Remove source branch**: Automatic cleanup
  - **Pipelines**: CI/CD visualization

  ## Real-World Scenarios

  ### Scenario 1: PR with Conflicts

  ```bash
  # PR shows conflicts with main
  # GitHub: "This branch has conflicts that must be resolved"

  # Solution:
  git checkout feature/my-feature
  git fetch origin
  git merge origin/main
  # Resolve conflicts
  git add .
  git commit -m "Resolve conflicts with main"
  git push origin feature/my-feature

  # PR now mergeable
  ```

  ### Scenario 2: CI Failing

  ```bash
  # PR shows: ‚ùå Tests failed

  # Pull PR locally
  git fetch origin pull/123/head:pr-123
  git checkout pr-123

  # Run tests locally
  npm test

  # Fix issues
  # ... make changes ...

  # If it's your PR: commit and push
  # If reviewing: suggest changes in comment
  ```

  ### Scenario 3: Stale PR

  ```bash
  # PR is 2 weeks old, main has moved ahead

  # Update PR with latest main
  git checkout feature/old-branch
  git fetch origin
  git merge origin/main
  # Or: git rebase origin/main
  git push origin feature/old-branch

  # Re-request review if needed
  ```

  ## Tips for Effective PRs

  ### As PR Author

  1. **Self-review first**: Review your own PR before requesting review
  2. **Write tests**: Include tests for new code
  3. **Update docs**: Keep documentation current
  4. **Small PRs**: Easier to review, faster to merge
  5. **Clear description**: Explain what, why, and how
  6. **Link issues**: Connect to related issues
  7. **Be responsive**: Address feedback promptly

  ### As Reviewer

  1. **Review promptly**: Don't block teammates
  2. **Be kind**: Constructive, helpful feedback
  3. **Ask questions**: "Why..." instead of "This is wrong"
  4. **Praise good code**: Positive reinforcement
  5. **Test locally**: For complex changes
  6. **Focus on important issues**: Not nitpicking syntax
  7. **Explain suggestions**: Why, not just what

  ### For Team Leads

  1. **Set PR standards**: Size, testing, documentation
  2. **Enable branch protection**: Prevent direct pushes to main
  3. **Require reviews**: At least 1-2 approvals
  4. **Configure CI/CD**: Automated testing
  5. **Review regularly**: Don't leave PRs hanging
  6. **Celebrate good PRs**: Recognize quality work

  **Next**: Learn advanced Git techniques like rebase, cherry-pick, and stash!

exercises:
  - type: mcq
    sequence_order: 1
    question: "What is the primary purpose of a Pull Request (PR) in modern development workflows?"
    options:
      - "To automatically merge code without review"
      - "To propose changes for code review, discussion, and automated testing before merging"
      - "To download code from the remote repository"
      - "To create a new branch"
    correct_answer: "To propose changes for code review, discussion, and automated testing before merging"
    explanation: "Pull Requests are fundamental to modern collaborative development, serving multiple critical purposes. Primary Purposes: (1) Code Review: Team members review proposed changes. Catch bugs before they reach production. Ensure code quality and standards. Share knowledge across team. Multiple reviewers can provide feedback. (2) Discussion and Collaboration: Comment on specific lines of code. Ask questions for clarification. Suggest improvements. Discuss implementation approaches. Knowledge sharing among team. (3) Automated Testing (CI/CD): Run tests automatically on proposed changes. Check code coverage. Run linters and formatters. Build verification. Security scans. Merge only if all checks pass. (4) Quality Control Gate: Prevents untested code from reaching main. Requires approval(s) before merge. Ensures documentation is updated. Validates tests are included. Enforces team standards. (5) Audit Trail: Documents what changed, when, and why. Links to issues and discussions. Shows who approved changes. Traceable history of decisions. PR Workflow Example: Developer creates feature branch: git checkout -b feature/user-auth. Makes changes and commits: git commit -m 'Add authentication'. Pushes to remote: git push -u origin feature/user-auth. Creates Pull Request on GitHub/GitLab. Team reviews: Reviewers examine code. Leave comments and suggestions. Request changes if needed. Automated tests run: CI pipeline executes. Tests must pass. Code coverage checked. Approval and Merge: Reviewer approves: 'LGTM!' PR merged to main. Feature branch deleted. Code deployed to production. Benefits Over Direct Commits: Without PR (direct to main): No review (bugs slip through). No discussion (missed better approaches). No automated testing before merge. Hard to track what changed and why. With PR: Multiple eyes on code (catch issues early). Discussion platform (better solutions emerge). Automated quality checks. Clear history and reasoning. What PR is NOT: Not for downloading code (that's git pull or git clone). Not for creating branches (that's git checkout -b). Not automatic merging (requires review and approval). Not just for large teams (valuable even for solo projects). Real-World Example: Company Policy: All changes to main must go through PR. Require 2 approvals from senior developers. All tests must pass (enforced by branch protection). PR description must link to Jira ticket. Developer submits PR for payment feature: Code review catches potential security issue. Tests reveal edge case bug. Senior dev suggests better architecture. After fixes and re-review: PR approved and merged. Modern Platforms: GitHub: Pull Requests. GitLab: Merge Requests (same concept). Bitbucket: Pull Requests. All support: Line-by-line comments, approvals, CI/CD integration, merge strategies."
    require_pass: true

  - type: mcq
    sequence_order: 2
    question: "What are the three merge strategies available on GitHub when merging a Pull Request?"
    options:
      - "Fast-forward, Slow-merge, and Manual"
      - "Merge commit (preserves history), Squash and merge (combines commits), Rebase and merge (linear history)"
      - "Auto-merge, Semi-merge, and No-merge"
      - "Local merge, Remote merge, and Cloud merge"
    correct_answer: "Merge commit (preserves history), Squash and merge (combines commits), Rebase and merge (linear history)"
    explanation: "GitHub offers three merge strategies, each with different effects on repository history. Understanding when to use each is important for maintaining clean, readable Git history. 1. Merge Commit (Default - Preserves Full History): What happens: Creates new merge commit combining both branches. Both branch histories preserved. Shows when feature was integrated. Visual: main: A---B---E---F---M, feature: C---D (M has two parents). Command equivalent: git merge --no-ff feature. When to use: Feature branches with meaningful commit history. Want to preserve who worked on what and when. Need to track feature integration points. Team wants full audit trail. Pros: Complete history preserved. Easy to revert entire feature (revert M). Shows parallel development clearly. Cons: History can become complex with many merges. Many merge commits can clutter history. 2. Squash and Merge (Combines All Commits): What happens: All feature branch commits combined into single commit. Commit message from PR title/description. Feature branch history discarded. Visual: main: A---B---E---F---S (C and D squashed into S). Command equivalent: git merge --squash feature && git commit. When to use: Feature has many 'work in progress' commits. Commits like 'fix typo', 'debugging', 'wip' that aren't valuable in history. Want clean main branch history. Each PR = one commit on main. Pros: Very clean main branch history. Easy to understand what each commit does. Simple to revert (one commit to revert). Good for semantic versioning (each commit = potential release). Cons: Loses detailed feature development history. Can't see individual changes during feature development. Harder to debug 'when did this specific change happen'. Example: Feature branch commits: 'Add login UI', 'fix button color', 'add validation', 'fix typo', 'final touches'. Squashed: 'Add login feature with validation (#123)'. 3. Rebase and Merge (Linear History): What happens: Feature commits replayed on top of main. No merge commit created. Looks like feature was developed on latest main. Linear history (straight line, no branching). Visual: main: A---B---E---F---C'---D' (C and D replayed as C' and D'). Command equivalent: git rebase main && git merge --ff-only. When to use: Want completely linear history. Team prefers 'looks like serial development'. Meaningful commit messages on feature branch. Want to avoid merge commits entirely. Pros: Cleanest, most linear history. Easier to bisect (git bisect). Simple git log visualization. Each commit builds on previous (no parallel branches). Cons: Rewrites commit history (changes SHAs). Can be confusing for less experienced developers. Lost information about when feature was actually developed. Comparison Table: Merge Commit: History: Full branching, Commits: All preserved, Revert: Easy (revert merge), Use case: Standard workflow. Squash: History: Linear, Commits: Combined into 1, Revert: Easy (one commit), Use case: Messy feature commits. Rebase: History: Linear, Commits: All preserved, Revert: Moderate (multiple), Use case: Clean commit history. Team Policies: Startups: Often squash and merge for simplicity. Enterprise: Often merge commit for auditability. Open source: Varies by project (check CONTRIBUTING.md). Configuring on GitHub: Repository Settings ‚Üí Pull Requests. Allow merge commits. Allow squash merging. Allow rebase merging. Can disable options to enforce team policy. Best Practice: Discuss and agree on team strategy. Document in CONTRIBUTING.md. Configure GitHub to allow only chosen strategy. Use consistently across all PRs."
    require_pass: true

  - type: mcq
    sequence_order: 3
    question: "In a fork workflow for open-source contributions, what is the correct process to keep your fork synced with the original repository?"
    options:
      - "Delete your fork and re-fork the repository"
      - "Add original repository as 'upstream' remote, then git fetch upstream && git merge upstream/main into your main branch"
      - "Clone the original repository again"
      - "Create a pull request from the original repository to your fork"
    correct_answer: "Add original repository as 'upstream' remote, then git fetch upstream && git merge upstream/main into your main branch"
    explanation: "Keeping your fork synced with the original (upstream) repository is essential for open-source contributions. Understanding the fork workflow prevents merge conflicts and ensures you're working with the latest code. Fork Workflow Explained: Fork on GitHub: Click 'Fork' button on original repository. Creates copy under your account: original/repo ‚Üí yourname/repo. Clone YOUR fork: git clone https://github.com/yourname/repo.git. Now you have local copy of YOUR fork. Add upstream remote: git remote add upstream https://github.com/original/repo.git. 'upstream' = original repository you forked from. Verify remotes: git remote -v shows origin (your fork), upstream (original repo). Keeping Fork Synced: Why sync: Original repo receives new commits from other contributors. Your fork becomes outdated. Before creating PR, you need latest upstream changes. Prevents merge conflicts. How to sync (CORRECT METHOD): Fetch upstream changes: git fetch upstream (downloads commits from original repo). Checkout your main branch: git checkout main. Merge upstream into your main: git merge upstream/main (integrates upstream changes). Push to your fork: git push origin main (updates your fork on GitHub). Now your fork's main = original repo's main. Detailed Workflow: # Start contribution: git fetch upstream, git checkout main, git merge upstream/main, git push origin main (sync first). # Create feature branch from synced main: git checkout -b fix/typo-in-docs. # Make changes: edit README.md, git commit -m 'Fix installation typo'. # Push to YOUR fork: git push origin fix/typo-in-docs. # Create PR on GitHub: Base: original/main, Head: yourfork/fix/typo-in-docs. If upstream changes while you work: git fetch upstream, git checkout fix/typo-in-docs, git merge upstream/main (update feature branch), resolve conflicts if any, git push origin fix/typo-in-docs. Why Other Options Are Wrong: ‚ùå Delete and re-fork: Loses all your branches and work. Extremely inefficient. Doesn't teach proper Git workflow. Never necessary. ‚ùå Clone original again: Creates separate repository. Doesn't update your existing fork. Wastes disk space. Doesn't solve the problem. ‚ùå PR from original to your fork: Not possible (you can't create PR targeting your fork from upstream). Pull requests go other direction (your fork ‚Üí original). Misunderstands PR direction. Complete Fork Workflow Example: Day 1 - Fork and setup: Fork kubernetes/kubernetes on GitHub. git clone https://github.com/yourname/kubernetes.git. git remote add upstream https://github.com/kubernetes/kubernetes.git. Day 2 - Start contribution: git fetch upstream (get latest). git checkout main. git merge upstream/main (sync main). git checkout -b fix/doc-typo. fix typo in docs/README.md. git commit -m 'Fix typo in quickstart guide'. git push origin fix/doc-typo. Day 3 - Create PR: Go to kubernetes/kubernetes on GitHub. Click 'Compare & pull request'. Fill in PR description. Submit PR. Week later - Sync again: git fetch upstream (upstream has 50 new commits). git checkout main. git merge upstream/main. git push origin main. Automated Sync: GitHub now offers 'Sync fork' button. Click button on your fork's page. Equivalent to: git fetch upstream && git merge upstream/main. Manual sync still better for learning and control. Best Practices: Sync before starting new work. Sync weekly (or daily for active projects). Never commit directly to main on your fork (keep it clean for syncing). Always create feature branches. Sync feature branches if they're long-running. Alternative - Rebase: Instead of merge: git fetch upstream, git rebase upstream/main (replay your commits on top). Cleaner linear history. More advanced technique. Common Mistakes: ‚ùå Forgetting to add upstream remote: Can't fetch from what you haven't added. ‚ùå Committing to main on fork: Makes syncing complicated. ‚ùå Never syncing: Your PR will have conflicts with upstream. ‚ùå Syncing into feature branch directly: Sync main first, then merge main into feature."
    require_pass: true
