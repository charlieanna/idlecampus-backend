slug: git-best-practices
title: Git Best Practices and Troubleshooting
difficulty: easy
sequence_order: 7
estimated_minutes: 20
key_concepts:
  - Git best practices
  - Commit messages
  - Git workflows
  - Troubleshooting
  - Common mistakes
  - Git configuration
prerequisites:
  - lesson-1
  - git-branching-strategies
  - git-merging-conflict-resolution
  - git-remote-collaboration
content_md: |
  # Git Best Practices and Troubleshooting

  Learn industry standards and solve common Git problems. These practices make you a professional Git user.

  ## Commit Best Practices

  ### Write Good Commit Messages

  **Anatomy of a great commit message:**

  ```
  Short summary (50 chars or less)

  More detailed explanation after blank line (wrap at 72 chars).
  Explain what and why, not how.

  - Bullet points okay
  - Use imperative mood: "Add feature" not "Added feature"
  - Reference issues: Fixes #123

  Breaking change: Describe breaking changes if any
  ```

  **Examples:**

  ✅ **Good commit messages:**
  ```
  Add user authentication with JWT

  Implement JWT-based authentication for API endpoints.
  - Add login and signup endpoints
  - Create JWT middleware for protected routes
  - Store tokens securely in httpOnly cookies

  Fixes #456
  ```

  ```
  Fix memory leak in WebSocket connection

  WebSocket connections weren't being properly closed
  on component unmount, causing memory accumulation.
  Added cleanup in useEffect return function.

  Closes #789
  ```

  ```
  Refactor database queries for performance

  Optimize user lookup queries by:
  - Adding index on email column
  - Using select statements instead of full table scans
  - Implementing query result caching

  Performance improvement: 250ms → 15ms per query
  ```

  ❌ **Bad commit messages:**
  ```
  fix bug
  update code
  changes
  asdf
  final version 2
  ```

  ### Conventional Commits

  **Format:** `<type>(<scope>): <description>`

  **Types:**
  - `feat`: New feature
  - `fix`: Bug fix
  - `docs`: Documentation only
  - `style`: Formatting, no code change
  - `refactor`: Code change that neither fixes bug nor adds feature
  - `perf`: Performance improvement
  - `test`: Adding tests
  - `chore`: Build process, dependencies

  **Examples:**
  ```bash
  git commit -m "feat(auth): add OAuth2 login support"
  git commit -m "fix(api): resolve null pointer in user endpoint"
  git commit -m "docs(readme): update installation instructions"
  git commit -m "refactor(database): optimize query performance"
  git commit -m "test(auth): add unit tests for login flow"
  ```

  ### Commit Often, Push Regularly

  **Good rhythm:**
  - Commit after each logical change
  - Push at least daily
  - Don't wait until "everything is perfect"

  **Small, focused commits:**
  ```bash
  # Bad: One giant commit
  git add .
  git commit -m "Add entire user management system"

  # Good: Multiple focused commits
  git add models/user.js
  git commit -m "feat(user): add User model"

  git add controllers/userController.js
  git commit -m "feat(user): add user controller with CRUD operations"

  git add routes/userRoutes.js
  git commit -m "feat(user): add user routes"

  git add tests/user.test.js
  git commit -m "test(user): add user controller tests"
  ```

  ### What to Commit

  ✅ **Commit:**
  - Source code files
  - Configuration files (public)
  - Documentation
  - Tests
  - Build scripts

  ❌ **Never commit:**
  - Passwords, API keys, secrets
  - Environment files (.env)
  - Build artifacts (dist/, build/)
  - Dependencies (node_modules/)
  - OS files (.DS_Store, Thumbs.db)
  - IDE files (.vscode/, .idea/)
  - Log files (*.log)
  - Sensitive data

  ## .gitignore Best Practices

  ### Common .gitignore Template

  ```bash
  # Dependencies
  node_modules/
  vendor/
  __pycache__/
  *.pyc

  # Environment
  .env
  .env.local
  .env.*.local

  # Build outputs
  dist/
  build/
  out/
  *.o
  *.exe

  # IDE
  .vscode/
  .idea/
  *.swp
  *.swo

  # OS
  .DS_Store
  Thumbs.db
  desktop.ini

  # Logs
  *.log
  npm-debug.log*
  yarn-debug.log*

  # Testing
  coverage/
  .nyc_output/

  # Temporary
  *.tmp
  *.temp
  .cache/
  ```

  ### Adding .gitignore After Files Committed

  ```bash
  # If you already committed files that should be ignored:

  # 1. Add to .gitignore
  echo "node_modules/" >> .gitignore

  # 2. Remove from Git (keep local files)
  git rm -r --cached node_modules/

  # 3. Commit
  git add .gitignore
  git commit -m "chore: add node_modules to gitignore"

  # 4. Push
  git push origin main
  ```

  ## Branching Best Practices

  ### Branch Naming Conventions

  **Pattern:** `<type>/<description-in-kebab-case>`

  ```bash
  # Feature branches
  feature/user-authentication
  feature/payment-integration
  feat/add-dark-mode

  # Bug fixes
  bugfix/fix-login-error
  fix/resolve-memory-leak
  hotfix/security-patch

  # Releases
  release/v1.2.0
  release/2024-q1

  # Experiments
  experiment/new-architecture
  spike/performance-testing

  # Personal branches (team member initials)
  john/refactor-api
  jane/test-new-library
  ```

  ### Branch Lifecycle

  ```bash
  # 1. Create from up-to-date main
  git checkout main
  git pull origin main
  git checkout -b feature/new-dashboard

  # 2. Work and commit
  # ... make changes ...
  git commit -m "feat: add dashboard component"

  # 3. Keep updated with main (regularly)
  git fetch origin
  git merge origin/main  # or: git rebase origin/main

  # 4. Push to remote
  git push -u origin feature/new-dashboard

  # 5. Create pull request

  # 6. After merge, delete branch
  git checkout main
  git pull origin main
  git branch -d feature/new-dashboard
  git push origin --delete feature/new-dashboard
  ```

  ### Keep Branches Short-Lived

  ✅ **Good:** Branches live days, not weeks
  - Less merge conflicts
  - Faster integration
  - Easier code review

  ❌ **Bad:** Long-lived feature branches
  - Massive merge conflicts
  - Integration nightmares
  - Code becomes stale

  ## Common Git Mistakes and Fixes

  ### Mistake 1: Committed to Wrong Branch

  **Problem:** Committed to `main` instead of feature branch

  **Solution:**
  ```bash
  # Don't panic! Don't push yet!

  # Option A: Move commit to new branch
  git branch feature/correct-branch  # Create branch with commit
  git reset --hard HEAD~1  # Undo commit on main

  # Option B: Cherry-pick to correct branch
  git log  # Note commit SHA: abc123
  git checkout -b feature/correct-branch main~1  # Branch from before commit
  git cherry-pick abc123  # Apply commit
  git checkout main
  git reset --hard HEAD~1  # Undo on main
  ```

  ### Mistake 2: Committed Sensitive Data

  **Problem:** Accidentally committed .env file with passwords

  **Solution:**
  ```bash
  # If not pushed yet:
  git rm --cached .env
  git commit --amend --no-edit

  # If already pushed:
  # Use BFG Repo-Cleaner or git filter-branch
  # Better: Rotate all secrets immediately!

  # Add to .gitignore:
  echo ".env" >> .gitignore
  git add .gitignore
  git commit -m "chore: add .env to gitignore"
  ```

  **Important:** Always rotate compromised secrets!

  ### Mistake 3: Committed Wrong Files

  **Problem:** Accidentally committed node_modules/

  **Solution:**
  ```bash
  # Before pushing:
  git reset HEAD~1  # Undo commit, keep changes
  git reset HEAD node_modules/  # Unstage node_modules
  echo "node_modules/" >> .gitignore
  git add .
  git commit -m "Your commit message"

  # After pushing:
  git rm -r --cached node_modules/
  echo "node_modules/" >> .gitignore
  git add .gitignore
  git commit -m "Remove node_modules and add to gitignore"
  git push origin main
  ```

  ### Mistake 4: Need to Undo Last Commit

  **Scenarios:**

  ```bash
  # Undo commit, keep changes (most common)
  git reset --soft HEAD~1
  # Changes still staged, ready to recommit

  # Undo commit and staging, keep files
  git reset HEAD~1
  # or: git reset --mixed HEAD~1
  # Changes in working directory, unstaged

  # Undo commit and delete changes (careful!)
  git reset --hard HEAD~1
  # ⚠️ WARNING: Deletes all changes!
  ```

  ### Mistake 5: Pushed Wrong Code

  **Problem:** Pushed broken code to main

  **Solution:**

  ```bash
  # Option A: Revert commit (safest)
  git revert abc123
  git push origin main
  # Creates new commit undoing changes

  # Option B: Reset (only if no one pulled)
  git reset --hard HEAD~1
  git push --force origin main
  # ⚠️ Only if coordinated with team!
  ```

  ### Mistake 6: Detached HEAD State

  **Problem:** Git says "You are in 'detached HEAD' state"

  ```bash
  # You checked out specific commit
  git checkout abc123  # Now in detached HEAD

  # To fix:
  # Option A: Create branch from here
  git checkout -b new-branch-name

  # Option B: Return to branch
  git checkout main
  ```

  ## Troubleshooting Common Issues

  ### Issue 1: Merge Conflicts

  ```bash
  # During merge:
  git merge feature-branch
  # CONFLICT (content): Merge conflict in file.js

  # Solution:
  # 1. Check conflicted files
  git status

  # 2. Open and edit files, resolve conflicts
  # Remove <<<<<<<, =======, >>>>>>> markers

  # 3. Stage resolved files
  git add file.js

  # 4. Complete merge
  git commit

  # If too complex, abort:
  git merge --abort
  ```

  ### Issue 2: Can't Switch Branches

  ```bash
  # Error: "Your local changes would be overwritten"

  # Solution A: Commit changes
  git add .
  git commit -m "WIP: work in progress"

  # Solution B: Stash changes
  git stash
  git checkout other-branch
  # Later: git stash pop

  # Solution C: Force switch (loses changes!)
  git checkout -f other-branch
  ```

  ### Issue 3: Can't Pull

  ```bash
  # Error: "Your local changes would be overwritten by merge"

  # Solution: Commit or stash first
  git add .
  git commit -m "Save local changes"
  git pull

  # Or:
  git stash
  git pull
  git stash pop
  ```

  ### Issue 4: Accidentally Deleted Branch

  ```bash
  # Find last commit on deleted branch
  git reflog | grep branch-name

  # Recreate branch
  git branch branch-name abc123

  # Or:
  git checkout -b branch-name abc123
  ```

  ### Issue 5: Large File Committed

  ```bash
  # Git rejects push: file too large

  # Solution:
  # 1. Remove from last commit
  git rm --cached large-file.zip
  git commit --amend --no-edit

  # 2. Add to .gitignore
  echo "large-file.zip" >> .gitignore

  # 3. Use Git LFS for large files
  git lfs track "*.zip"
  ```

  ## Git Configuration Best Practices

  ### Essential Config

  ```bash
  # User identity (required)
  git config --global user.name "Your Name"
  git config --global user.email "your.email@example.com"

  # Default branch name
  git config --global init.defaultBranch main

  # Editor
  git config --global core.editor "code --wait"  # VS Code
  # or: vim, nano, emacs

  # Line endings (important for cross-platform)
  # Windows:
  git config --global core.autocrlf true
  # Mac/Linux:
  git config --global core.autocrlf input

  # Colors
  git config --global color.ui auto

  # Default pull behavior
  git config --global pull.rebase false  # merge (default)
  # or: git config --global pull.rebase true  # rebase

  # Credential caching
  git config --global credential.helper cache
  # or on Windows:
  git config --global credential.helper wincred
  ```

  ### Useful Aliases

  ```bash
  # Status
  git config --global alias.st status
  git config --global alias.s "status -s"

  # Logging
  git config --global alias.lg "log --oneline --graph --all"
  git config --global alias.last "log -1 HEAD"

  # Diff
  git config --global alias.df diff
  git config --global alias.dc "diff --cached"

  # Checkout
  git config --global alias.co checkout
  git config --global alias.br branch

  # Commit
  git config --global alias.ci commit
  git config --global alias.amend "commit --amend --no-edit"

  # Undo
  git config --global alias.unstage "reset HEAD --"
  git config --global alias.undo "reset --soft HEAD~1"

  # Now use:
  git st  # instead of git status
  git lg  # beautiful log
  ```

  ## Security Best Practices

  ### Never Commit Secrets

  ✅ **Use environment variables:**
  ```javascript
  // Good
  const apiKey = process.env.API_KEY;

  // Bad
  const apiKey = "abc123secretkey456";  // Never!
  ```

  ✅ **Use .env files (and ignore them):**
  ```bash
  # .env (never commit!)
  API_KEY=abc123secretkey456
  DATABASE_URL=postgres://user:pass@localhost/db

  # .gitignore
  .env
  .env.local
  .env.*.local
  ```

  ✅ **Use secrets managers:**
  - AWS Secrets Manager
  - Azure Key Vault
  - HashiCorp Vault
  - GitHub Secrets (for CI/CD)

  ### Sign Your Commits

  ```bash
  # Generate GPG key
  gpg --gen-key

  # List keys
  gpg --list-secret-keys --keyid-format LONG

  # Configure Git
  git config --global user.signingkey <key-id>
  git config --global commit.gpgsign true

  # Sign commit
  git commit -S -m "Signed commit"

  # Verify
  git log --show-signature
  ```

  ## Team Collaboration Best Practices

  ### Code Review Guidelines

  **As author:**
  - Keep PRs small (< 400 lines)
  - Write clear description
  - Self-review before requesting
  - Respond promptly to feedback

  **As reviewer:**
  - Review within 24 hours
  - Be constructive and kind
  - Test locally if needed
  - Approve or request changes clearly

  ### Communication

  - Document major changes
  - Notify team of force pushes
  - Use PR templates
  - Link commits to issues
  - Update CHANGELOG

  ## Performance Tips

  ```bash
  # Shallow clone (faster, less storage)
  git clone --depth 1 https://github.com/user/repo.git

  # Fetch only what you need
  git fetch origin main

  # Clean up
  git gc  # Garbage collection
  git prune  # Remove unreachable objects

  # Remove merged branches
  git branch --merged | grep -v "\*\|main" | xargs -n 1 git branch -d
  ```

  ## Quick Reference Card

  ```bash
  # Status and Info
  git status              # Show working tree status
  git log --oneline       # Compact log
  git diff                # Show changes

  # Basic Workflow
  git add .               # Stage all changes
  git commit -m "msg"     # Commit with message
  git push                # Push to remote

  # Branching
  git branch              # List branches
  git checkout -b <name>  # Create and switch
  git merge <branch>      # Merge branch

  # Undo
  git reset HEAD~1        # Undo commit, keep changes
  git checkout -- <file>  # Discard changes
  git revert <commit>     # Revert commit

  # Remote
  git fetch               # Download changes
  git pull                # Fetch + merge
  git push -u origin <br> # Push and track

  # Help
  git help <command>      # Get help
  ```

  ## When Things Go Wrong

  **Remember:**
  1. Don't panic!
  2. Git rarely loses data
  3. Use `git reflog` to find lost commits
  4. Make a backup branch before complex operations
  5. Ask for help if unsure

  **Emergency commands:**
  ```bash
  # See all HEAD movements
  git reflog

  # Abort current operation
  git merge --abort
  git rebase --abort
  git cherry-pick --abort

  # Go back to previous state
  git reset --hard HEAD@{1}

  # Create backup
  git branch backup-$(date +%Y%m%d)
  ```

  **Congratulations!** You've completed the Git Fundamentals course. You now have professional Git skills!

exercises:
  - type: mcq
    sequence_order: 1
    question: "What makes a good Git commit message according to best practices?"
    options:
      - "Short one-word descriptions like 'fix' or 'update'"
      - "A short summary (50 chars) in imperative mood, optional detailed explanation, and issue references (e.g., 'Add user authentication' not 'Added auth')"
      - "Very long descriptions with all code changes listed"
      - "Just the file names that were changed"
    correct_answer: "A short summary (50 chars) in imperative mood, optional detailed explanation, and issue references (e.g., 'Add user authentication' not 'Added auth')"
    explanation: "Good commit messages are crucial for project maintainability, code review, and team collaboration. They serve as documentation of why changes were made. Anatomy of a Good Commit Message: (1) Subject Line (Required): Length: 50 characters or less (strict), 72 chars max (hard limit). Mood: Imperative (command form). Correct: 'Add feature', 'Fix bug', 'Update docs'. Incorrect: 'Added feature', 'Fixing bug', 'Updated docs'. Capitalized first word. No period at end. Completes sentence: 'If applied, this commit will [your subject line]'. (2) Blank Line: Separates subject from body. Required if body is present. (3) Body (Optional but Recommended): Wrap at 72 characters. Explain what and why, not how (code shows how). Bullet points okay (use - or *). Multiple paragraphs okay. Link to issues: Fixes #123, Closes #456, Related to #789. Examples of Excellent Commit Messages: Example 1 - New Feature: Subject: Add user authentication with JWT. Body: Implement JWT-based authentication for API endpoints. - Add login and signup endpoints with validation - Create JWT middleware for protected routes - Store tokens securely in httpOnly cookies - Add user session management. Security improvements: Prevents CSRF attacks, tokens expire after 24 hours. Fixes #456, Related to #123. Why good: Clear what was added (JWT auth). Explains how (bullets). Shows benefits (security). Links issue. Example 2 - Bug Fix: Subject: Fix memory leak in WebSocket connection. Body: WebSocket connections weren't being properly closed on component unmount, causing memory to accumulate over time. Added cleanup function in useEffect return that explicitly closes connections. Reproduces after 50+ component mounts. Tested: Memory usage now stable after 1000 mounts. Closes #789. Why good: Explains bug (memory leak). Shows root cause (unclosed connections). Describes solution (cleanup in useEffect). Provides testing evidence. Example 3 - Refactor: Subject: Refactor database queries for performance. Body: Optimize user lookup queries for better performance. Changes: - Add index on email column (250ms → 15ms) - Use SELECT with specific columns vs SELECT * - Implement Redis caching for frequent queries - Batch similar queries. Benchmarks show 94% improvement in user fetching. No behavior changes, all tests pass. Why good: Clear goal (performance). Quantifiable improvements (250ms → 15ms). Lists specific changes. Notes no behavior change. Examples of BAD Commit Messages: ❌ 'fix bug' - Which bug? What was fixed? How? ❌ 'update code' - What code? Why update? ❌ 'changes' - Meaningless, provides zero information. ❌ 'asdf' or 'wip' - Not professional, hard to track. ❌ 'final version 2' - Vague, what's finalized? ❌ 'Fixed the issue with the thing where it wasn't working' - Imprecise, no details. Conventional Commits Format: Pattern: <type>(<scope>): <description>. Types: feat (new feature), fix (bug fix), docs (documentation), style (formatting), refactor (restructure code), perf (performance), test (tests), chore (build, dependencies). Examples: feat(auth): add OAuth2 login support, fix(api): resolve null pointer in user endpoint, docs(readme): update installation instructions, perf(database): optimize query with indexes. Benefits of Good Commit Messages: (1) Code Review: Reviewers understand intent. Faster approval process. Better feedback. (2) Debugging: git log to find when bug introduced. git bisect more effective. Understand historical decisions. (3) Collaboration: New team members understand changes. Distributed teams stay aligned. Knowledge preserved. (4) Documentation: Changelog generation. Release notes. Audit trails. (5) Maintenance: Future you thanks past you! Understand code years later. Tools and Tips: Use templates: git config --global commit.template ~/.gitmessage.txt. Use conventional commits. Write message in editor (git commit) not -m for complex commits. Ask: 'Why did I make this change?' not 'What did I change?'. Link to issue tracker. Best Practice Workflow: Make logical change. git add [files]. git commit (opens editor). Write thoughtful message. Review diff: git diff --staged. Commit if satisfied."
    require_pass: true

  - type: mcq
    sequence_order: 2
    question: "What should you NEVER commit to a Git repository for security reasons?"
    options:
      - "Source code files"
      - "Documentation files"
      - "API keys, passwords, .env files, and other sensitive credentials"
      - "Configuration files"
    correct_answer: "API keys, passwords, .env files, and other sensitive credentials"
    explanation: "Committing secrets to Git is a critical security mistake that can lead to breaches, data leaks, and compromised systems. Once committed, secrets are in Git history forever (unless scrubbed with special tools). What NEVER to Commit: (1) API Keys and Tokens: AWS access keys (AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY). GitHub personal access tokens. Stripe API keys. Third-party service tokens. OAuth client secrets. (2) Passwords and Credentials: Database passwords. Admin passwords. Service account credentials. SSH private keys. SSL/TLS private keys. (3) Environment Files: .env, .env.local, .env.production. config.json (if contains secrets). credentials.json. secrets.yaml. (4) Security Certificates: Private key files (*.key, *.pem). Certificate signing requests with private data. JWT signing keys. (5) Sensitive Business Data: Customer data. PII (Personally Identifiable Information). Financial records. Proprietary algorithms (in public repos). Why It's Dangerous: Example Security Incident: Developer commits: git add config.js (contains API keys), git commit -m 'Update config', git push origin main. Within minutes: Automated bots scan GitHub for secrets. Bots find AWS keys. Attackers spin up EC2 instances for crypto mining. Company receives $50,000 AWS bill. Data breach exposes customer information. Real-world: This happens DAILY to companies. GitHub detects and alerts, but damage may be done. Keys in history even if removed later. How Secrets Get Exposed: (1) Public Repositories: Anyone can clone and view. Bots scan continuously. Git history searchable. (2) Private Repositories: Contractors and temp employees have access. Repos sometimes made public accidentally. Employee laptops stolen. GitHub breaches (rare but possible). (3) Git History: Secrets in old commits stay forever. Removing from latest commit doesn't help. Need to rewrite entire history (complex). Safe Practices: ✅ Use Environment Variables: // Good: const apiKey = process.env.API_KEY; const dbPassword = process.env.DB_PASSWORD; // Bad: const apiKey = 'sk_live_abc123...'; Never hardcode! ✅ Use .env Files (and .gitignore): Create .env file: API_KEY=abc123, DATABASE_URL=postgres://user:pass@localhost/db. Add to .gitignore: echo '.env' >> .gitignore. Never commit .env files! Example .env: # .env (NEVER COMMIT!), NODE_ENV=production, API_KEY=abc123secretkey, DB_PASSWORD=supersecret, JWT_SECRET=random-string. ✅ Use .gitignore: # Security, .env, .env.local, .env.*.local, secrets.json, credentials.json, config/secrets.yml, *.pem, *.key, .aws/credentials. ✅ Use Secrets Managers: AWS Secrets Manager: Centralized secret storage. Automatic rotation. Access control via IAM. Azure Key Vault: Secrets, keys, certificates. Integration with Azure services. HashiCorp Vault: Open source option. Dynamic secrets. Encryption as a service. GitHub Secrets: For CI/CD workflows. Encrypted, not visible in logs. ✅ Separate Config from Code: config.js (public): module.exports = { apiUrl: process.env.API_URL, debug: process.env.DEBUG === 'true' }. .env (private, ignored): API_URL=https://api.example.com, DEBUG=true. What TO Commit: ✅ Source code (.js, .py, .go, .java). ✅ Documentation (README.md, docs/). ✅ Build scripts (Makefile, package.json). ✅ Configuration templates: config.example.json: { 'apiKey': 'YOUR_API_KEY_HERE', 'dbUrl': 'YOUR_DATABASE_URL' }. User copies to config.json and fills in real values. ✅ Tests (*.test.js, *.spec.py). If You Accidentally Commit Secrets: IMMEDIATE ACTIONS: (1) Rotate secrets IMMEDIATELY: Change API keys on provider. Update database passwords. Revoke OAuth tokens. Assume keys compromised! (2) Remove from Git: If not pushed: git reset HEAD~1 (undo commit), git rm --cached .env (remove file), git add .gitignore, git commit. If pushed: Use BFG Repo-Cleaner or git filter-branch. git filter-branch --force --index-filter 'git rm --cached --ignore-unmatch .env' --prune-empty --tag-name-filter cat -- --all. (3) Force push (after backup): git push --force --all origin. (4) Notify team and security. Prevention Tools: (1) git-secrets: AWS tool to prevent secrets. Scans commits for patterns. Pre-commit hook. Install: brew install git-secrets, git secrets --install, git secrets --register-aws. (2) GitGuardian: SaaS solution. Monitors repositories. Alerts on secrets. (3) Pre-commit hooks: Check for secrets before allowing commit. Reject commits with sensitive patterns. (4) GitHub secret scanning: Automatic detection. Notifications for known patterns. Available for public and private repos. Real-World Example: Startup Incident: Junior developer committed .env with Stripe keys. Pushed to public GitHub repo. Bot found keys in 3 minutes. Attacker made unauthorized charges. Company lost $15,000 before catching. Stripe account suspended. Customer trust damaged. Lesson: Always use .gitignore, educate team, use automated scanning. Best Practices Summary: ❌ Never commit: Secrets, API keys, passwords, .env files, credentials. ✅ Always use: Environment variables, .gitignore, secrets managers, config templates. ✅ Install: git-secrets, pre-commit hooks, scanning tools. ✅ If breach: Rotate secrets immediately, remove from history, notify stakeholders."
    require_pass: true

  - type: mcq
    sequence_order: 3
    question: "You accidentally committed to the main branch instead of a feature branch. What's the safest way to fix this?"
    options:
      - "Delete the repository and start over"
      - "Create a new branch from main (preserving the commit), then reset main back one commit: git branch feature/fix && git reset --hard HEAD~1"
      - "Force push to delete the commit"
      - "Just leave it there"
    correct_answer: "Create a new branch from main (preserving the commit), then reset main back one commit: git branch feature/fix && git reset --hard HEAD~1"
    explanation: "Committing to the wrong branch is a common mistake that's easily fixable if caught before pushing. The key is to preserve your work while moving it to the correct branch. The Problem: You're working on a feature. Forget to create/switch to feature branch. Make changes and commit to main: git add ., git commit -m 'Add feature'. Realize: 'Oops! That should be on feature branch!'. Current state: main has your new commit, should be on feature branch. Safe Solution (Before Pushing): Step 1 - Create Feature Branch: git branch feature/my-feature. This creates branch at current commit (includes your work). Main and feature/my-feature now point to same commit. Step 2 - Reset Main: git reset --hard HEAD~1. Moves main back one commit (before your work). Removes commit from main. Step 3 - Switch to Feature Branch: git checkout feature/my-feature. Now on feature branch with your work. Step 4 - Verify: git log (see your commit on feature branch). git checkout main, git log (your commit NOT on main). Success! Detailed Example: # You're on main (forgot to create feature branch): git branch (*main). # Make changes: echo 'new feature' > feature.js. # Commit (OOPS!): git add feature.js, git commit -m 'Add new feature' (abc123). # Realize mistake: git log (see commit on main - should be on feature!). # FIX IT: # 1. Create feature branch (preserves commit): git branch feature/awesome-feature. # 2. Move main back (removes commit from main): git reset --hard HEAD~1. # 3. Switch to feature branch: git checkout feature/awesome-feature. # 4. Verify: git log (see your commit here). git checkout main, git log (commit gone from main). # 5. Continue working: git checkout feature/awesome-feature. (make more changes), git commit -m 'Continue feature'. # 6. Eventually merge via PR: git push -u origin feature/awesome-feature. (create pull request on GitHub). Alternative Methods: Method 1 - Using git reset --soft: # Keep changes staged: git reset --soft HEAD~1. # Stash changes: git stash. # Switch to feature branch: git checkout -b feature/my-feature. # Apply changes: git stash pop. # Recommit: git commit -m 'Add feature'. Pros: Keeps changes staged. Can modify before recommitting. Cons: Extra steps. Method 2 - Using git cherry-pick: # Note commit SHA: git log (abc123). # Reset main: git reset --hard HEAD~1. # Create and switch to feature branch: git checkout -b feature/my-feature main. # Cherry-pick commit: git cherry-pick abc123. Pros: Explicit about moving commit. Cons: More complex. If You Already Pushed: More complex situation because others might have pulled. If no one pulled yet: # Create feature branch: git branch feature/my-feature origin/main. git checkout feature/my-feature. # Reset main locally: git checkout main. git reset --hard HEAD~1. # Force push (DANGEROUS if others have pulled!): git push --force origin main. # Push feature branch: git push -u origin feature/my-feature. ⚠️ WARNING: Coordinate with team before force pushing! If others already pulled: Better to leave commit on main and note it for future. Or: revert commit on main, then add to feature branch. Git revert vs reset: git revert abc123 (creates new commit undoing abc123). git reset --hard HEAD~1 (deletes commit from history). Revert is safer for shared branches. Prevention: ✅ Always check current branch: git branch, git status. ✅ Create feature branch before working: git checkout -b feature/name. ✅ Set up shell prompt showing branch: Add to .bashrc/.zshrc for visual reminder. ✅ Use Git hooks: Pre-commit hook to warn if on main. Real-World Scenario: Team workflow: main branch protected (no direct pushes). All work via feature branches. Developer forgets to create branch: (works on main locally). git commit -m 'Huge feature' (commit to main). Tries to push: git push origin main. Error: 'Protected branch - cannot push directly'. Relief! Mistake caught by branch protection. Fix: git branch feature/huge-feature, git reset --hard origin/main, git checkout feature/huge-feature, git push -u origin feature/huge-feature. Why Other Options are Wrong: ❌ Delete repository: Loses all work! Completely unnecessary. Git designed to recover from mistakes. ❌ Force push to delete: Dangerous if shared. Can lose others' work. No branch protection bypass. ❌ Leave it: Clutters main branch. Breaks CI/CD if main autodeploys. Violates team workflow. ❌ Just create new branch and leave commit on main: Original problem not solved. Main still has unwanted commit. Best Practice: Don't panic - Git rarely loses data. Check if pushed (git status, git log origin/main..main). Use safe method (branch + reset). Verify result before continuing. Continue working on feature branch. Key Takeaway: Create branch before working: git checkout -b feature/name. Always check current branch: git branch or shell prompt. Branch protection prevents worst mistakes. Git provides tools to fix mistakes - learn them!"
    require_pass: true
