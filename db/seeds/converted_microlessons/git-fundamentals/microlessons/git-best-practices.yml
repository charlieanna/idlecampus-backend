slug: git-best-practices
title: Git Best Practices
difficulty: easy
sequence_order: 7
estimated_minutes: 10
key_concepts:
  - Commit messages
  - atomic commits
  - .gitignore
prerequisites:
  - lesson-1
content_md: |
  # Git Best Practices üèÜ

  # 1. Atomic Commits

  One commit = One logical change.
  - **Don't:** Fix a bug, add a feature, and fix a typo in one commit.
  - **Do:** Split into three commits.

  **Why?** Easier to review, easier to revert.

  # 2. Good Commit Messages

  Structure:
  - **Subject:** 50 chars max, imperative mood ("Fix bug" not "Fixed bug").
  - **Body:** Explain *what* and *why*, not *how*.

  ```
  Add user authentication middleware

  Use JWT tokens to secure API endpoints.
  Middleware validates token on protected routes.

  Closes #102
  ```

  # 3. Use .gitignore

  Never commit:
  - Secrets (API keys, passwords)
  - Build artifacts (dist/, build/)
  - Dependencies (node_modules/)
  - System files (.DS_Store)

  # 4. Review Before Commit

  ```bash
  git diff      # Check unstaged changes
  git diff --staged  # Check staged changes
  ```

  Always read your own code before committing.
exercises:
  - type: mcq
    sequence_order: 1
    question: "Which is a good commit message subject?"
    options:
      - "Fixed stuff"
      - "Add inventory management module"
      - "I changed the login page and also fixed a bug in the footer and updated the readme"
      - "Inventory module. Added items. Fixed database."
    correct_answer: "Add inventory management module"
    explanation: "It uses the imperative mood ('Add' not 'Added'), is concise, and describes the change clearly."
    require_pass: true

  - type: code
    sequence_order: 2
    language: bash
    question: "Create a .gitignore file that ignores node_modules"
    starter_code: "# .gitignore content"
    solution_code: "node_modules/"
    hints:
      - "Just the folder name with a slash"
    require_pass: true
