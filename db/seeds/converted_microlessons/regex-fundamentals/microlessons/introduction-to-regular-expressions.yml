slug: introduction-to-regular-expressions
title: Introduction to Regular Expressions
difficulty: easy
sequence_order: 4
estimated_minutes: 2
key_concepts: []
prerequisites: []
content_md: "# Introduction to Regular Expressions \U0001F680\n\n# Introduction to\
  \ Regular Expressions\n\n    Regular expressions (regex) are powerful patterns used\
  \ for matching and manipulating text. They're supported in virtually every programming\
  \ language and are essential for text processing tasks.\n\n    ## What are Regular\
  \ Expressions?\n\n    A regular expression is a sequence of characters that defines\
  \ a search pattern. When you run a regex against text, it returns matches or allows\
  \ you to perform substitutions.\n\n    ### Common Use Cases\n\n    - **Validation**:\
  \ Email addresses, phone numbers, passwords\n    - **Parsing**: Log files, data\
  \ extraction, web scraping\n    - **Search & Replace**: Text editors, IDEs, code\
  \ refactoring\n    - **Data Cleaning**: Removing whitespace, formatting\n    - **Tokenization**:\
  \ Breaking text into words or sentences\n\n    ## Your First Regex\n\n    ### Literal\
  \ Matches\n\n    The simplest regex matches exact text:\n\n    ```python\n    import\
  \ re\n\n    text = \"The cat sat on the mat\"\n    pattern = \"cat\"\n\n    match\
  \ = re.search(pattern, text)\n    print(match.group())  # Output: cat\n    ```\n\
  \n    ## Basic Metacharacters\n\n    Metacharacters are special characters with\
  \ special meanings:\n\n    | Character | Meaning | Example |\n    |-----------|---------|---------|\n\
  \    | `.` | Any character except newline | `c.t` matches \"cat\", \"cot\", \"cut\"\
  \ |\n    | `^` | Start of string | `^The` matches \"The\" at beginning |\n    |\
  \ `$` | End of string | `end$` matches \"end\" at end |\n    | `*` | 0 or more repetitions\
  \ | `ca*t` matches \"ct\", \"cat\", \"caat\" |\n    | `+` | 1 or more repetitions\
  \ | `ca+t` matches \"cat\", \"caat\" but not \"ct\" |\n    | `?` | 0 or 1 repetition\
  \ (optional) | `colou?r` matches \"color\" and \"colour\" |\n    | `|` | OR operator\
  \ | `cat|dog` matches \"cat\" or \"dog\" |\n    | `\\\\` | Escape special character\
  \ | `\\\\.` matches literal \".\" |\n\n    ### The Dot (.) - Universal Wildcard\n\
  \n    ```python\n    pattern = \"c.t\"\n    # Matches: cat, cot, cut, c9t, c@t,\
  \ etc.\n    # Does NOT match: ct (no character between c and t)\n    ```\n\n   \
  \ ### Escape Characters (\\\\)\n\n    To match special characters literally, escape\
  \ them:\n\n    ```python\n    pattern = \"\\\\.\"      # Matches literal \".\"\n\
  \    pattern = \"\\\\$\"      # Matches literal \"$\"\n    pattern = \"\\\\?\" \
  \     # Matches literal \"?\"\n    pattern = \"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\
  \      # Matches literal \"\\\\\\\\\\\\\\\\\"\n    ```\n\n    ## Character Classes\n\
  \n    Character classes match one character from a set:\n\n    ### Basic Syntax:\
  \ [...]\n\n    ```python\n    pattern = \"[aeiou]\"      # Matches any vowel\n \
  \   pattern = \"[0-9]\"        # Matches any digit\n    pattern = \"[a-z]\"    \
  \    # Matches any lowercase letter\n    pattern = \"[A-Z]\"        # Matches any\
  \ uppercase letter\n    pattern = \"[a-zA-Z]\"     # Matches any letter\n    pattern\
  \ = \"[a-zA-Z0-9]\"  # Matches alphanumeric\n    ```\n\n    ### Negated Character\
  \ Classes: [^...]\n\n    ```python\n    pattern = \"[^0-9]\"   # Matches any NON-digit\n\
  \    pattern = \"[^aeiou]\" # Matches any NON-vowel\n    ```\n\n    ### Predefined\
  \ Character Classes\n\n    | Class | Equivalent | Meaning |\n    |-------|------------|---------|\n\
  \    | `\\\\d` | `[0-9]` | Any digit |\n    | `\\\\D` | `[^0-9]` | Any non-digit\
  \ |\n    | `\\\\w` | `[a-zA-Z0-9_]` | Any word character |\n    | `\\\\W` | `[^a-zA-Z0-9_]`\
  \ | Any non-word character |\n    | `\\\\s` | `[ \\\\t\\\\n\\\\r\\\\f\\\\v]` | Any\
  \ whitespace |\n    | `\\\\S` | `[^ \\\\t\\\\n\\\\r\\\\f\\\\v]` | Any non-whitespace\
  \ |\n\n    ### Examples\n\n    ```python\n    # Match a 3-digit number\n    pattern\
  \ = \"\\\\d\\\\d\\\\d\"\n    # Matches: 123, 456, 999\n\n    # Match a word\n  \
  \  pattern = \"\\\\w+\"\n    # Matches: hello, world123, test_case\n\n    # Match\
  \ whitespace-separated words\n    pattern = \"\\\\w+\\\\s+\\\\w+\"\n    # Matches:\
  \ \"hello world\", \"foo bar\"\n    ```\n\n    ## Quantifiers\n\n    Quantifiers\
  \ specify how many times a character or group should appear:\n\n    | Quantifier\
  \ | Meaning | Example |\n    |------------|---------|---------|\n    | `*` | 0 or\
  \ more | `a*` matches \"\", \"a\", \"aa\", \"aaa\" |\n    | `+` | 1 or more | `a+`\
  \ matches \"a\", \"aa\", \"aaa\" (not \"\") |\n    | `?` | 0 or 1 | `a?` matches\
  \ \"\", \"a\" |\n    | `{n}` | Exactly n | `a{3}` matches \"aaa\" |\n    | `{n,}`\
  \ | n or more | `a{2,}` matches \"aa\", \"aaa\", \"aaaa\" |\n    | `{n,m}` | Between\
  \ n and m | `a{2,4}` matches \"aa\", \"aaa\", \"aaaa\" |\n\n    ### Practical Examples\n\
  \n    ```python\n    # Phone number: 3 digits, dash, 4 digits\n    pattern = \"\\\
  \\d{3}-\\\\d{4}\"\n    # Matches: 555-1234\n\n    # Flexible phone: optional area\
  \ code\n    pattern = \"(\\\\d{3}-)?\\\\d{3}-\\\\d{4}\"\n    # Matches: 555-1234\
  \ or 800-555-1234\n\n    # One or more words\n    pattern = \"\\\\w+\"\n    # Matches:\
  \ hello, world123, test\n\n    # Optional plural\n    pattern = \"cats?\"\n    #\
  \ Matches: cat or cats\n    ```\n\n    ## Anchors and Boundaries\n\n    Anchors\
  \ don't match characters—they match positions:\n\n    | Anchor | Meaning | Example\
  \ |\n    |--------|---------|---------|\n    | `^` | Start of string/line | `^Hello`\
  \ matches \"Hello\" at start |\n    | `$` | End of string/line | `world$` matches\
  \ \"world\" at end |\n    | `\\\\b` | Word boundary | `\\\\bcat\\\\b` matches \"\
  cat\" but not \"category\" |\n    | `\\\\B` | Non-word boundary | `\\\\Bcat\\\\\
  B` matches \"category\" but not \"cat\" |\n\n    ### Examples\n\n    ```python\n\
  \    # Entire string must be digits\n    pattern = \"^\\\\d+$\"\n    # Matches:\
  \ \"12345\" (entire string)\n    # Does NOT match: \"abc123\" or \"123abc\"\n\n\
  \    # Match \"cat\" as a whole word\n    pattern = \"\\\\bcat\\\\b\"\n    # Matches:\
  \ \"the cat sat\" (matches \"cat\")\n    # Does NOT match: \"category\" or \"scattered\"\
  \n\n    # Email validation (simplified)\n    pattern = \"^[\\\\w.-]+@[\\\\w.-]+\\\
  \\.\\\\w+$\"\n    # Matches: user@example.com\n    ```\n\n    ## Greedy vs Lazy\
  \ Matching\n\n    ### Greedy (Default)\n    Quantifiers are greedy by default—they\
  \ match as much as possible:\n\n    ```python\n    text = \"<html><body></body></html>\"\
  \n    pattern = \"<.*>\"\n    # Matches: \"<html><body></body></html>\" (everything!)\n\
  \    ```\n\n    ### Lazy (Non-Greedy)\n    Add `?` after quantifier to make it lazy—match\
  \ as little as possible:\n\n    ```python\n    text = \"<html><body></body></html>\"\
  \n    pattern = \"<.*?>\"\n    # Matches: \"<html>\", \"<body>\", \"</body>\", \"\
  </html>\" (separately)\n    ```\n\n    | Greedy | Lazy | Meaning |\n    |--------|------|---------|\n\
  \    | `*` | `*?` | 0 or more (lazy) |\n    | `+` | `+?` | 1 or more (lazy) |\n\
  \    | `?` | `??` | 0 or 1 (lazy) |\n    | `{n,m}` | `{n,m}?` | Between n and m\
  \ (lazy) |\n\n    ## Practical Examples\n\n    ### Validate Email Address (Simple)\n\
  \    ```python\n    pattern = \"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$\"\
  \n    ```\n\n    ### Extract URLs\n    ```python\n    pattern = \"https?://[\\\\\
  w.-]+\\\\.[a-zA-Z]{2,}(/[\\\\w.-]*)*\"\n    ```\n\n    ### Match Phone Numbers\n\
  \    ```python\n    # Format: (123) 456-7890 or 123-456-7890\n    pattern = \"\\\
  \\(?(\\\\d{3})\\\\)?[- ]?(\\\\d{3})[- ]?(\\\\d{4})\"\n    ```\n\n    ### Extract\
  \ Hashtags\n    ```python\n    pattern = \"#\\\\w+\"\n    # Matches: #python, #regex,\
  \ #coding\n    ```\n\n    ## Testing Your Regex\n\n    ### Online Tools\n    - **regex101.com**\
  \ - Best for learning (explanations + testing)\n    - **regexr.com** - Interactive\
  \ with cheat sheet\n    - **regexpal.com** - Simple and fast\n\n    ### In Python\n\
  \    ```python\n    import re\n\n    pattern = r\"\\\\d{3}-\\\\d{4}\"\n    text\
  \ = \"Call me at 555-1234\"\n\n    # Search for first match\n    match = re.search(pattern,\
  \ text)\n    if match:\n        print(f\"Found: {match.group()}\")\n\n    # Find\
  \ all matches\n    matches = re.findall(pattern, text)\n    print(f\"All matches:\
  \ {matches}\")\n    ```\n\n    ## Common Pitfalls\n\n    ### 1. Forgetting to Escape\
  \ Special Characters\n    ```python\n    # ❌ Wrong - tries to match any character\n\
  \    pattern = \".\"\n\n    # ✅ Correct - matches literal period\n    pattern =\
  \ \"\\\\.\"\n    ```\n\n    ### 2. Greedy Matching\n    ```python\n    # ❌ Matches\
  \ too much\n    pattern = \"\\\".*\\\"\"\n    text = '\"Hello\" and \"World\"'\n\
  \    # Matches: \"Hello\" and \"World\" (entire string!)\n\n    # ✅ Use lazy quantifier\n\
  \    pattern = \"\\\".*?\\\"\"\n    # Matches: \"Hello\" and \"World\" (separately)\n\
  \    ```\n\n    ### 3. Not Using Raw Strings (Python)\n    ```python\n    # ❌ Need\
  \ double backslashes\n    pattern = \"\\\\\\\\d+\"\n\n    # ✅ Use raw string\n \
  \   pattern = r\"\\\\d+\"\n    ```\n\n    ## Key Takeaways\n\n    1. **Start simple**\
  \ - Build complex patterns incrementally\n    2. **Test frequently** - Use online\
  \ tools to visualize matches\n    3. **Use raw strings** - `r\"...\"` in Python\
  \ to avoid double escaping\n    4. **Character classes** - `[...]` for sets, `\\\
  \\d \\\\w \\\\s` for common patterns\n    5. **Quantifiers** - `* + ? {n,m}` for\
  \ repetition\n    6. **Anchors** - `^ $ \\\\b` for position matching\n    7. **Lazy\
  \ matching** - Add `?` after quantifiers when needed\n    8. **Practice** - The\
  \ best way to learn is by doing!"
exercises:
- type: mcq
  sequence_order: 1
  question: What is the difference between the metacharacters * (asterisk) and + (plus)
    in regular expressions, and what would the pattern "ca*t" match?
  options:
  - '* means 1 or more; + means 0 or more; "ca*t" matches "cat" and "caat" but not
    "ct"'
  - '* means 0 or more; + means 1 or more; "ca*t" matches "ct", "cat", "caat"'
  - '* and + are identical - both match 1 or more repetitions'
  - '* matches any character; + matches word characters only'
  correct_answer: '* means 0 or more; + means 1 or more; "ca*t" matches "ct", "cat",
    "caat"'
  explanation: 'The asterisk (*) and plus (+) are quantifiers that specify repetition,
    but differ in whether zero occurrences match. The * quantifier means "0 or more
    occurrences" of the preceding element - it will match even if the element appears
    zero times. So "ca*t" matches: (1) "ct" - zero ''a''s, (2) "cat" - one ''a'',
    (3) "caat" - two ''a''s, (4) "caaaat" - many ''a''s. The + quantifier means "1
    or more occurrences" - at least one occurrence required. So "ca+t" matches "cat",
    "caat", "caaaat" but NOT "ct" (no ''a'' present). Other quantifiers: ? means "0
    or 1" (optional - makes sense for things like plural "cats?" matching "cat" or
    "cats"), {n} means exactly n, {n,m} means between n and m occurrences, {n,} means
    n or more. Understanding quantifiers is crucial for patterns like phone numbers
    (\d{3}-\d{4} exactly 3 then 4 digits), optional elements (colou?r matches "color"
    or "colour"), and repeated patterns (\w+ matches one or more word characters).'
  require_pass: true
- type: mcq
  sequence_order: 2
  question: What is the difference between greedy and lazy matching in regex, and
    how does adding ? after a quantifier change the behavior?
  options:
  - Greedy matches as much as possible; lazy matches as little as possible; adding
    ? makes quantifiers lazy
  - Greedy is faster; lazy is more accurate but slower
  - Greedy matches first occurrence; lazy matches last occurrence
  - Adding ? makes the pattern case-insensitive
  correct_answer: Greedy matches as much as possible; lazy matches as little as possible;
    adding ? makes quantifiers lazy
  explanation: 'Greedy vs lazy matching is crucial for correctly extracting data.
    By default, quantifiers (*, +, ?, {n,m}) are greedy - they match as much text
    as possible while still allowing the overall pattern to match. Consider text "<html><body></body></html>"
    with pattern "<.*>" - the greedy .* consumes everything, giving one match: the
    entire string from first < to last >. This is usually NOT what you want when extracting
    HTML tags. Lazy (non-greedy) matching is enabled by adding ? after a quantifier:
    *?, +?, ??, {n,m}?. Lazy quantifiers match as little as possible while still allowing
    the pattern to match. With pattern "<.*?>", the lazy .*? matches minimally, giving
    four separate matches: "<html>", "<body>", "</body>", "</html>". Practical example:
    extracting quoted strings from "text "first" and "second"" - greedy pattern ".*"
    matches "first" and "second" (too much!), while lazy ".*?" correctly matches "first"
    and "second" separately. The lesson: use lazy quantifiers when extracting content
    between delimiters (quotes, tags, parentheses) to avoid over-matching.'
  require_pass: true
- type: mcq
  sequence_order: 3
  question: What is the purpose of anchors (^ $ \b) in regular expressions, and why
    doesn't the pattern "^\d+$" match the string "abc123"?
  options:
  - Anchors match special characters; "^\d+$" doesn't match because it requires the
    entire string to be only digits
  - Anchors mark the beginning and end of patterns; "^\d+$" fails because ^ means
    "not digits"
  - Anchors are for case-insensitive matching; the pattern fails because of mixed
    case
  - ^ and $ are comment markers; the pattern is invalid
  correct_answer: Anchors match special characters; "^\d+$" doesn't match because
    it requires the entire string to be only digits
  explanation: 'Anchors are zero-width assertions - they match positions, not actual
    characters. The ^ (caret) anchor matches the start of a string/line, $ (dollar)
    matches the end, and \b matches word boundaries (transition between \w and \W).
    These are crucial for ensuring patterns match entire strings or specific positions.
    Without anchors, "\d+" would match the "123" part of "abc123" (partial match).
    But "^\d+$" means: (1) ^ - start at beginning of string, (2) \d+ - match one or
    more digits, (3) $ - must reach end of string. This requires the ENTIRE string
    to be digits. "abc123" fails because after matching digits "123", we''re not at
    the end (there are preceding "abc" characters), or alternatively, starting from
    the beginning, "abc" doesn''t match \d+. Anchors are essential for validation:
    email validation "^[\w.-]+@[\w.-]+\.[a-zA-Z]{2,}$" ensures entire string is an
    email (not just contains an email), password validation "^(?=.*[A-Z])(?=.*\d).{8,}$"
    ensures entire password meets requirements. Word boundary \b is useful for matching
    whole words: "\bcat\b" matches "the cat sat" but not "category" or "scattered".'
  require_pass: true
