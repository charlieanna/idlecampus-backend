slug: codesprout-exposing-containers-with-port-mapping
title: 'CodeSprout: Exposing Containers with Port Mapping'
difficulty: easy
sequence_order: 2
estimated_minutes: 2
key_concepts:
- docker-run
- port-mapping
- networking
- container-exposure
- publishing-ports
prerequisites: []
content_md: "# CodeSprout: Exposing Containers with Port Mapping \U0001F680\n\n**Port\
  \ Mapping Challenge** \U0001F310\n\n    Your team lead Sarah has a problem:\n\n\
  \    > \"We deployed our marketing site in a container, but no one can access it!\
  \ The container is running\n    > but when we try to visit the site, nothing loads.\
  \ Can you figure out why?\"\n\n    ### The Problem\n    Containers are **isolated\
  \ by default**. Even if nginx is running perfectly inside the container on port\
  \ 80,\n    your browser on your host machine can't reach it. You need to **map**\
  \ (publish) the container's port to your host.\n\n    ### Port Mapping Explained\n\
  \    Port mapping connects a port on your **host machine** to a port inside the\
  \ **container**:\n\n    ```bash\n    docker run -p HOST_PORT:CONTAINER_PORT image\n\
  \    ```\n\n    - **HOST_PORT** (e.g., `8080`) → Port on your computer\n    - **CONTAINER_PORT**\
  \ (e.g., `80`) → Port inside the container where the app listens\n    - **Format**:\
  \ `-p 8080:80` means \"send traffic from host port 8080 to container port 80\"\n\
  \n    ### Visual Example\n    ```\n    Your Browser → http://localhost:8080 → Docker\
  \ NAT → Container Port 80 → nginx\n    ```\n\n    ### The Solution\n    To make\
  \ the CodeSprout site accessible, we need to:\n    1. Map host port `8080` to container\
  \ port `80` (where nginx listens)\n    2. Run in detached mode (`-d`) so the terminal\
  \ isn't blocked\n    3. Name it `codesprout-web` for easy reference\n\n    ```bash\n\
  \    docker run -d -p 8080:80 --name codesprout-web nginx:alpine\n    ```\n\n  \
  \  After this, anyone can visit `http://localhost:8080` and see the site!\n\n  \
  \  ### Common Mistakes\n    - **Swapping ports**: `-p 80:8080` would try to map\
  \ your host's port 80 to container 8080 (wrong direction!)\n    - **Forgetting `-p`**:\
  \ Container runs but can't be accessed from outside\n    - **Port conflicts**: If\
  \ port 8080 is already in use, Docker will error - try a different port like 8081\n\
  \n## Syntax/Command\n\n```bash\ndocker run -d -p 8080:80 --name codesprout-web nginx:alpine\n\
  ```\n\n## Example\n\n```bash\ndocker run -d --name codesprout-web -p 8080:80 nginx:alpine\n\
  ```\n\n## Key Points\n\n- Port mapping format: -p HOST:CONTAINER → -p 8080:80\n\n\
  - Remember: first number (8080) is your host, second (80) is the container\n\n-\
  \ Use -d to run in background and free your terminal"
exercises:
- type: terminal
  problem_statement: Run an nginx container in detached mode with port mapping so the container's port 80 is accessible from your host machine on port 8080, naming it 'codesprout-web'
  expected_output: Container ID printed, nginx accessible at http://localhost:8080
  language: bash
  starter_code: "# Run with port mapping\n"
  sequence_order: 1
  command: docker run -d -p 8080:80 --name codesprout-web nginx:alpine
  description: Expose the nginx container on port 80 so it can be accessed via http://localhost:8080
  validation:
    must_not_include:
    - Error
    - 'panic:'
  timeout_sec: 60
  require_pass: true
- type: mcq
  sequence_order: 2
  question: In "docker run -p 8080:80 nginx", what does 8080 represent?
  options:
  - The port on the host machine
  - The port inside the container
  - The container ID
  - The process ID
  correct_answer: The port on the host machine
  explanation: "In port mapping syntax -p HOST:CONTAINER, the first number (8080) is the port on your host machine, and the second (80) is the port inside the container. So -p 8080:80 maps host port 8080 to container port 80, meaning traffic to localhost:8080 gets forwarded to port 80 inside the container where nginx is listening."
  require_pass: true
