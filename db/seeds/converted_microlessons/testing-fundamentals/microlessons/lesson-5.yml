slug: lesson-5
title: Lesson 5
difficulty: easy
sequence_order: 5
estimated_minutes: 2
key_concepts: []
prerequisites: []
content_md: "# Microlesson \U0001F680\n\n# Integration and E2E Testing\n\n    **Integration\
  \ tests** verify that multiple components work together correctly. **E2E tests**\
  \ verify complete user workflows from start to finish.\n\n    ## API Testing\n\n\
  \    ### Testing REST APIs with SuperTest (Node.js)\n\n    ```javascript\n    //\
  \ app.js\n    const express = require('express');\n    const app = express();\n\
  \    app.use(express.json());\n\n    const users = [];\n\n    app.post('/api/users',\
  \ (req, res) => {\n      const { name, email } = req.body;\n\n      if (!name ||\
  \ !email) {\n        return res.status(400).json({ error: 'Name and email required'\
  \ });\n      }\n\n      const user = { id: users.length + 1, name, email };\n  \
  \    users.push(user);\n      res.status(201).json(user);\n    });\n\n    app.get('/api/users/:id',\
  \ (req, res) => {\n      const user = users.find(u => u.id === parseInt(req.params.id));\n\
  \      if (!user) {\n        return res.status(404).json({ error: 'User not found'\
  \ });\n      }\n      res.json(user);\n    });\n\n    module.exports = app;\n\n\
  \    // app.test.js\n    const request = require('supertest');\n    const app =\
  \ require('./app');\n\n    describe('Users API', () => {\n      describe('POST /api/users',\
  \ () => {\n        test('creates user with valid data', async () => {\n        \
  \  // ARRANGE\n          const userData = { name: 'Alice', email: 'alice@example.com'\
  \ };\n\n          // ACT\n          const response = await request(app)\n      \
  \      .post('/api/users')\n            .send(userData)\n            .expect(201);\n\
  \n          // ASSERT\n          expect(response.body).toMatchObject({\n       \
  \     id: expect.any(Number),\n            name: 'Alice',\n            email: 'alice@example.com'\n\
  \          });\n        });\n\n        test('returns 400 when name is missing',\
  \ async () => {\n          const response = await request(app)\n            .post('/api/users')\n\
  \            .send({ email: 'alice@example.com' })\n            .expect(400);\n\n\
  \          expect(response.body.error).toBe('Name and email required');\n      \
  \  });\n      });\n\n      describe('GET /api/users/:id', () => {\n        test('returns\
  \ user by id', async () => {\n          // ARRANGE: Create user first\n        \
  \  const createResponse = await request(app)\n            .post('/api/users')\n\
  \            .send({ name: 'Bob', email: 'bob@example.com' });\n          const\
  \ userId = createResponse.body.id;\n\n          // ACT\n          const response\
  \ = await request(app)\n            .get(`/api/users/${userId}`)\n            .expect(200);\n\
  \n          // ASSERT\n          expect(response.body).toEqual({\n            id:\
  \ userId,\n            name: 'Bob',\n            email: 'bob@example.com'\n    \
  \      });\n        });\n\n        test('returns 404 for non-existent user', async\
  \ () => {\n          const response = await request(app)\n            .get('/api/users/99999')\n\
  \            .expect(404);\n\n          expect(response.body.error).toBe('User not\
  \ found');\n        });\n      });\n    });\n    ```\n\n    ### Testing REST APIs\
  \ with Pytest (Python)\n\n    ```python\n    # app.py (Flask)\n    from flask import\
  \ Flask, request, jsonify\n\n    app = Flask(__name__)\n    users = []\n\n    @app.route('/api/users',\
  \ methods=['POST'])\n    def create_user():\n        data = request.get_json()\n\
  \n        if not data.get('name') or not data.get('email'):\n            return\
  \ jsonify({'error': 'Name and email required'}), 400\n\n        user = {\n     \
  \       'id': len(users) + 1,\n            'name': data['name'],\n            'email':\
  \ data['email']\n        }\n        users.append(user)\n        return jsonify(user),\
  \ 201\n\n    @app.route('/api/users/<int:user_id>', methods=['GET'])\n    def get_user(user_id):\n\
  \        user = next((u for u in users if u['id'] == user_id), None)\n        if\
  \ not user:\n            return jsonify({'error': 'User not found'}), 404\n    \
  \    return jsonify(user)\n\n    # test_app.py\n    import pytest\n    from app\
  \ import app\n\n    @pytest.fixture\n    def client():\n        app.config['TESTING']\
  \ = True\n        with app.test_client() as client:\n            yield client\n\n\
  \    class TestUsersAPI:\n        def test_create_user_with_valid_data(self, client):\n\
  \            # ARRANGE\n            user_data = {'name': 'Alice', 'email': 'alice@example.com'}\n\
  \n            # ACT\n            response = client.post('/api/users', json=user_data)\n\
  \n            # ASSERT\n            assert response.status_code == 201\n       \
  \     data = response.get_json()\n            assert data['name'] == 'Alice'\n \
  \           assert data['email'] == 'alice@example.com'\n            assert 'id'\
  \ in data\n\n        def test_create_user_missing_name(self, client):\n        \
  \    # ACT\n            response = client.post('/api/users', json={'email': 'alice@example.com'})\n\
  \n            # ASSERT\n            assert response.status_code == 400\n       \
  \     data = response.get_json()\n            assert data['error'] == 'Name and\
  \ email required'\n\n        def test_get_user_by_id(self, client):\n          \
  \  # ARRANGE: Create user first\n            create_response = client.post('/api/users',\
  \ json={\n                'name': 'Bob',\n                'email': 'bob@example.com'\n\
  \            })\n            user_id = create_response.get_json()['id']\n\n    \
  \        # ACT\n            response = client.get(f'/api/users/{user_id}')\n\n \
  \           # ASSERT\n            assert response.status_code == 200\n         \
  \   data = response.get_json()\n            assert data['name'] == 'Bob'\n     \
  \       assert data['email'] == 'bob@example.com'\n\n        def test_get_nonexistent_user(self,\
  \ client):\n            # ACT\n            response = client.get('/api/users/99999')\n\
  \n            # ASSERT\n            assert response.status_code == 404\n       \
  \     assert response.get_json()['error'] == 'User not found'\n    ```\n\n    ##\
  \ Database Testing\n\n    ### Option 1: In-Memory Database (SQLite)\n\n    ```javascript\n\
  \    // database.js\n    const { Sequelize, DataTypes } = require('sequelize');\n\
  \n    const sequelize = new Sequelize('sqlite::memory:');\n\n    const User = sequelize.define('User',\
  \ {\n      name: {\n        type: DataTypes.STRING,\n        allowNull: false\n\
  \      },\n      email: {\n        type: DataTypes.STRING,\n        allowNull: false,\n\
  \        unique: true\n      }\n    });\n\n    module.exports = { sequelize, User\
  \ };\n\n    // database.test.js\n    const { sequelize, User } = require('./database');\n\
  \n    describe('User Model', () => {\n      beforeAll(async () => {\n        await\
  \ sequelize.sync({ force: true });\n      });\n\n      afterEach(async () => {\n\
  \        await User.destroy({ where: {} });\n      });\n\n      test('creates user\
  \ successfully', async () => {\n        // ARRANGE\n        const userData = { name:\
  \ 'Alice', email: 'alice@example.com' };\n\n        // ACT\n        const user =\
  \ await User.create(userData);\n\n        // ASSERT\n        expect(user.id).toBeDefined();\n\
  \        expect(user.name).toBe('Alice');\n        expect(user.email).toBe('alice@example.com');\n\
  \      });\n\n      test('enforces unique email constraint', async () => {\n   \
  \     // ARRANGE\n        await User.create({ name: 'Alice', email: 'alice@example.com'\
  \ });\n\n        // ACT & ASSERT\n        await expect(\n          User.create({\
  \ name: 'Bob', email: 'alice@example.com' })\n        ).rejects.toThrow();\n   \
  \   });\n\n      test('finds user by email', async () => {\n        // ARRANGE\n\
  \        await User.create({ name: 'Alice', email: 'alice@example.com' });\n\n \
  \       // ACT\n        const user = await User.findOne({ where: { email: 'alice@example.com'\
  \ } });\n\n        // ASSERT\n        expect(user).toBeDefined();\n        expect(user.name).toBe('Alice');\n\
  \      });\n    });\n    ```\n\n    ### Option 2: Test Containers (Real Database)\n\
  \n    ```javascript\n    // database.test.js (with Testcontainers)\n    const {\
  \ GenericContainer } = require('testcontainers');\n    const { Sequelize, DataTypes\
  \ } = require('sequelize');\n\n    describe('User Model with PostgreSQL', () =>\
  \ {\n      let container;\n      let sequelize;\n      let User;\n\n      beforeAll(async\
  \ () => {\n        // Start PostgreSQL container\n        container = await new\
  \ GenericContainer('postgres:15')\n          .withEnvironment({ POSTGRES_PASSWORD:\
  \ 'test' })\n          .withExposedPorts(5432)\n          .start();\n\n        const\
  \ host = container.getHost();\n        const port = container.getMappedPort(5432);\n\
  \n        // Connect to PostgreSQL\n        sequelize = new Sequelize({\n      \
  \    dialect: 'postgres',\n          host,\n          port,\n          username:\
  \ 'postgres',\n          password: 'test',\n          database: 'postgres',\n  \
  \        logging: false\n        });\n\n        User = sequelize.define('User',\
  \ {\n          name: DataTypes.STRING,\n          email: { type: DataTypes.STRING,\
  \ unique: true }\n        });\n\n        await sequelize.sync({ force: true });\n\
  \      }, 60000);\n\n      afterAll(async () => {\n        await sequelize.close();\n\
  \        await container.stop();\n      });\n\n      test('creates user in real\
  \ PostgreSQL', async () => {\n        const user = await User.create({\n       \
  \   name: 'Alice',\n          email: 'alice@example.com'\n        });\n\n      \
  \  expect(user.id).toBeDefined();\n\n        // Verify in database\n        const\
  \ found = await User.findByPk(user.id);\n        expect(found.name).toBe('Alice');\n\
  \      });\n    });\n    ```\n\n    ### Python with Testcontainers\n\n    ```python\n\
  \    # test_database.py\n    import pytest\n    from testcontainers.postgres import\
  \ PostgresContainer\n    from sqlalchemy import create_engine, Column, Integer,\
  \ String\n    from sqlalchemy.ext.declarative import declarative_base\n    from\
  \ sqlalchemy.orm import sessionmaker\n\n    Base = declarative_base()\n\n    class\
  \ User(Base):\n        __tablename__ = 'users'\n        id = Column(Integer, primary_key=True)\n\
  \        name = Column(String, nullable=False)\n        email = Column(String, unique=True,\
  \ nullable=False)\n\n    @pytest.fixture(scope='module')\n    def database():\n\
  \        with PostgresContainer('postgres:15') as postgres:\n            engine\
  \ = create_engine(postgres.get_connection_url())\n            Base.metadata.create_all(engine)\n\
  \            Session = sessionmaker(bind=engine)\n            yield Session()\n\n\
  \    class TestUserModel:\n        def test_create_user(self, database):\n     \
  \       # ARRANGE\n            session = database\n\n            # ACT\n       \
  \     user = User(name='Alice', email='alice@example.com')\n            session.add(user)\n\
  \            session.commit()\n\n            # ASSERT\n            assert user.id\
  \ is not None\n\n            # Verify in database\n            found = session.query(User).filter_by(email='alice@example.com').first()\n\
  \            assert found.name == 'Alice'\n\n        def test_unique_email_constraint(self,\
  \ database):\n            # ARRANGE\n            session = database\n          \
  \  user1 = User(name='Alice', email='alice@example.com')\n            session.add(user1)\n\
  \            session.commit()\n\n            # ACT & ASSERT\n            user2 =\
  \ User(name='Bob', email='alice@example.com')\n            session.add(user2)\n\n\
  \            with pytest.raises(Exception):  # Unique constraint violation\n   \
  \             session.commit()\n    ```\n\n    ## End-to-End Testing with Cypress\n\
  \n    ### Setup Cypress\n\n    ```bash\n    npm install --save-dev cypress\n   \
  \ npx cypress open\n    ```\n\n    ### Example 1: User Registration Flow\n\n   \
  \ ```javascript\n    // cypress/e2e/registration.cy.js\n    describe('User Registration',\
  \ () => {\n      beforeEach(() => {\n        // Reset database before each test\n\
  \        cy.task('db:reset');\n        cy.visit('/register');\n      });\n\n   \
  \   it('successfully registers a new user', () => {\n        // ARRANGE & ACT\n\
  \        cy.get('input[name=\"name\"]').type('Alice Johnson');\n        cy.get('input[name=\"\
  email\"]').type('alice@example.com');\n        cy.get('input[name=\"password\"]').type('SecurePass123!');\n\
  \        cy.get('input[name=\"confirmPassword\"]').type('SecurePass123!');\n   \
  \     cy.get('button[type=\"submit\"]').click();\n\n        // ASSERT\n        cy.url().should('include',\
  \ '/dashboard');\n        cy.contains('Welcome, Alice Johnson').should('be.visible');\n\
  \n        // Verify email was sent (check via API)\n        cy.request('/api/test/emails').then((response)\
  \ => {\n          const emails = response.body;\n          expect(emails).to.have.length(1);\n\
  \          expect(emails[0].to).to.equal('alice@example.com');\n          expect(emails[0].subject).to.include('Welcome');\n\
  \        });\n      });\n\n      it('shows error for duplicate email', () => {\n\
  \        // ARRANGE: Create user first\n        cy.task('db:createUser', {\n   \
  \       name: 'Existing User',\n          email: 'alice@example.com'\n        });\n\
  \n        // ACT\n        cy.get('input[name=\"name\"]').type('Alice Johnson');\n\
  \        cy.get('input[name=\"email\"]').type('alice@example.com');\n        cy.get('input[name=\"\
  password\"]').type('SecurePass123!');\n        cy.get('input[name=\"confirmPassword\"\
  ]').type('SecurePass123!');\n        cy.get('button[type=\"submit\"]').click();\n\
  \n        // ASSERT\n        cy.contains('Email already exists').should('be.visible');\n\
  \        cy.url().should('include', '/register');\n      });\n\n      it('validates\
  \ password requirements', () => {\n        // ACT\n        cy.get('input[name=\"\
  name\"]').type('Alice Johnson');\n        cy.get('input[name=\"email\"]').type('alice@example.com');\n\
  \        cy.get('input[name=\"password\"]').type('weak');\n        cy.get('input[name=\"\
  confirmPassword\"]').type('weak');\n        cy.get('button[type=\"submit\"]').click();\n\
  \n        // ASSERT\n        cy.contains('Password must be at least 8 characters').should('be.visible');\n\
  \      });\n    });\n    ```\n\n    ### Example 2: Shopping Cart E2E Test\n\n  \
  \  ```javascript\n    // cypress/e2e/shopping-cart.cy.js\n    describe('Shopping\
  \ Cart', () => {\n      beforeEach(() => {\n        cy.task('db:reset');\n     \
  \   cy.task('db:seedProducts');\n        cy.visit('/');\n      });\n\n      it('adds\
  \ items to cart and completes checkout', () => {\n        // Browse products\n \
  \       cy.contains('MacBook Pro').click();\n        cy.contains('Add to Cart').click();\n\
  \        cy.contains('Added to cart').should('be.visible');\n\n        // View cart\n\
  \        cy.get('[data-testid=\"cart-icon\"]').click();\n        cy.url().should('include',\
  \ '/cart');\n\n        // Verify item in cart\n        cy.contains('MacBook Pro').should('be.visible');\n\
  \        cy.contains('$2,399.00').should('be.visible');\n\n        // Update quantity\n\
  \        cy.get('input[type=\"number\"]').clear().type('2');\n        cy.contains('$4,798.00').should('be.visible');\n\
  \n        // Proceed to checkout\n        cy.contains('Checkout').click();\n   \
  \     cy.url().should('include', '/checkout');\n\n        // Fill shipping info\n\
  \        cy.get('input[name=\"fullName\"]').type('Alice Johnson');\n        cy.get('input[name=\"\
  address\"]').type('123 Main St');\n        cy.get('input[name=\"city\"]').type('San\
  \ Francisco');\n        cy.get('select[name=\"state\"]').select('CA');\n       \
  \ cy.get('input[name=\"zip\"]').type('94102');\n\n        // Fill payment info\n\
  \        cy.get('input[name=\"cardNumber\"]').type('4111111111111111');\n      \
  \  cy.get('input[name=\"expiry\"]').type('12/25');\n        cy.get('input[name=\"\
  cvv\"]').type('123');\n\n        // Submit order\n        cy.contains('Place Order').click();\n\
  \n        // Verify success\n        cy.url().should('include', '/order/confirmation');\n\
  \        cy.contains('Order confirmed').should('be.visible');\n        cy.contains('Order\
  \ #').should('be.visible');\n\n        // Verify email sent\n        cy.request('/api/test/emails').then((response)\
  \ => {\n          const emails = response.body;\n          const confirmationEmail\
  \ = emails.find(e =>\n            e.subject.includes('Order Confirmation')\n   \
  \       );\n          expect(confirmationEmail).to.exist;\n        });\n      });\n\
  \n      it('applies discount code', () => {\n        // Add item to cart\n     \
  \   cy.contains('MacBook Pro').click();\n        cy.contains('Add to Cart').click();\n\
  \        cy.get('[data-testid=\"cart-icon\"]').click();\n\n        // Apply discount\n\
  \        cy.get('input[name=\"discountCode\"]').type('SAVE20');\n        cy.contains('Apply').click();\n\
  \n        // Verify discount applied\n        cy.contains('Discount (20%)').should('be.visible');\n\
  \        cy.contains('$1,919.20').should('be.visible'); // $2,399 - 20%\n      });\n\
  \    });\n    ```\n\n    ## End-to-End Testing with Selenium\n\n    ```python\n\
  \    # test_e2e.py (Python + Selenium)\n    import pytest\n    from selenium import\
  \ webdriver\n    from selenium.webdriver.common.by import By\n    from selenium.webdriver.support.ui\
  \ import WebDriverWait\n    from selenium.webdriver.support import expected_conditions\
  \ as EC\n\n    @pytest.fixture\n    def driver():\n        driver = webdriver.Chrome()\n\
  \        driver.implicitly_wait(10)\n        yield driver\n        driver.quit()\n\
  \n    class TestUserRegistration:\n        def test_successful_registration(self,\
  \ driver):\n            # ARRANGE\n            driver.get('http://localhost:3000/register')\n\
  \n            # ACT\n            driver.find_element(By.NAME, 'name').send_keys('Alice\
  \ Johnson')\n            driver.find_element(By.NAME, 'email').send_keys('alice@example.com')\n\
  \            driver.find_element(By.NAME, 'password').send_keys('SecurePass123!')\n\
  \            driver.find_element(By.NAME, 'confirmPassword').send_keys('SecurePass123!')\n\
  \            driver.find_element(By.CSS_SELECTOR, 'button[type=\"submit\"]').click()\n\
  \n            # ASSERT\n            WebDriverWait(driver, 10).until(\n         \
  \       EC.url_contains('/dashboard')\n            )\n            assert 'Welcome,\
  \ Alice Johnson' in driver.page_source\n\n        def test_duplicate_email_error(self,\
  \ driver):\n            # ARRANGE: User already exists\n            # (Assume database\
  \ seeded with user)\n\n            # ACT\n            driver.get('http://localhost:3000/register')\n\
  \            driver.find_element(By.NAME, 'name').send_keys('Alice Johnson')\n \
  \           driver.find_element(By.NAME, 'email').send_keys('existing@example.com')\n\
  \            driver.find_element(By.NAME, 'password').send_keys('SecurePass123!')\n\
  \            driver.find_element(By.NAME, 'confirmPassword').send_keys('SecurePass123!')\n\
  \            driver.find_element(By.CSS_SELECTOR, 'button[type=\"submit\"]').click()\n\
  \n            # ASSERT\n            error_message = WebDriverWait(driver, 10).until(\n\
  \                EC.presence_of_element_located((By.CLASS_NAME, 'error-message'))\n\
  \            )\n            assert 'Email already exists' in error_message.text\n\
  \n    class TestLoginFlow:\n        def test_successful_login(self, driver):\n \
  \           # ACT\n            driver.get('http://localhost:3000/login')\n     \
  \       driver.find_element(By.NAME, 'email').send_keys('user@example.com')\n  \
  \          driver.find_element(By.NAME, 'password').send_keys('password123')\n \
  \           driver.find_element(By.CSS_SELECTOR, 'button[type=\"submit\"]').click()\n\
  \n            # ASSERT\n            WebDriverWait(driver, 10).until(\n         \
  \       EC.url_contains('/dashboard')\n            )\n            profile_button\
  \ = driver.find_element(By.ID, 'user-profile')\n            assert profile_button.is_displayed()\n\
  \n        def test_invalid_credentials(self, driver):\n            # ACT\n     \
  \       driver.get('http://localhost:3000/login')\n            driver.find_element(By.NAME,\
  \ 'email').send_keys('user@example.com')\n            driver.find_element(By.NAME,\
  \ 'password').send_keys('wrongpassword')\n            driver.find_element(By.CSS_SELECTOR,\
  \ 'button[type=\"submit\"]').click()\n\n            # ASSERT\n            error_message\
  \ = WebDriverWait(driver, 10).until(\n                EC.presence_of_element_located((By.CLASS_NAME,\
  \ 'error'))\n            )\n            assert 'Invalid email or password' in error_message.text\n\
  \    ```\n\n    ## Cypress vs Selenium\n\n    | Feature | Cypress | Selenium |\n\
  \    |---------|---------|----------|\n    | **Speed** | Fast (runs in browser)\
  \ | Slower (WebDriver protocol) |\n    | **Setup** | Easy (npm install) | Complex\
  \ (drivers, grid) |\n    | **Debugging** | Excellent (time travel, snapshots) |\
  \ Basic |\n    | **Languages** | JavaScript only | Multiple (Python, Java, JS, etc.)\
  \ |\n    | **Real browser** | Chrome/Firefox/Edge | All browsers |\n    | **Cross-browser**\
  \ | Limited | Excellent |\n    | **Mobile** | No | Yes (Appium) |\n    | **Community**\
  \ | Growing | Mature |\n\n    **Choose Cypress if:**\n    - JavaScript project\n\
  \    - Focus on modern browsers\n    - Want fast feedback and great DX\n\n    **Choose\
  \ Selenium if:**\n    - Need multiple languages\n    - Need all browsers (Safari,\
  \ IE)\n    - Need mobile testing\n    - Large existing Selenium investment\n\n \
  \   ## Best Practices for Integration/E2E Tests\n\n    ### 1. Use Test Data Builders\n\
  \n    ```javascript\n    // test-helpers/builders.js\n    class UserBuilder {\n\
  \      constructor() {\n        this.user = {\n          name: 'Test User',\n  \
  \        email: `test${Date.now()}@example.com`,\n          password: 'TestPass123!'\n\
  \        };\n      }\n\n      withName(name) {\n        this.user.name = name;\n\
  \        return this;\n      }\n\n      withEmail(email) {\n        this.user.email\
  \ = email;\n        return this;\n      }\n\n      build() {\n        return this.user;\n\
  \      }\n    }\n\n    // Usage in tests\n    test('creates user', async () => {\n\
  \      const user = new UserBuilder()\n        .withName('Alice')\n        .withEmail('alice@test.com')\n\
  \        .build();\n\n      const response = await request(app)\n        .post('/api/users')\n\
  \        .send(user);\n\n      expect(response.status).toBe(201);\n    });\n   \
  \ ```\n\n    ### 2. Clean Up Test Data\n\n    ```javascript\n    describe('Users\
  \ API', () => {\n      const createdUserIds = [];\n\n      afterEach(async () =>\
  \ {\n        // Clean up created users\n        for (const id of createdUserIds)\
  \ {\n          await User.destroy({ where: { id } });\n        }\n        createdUserIds.length\
  \ = 0;\n      });\n\n      test('creates user', async () => {\n        const response\
  \ = await request(app)\n          .post('/api/users')\n          .send({ name: 'Alice',\
  \ email: 'alice@test.com' });\n\n        createdUserIds.push(response.body.id);\n\
  \        expect(response.status).toBe(201);\n      });\n    });\n    ```\n\n   \
  \ ### 3. Use Page Object Pattern (E2E)\n\n    ```javascript\n    // cypress/pages/LoginPage.js\n\
  \    class LoginPage {\n      visit() {\n        cy.visit('/login');\n      }\n\n\
  \      fillEmail(email) {\n        cy.get('input[name=\"email\"]').type(email);\n\
  \        return this;\n      }\n\n      fillPassword(password) {\n        cy.get('input[name=\"\
  password\"]').type(password);\n        return this;\n      }\n\n      submit() {\n\
  \        cy.get('button[type=\"submit\"]').click();\n        return this;\n    \
  \  }\n\n      shouldShowError(message) {\n        cy.contains(message).should('be.visible');\n\
  \        return this;\n      }\n    }\n\n    // cypress/e2e/login.cy.js\n    import\
  \ LoginPage from '../pages/LoginPage';\n\n    describe('Login', () => {\n      const\
  \ loginPage = new LoginPage();\n\n      it('logs in successfully', () => {\n   \
  \     loginPage\n          .visit()\n          .fillEmail('user@example.com')\n\
  \          .fillPassword('password123')\n          .submit();\n\n        cy.url().should('include',\
  \ '/dashboard');\n      });\n\n      it('shows error for invalid credentials', ()\
  \ => {\n        loginPage\n          .visit()\n          .fillEmail('user@example.com')\n\
  \          .fillPassword('wrongpassword')\n          .submit()\n          .shouldShowError('Invalid\
  \ email or password');\n      });\n    });\n    ```\n\n    ### 4. Wait for Async\
  \ Operations\n\n    ```javascript\n    // ❌ Bad: Fixed timeout\n    cy.wait(5000);\n\
  \n    // ✅ Good: Wait for specific condition\n    cy.get('[data-testid=\"loading\"\
  ]').should('not.exist');\n    cy.get('[data-testid=\"user-profile\"]').should('be.visible');\n\
  \n    // ✅ Good: Wait for network request\n    cy.intercept('GET', '/api/users').as('getUsers');\n\
  \    cy.visit('/users');\n    cy.wait('@getUsers');\n    cy.get('.user-list').should('be.visible');\n\
  \    ```\n\n    **Next**: We'll dive into Test-Driven Development (TDD) and testing\
  \ best practices."
exercises:
- type: mcq
  sequence_order: 1
  question: What is the difference between integration tests and E2E (end-to-end)
    tests?
  options:
  - Integration tests verify individual functions, E2E tests verify classes
  - Integration tests verify multiple components work together, E2E tests verify complete
    user workflows from UI to database
  - They are the same thing with different names
  - Integration tests are slower than E2E tests
  correct_answer: Integration tests verify multiple components work together, E2E
    tests verify complete user workflows from UI to database
  explanation: 'Integration and E2E tests differ in scope and what they verify. Integration
    tests verify that multiple components/modules work together correctly, typically
    testing: (1) API endpoints with real HTTP requests (using SuperTest, pytest),
    (2) Database operations with test database (SQLite in-memory, test PostgreSQL),
    (3) Service-to-service communication, (4) Authentication/authorization flows.
    Scope: Multiple units working together, but not the full system. Example: Test
    POST /api/users creates user in database and returns 201. E2E (End-to-End) tests
    verify complete user workflows from start to finish, simulating real user behavior:
    (1) Full browser automation (Playwright, Cypress, Selenium), (2) UI interactions
    (click, type, navigate), (3) Complete workflows (login → browse → add to cart
    → checkout → verify order), (4) Tests entire stack (frontend, backend, database,
    external services). Scope: Entire application as user experiences it. Example:
    User registers → logs in → creates post → sees post in feed. Testing pyramid:
    Many unit tests (fast, cheap) → Some integration tests (medium speed/cost) → Few
    E2E tests (slow, expensive). E2E tests are brittle and slow but catch issues unit/integration
    tests miss.'
  require_pass: true
- type: mcq
  sequence_order: 2
  question: Why should you use an in-memory database (like SQLite :memory:) for integration
    tests instead of the production database?
  options:
  - In-memory databases are always faster than production databases
  - In-memory databases provide test isolation, speed, and prevent polluting production
    data
  - Production databases cannot be used in test environments
  - In-memory databases have more features than production databases
  correct_answer: In-memory databases provide test isolation, speed, and prevent polluting
    production data
  explanation: 'Using in-memory databases for integration tests provides critical
    benefits: (1) Isolation - Each test runs against fresh database state. No test
    pollution where TestA creates data that affects TestB. Tests can run in parallel
    without conflicts, (2) Speed - In-memory databases are 10-100x faster than disk-based
    databases (no disk I/O). Entire test suite runs in seconds, not minutes, (3) Safety
    - Cannot accidentally modify production/staging data. No need for complex test
    data cleanup, (4) Simplicity - No database server to configure. Works on any developer
    machine without setup. Implementation patterns: beforeEach hook creates fresh
    schema: await sequelize.sync({ force: true }), afterEach clears data: await User.destroy({
    where: {} }). SQLite :memory: is perfect for integration tests, matches PostgreSQL/MySQL
    syntax for most queries. When in-memory is NOT suitable: (1) Testing database-specific
    features (PostgreSQL JSONB, MySQL full-text search), (2) Testing performance/optimization,
    (3) Complex migrations. Solution: Use Docker container with real database, reset
    between tests: docker run --rm postgres:15 for each test. Alternative: Separate
    test database with automatic cleanup.'
  require_pass: true
- type: mcq
  sequence_order: 3
  question: What is the purpose of the SuperTest library in API testing?
  options:
  - SuperTest tests the frontend UI components
  - SuperTest makes HTTP requests to API endpoints without starting a server, enabling
    integration testing
  - SuperTest automatically generates test cases from API documentation
  - SuperTest mocks all database calls
  correct_answer: SuperTest makes HTTP requests to API endpoints without starting
    a server, enabling integration testing
  explanation: 'SuperTest is a Node.js library for testing HTTP APIs by making requests
    to Express/Koa apps without starting an actual server. How it works: (1) Import
    app: const app = require(''./app'') (Express app instance), (2) Make requests:
    request(app).post(''/api/users'').send(data), (3) Assert responses: .expect(201).expect(''Content-Type'',
    /json/). Key features: (1) No server required - SuperTest starts ephemeral server
    internally, faster than real HTTP requests, (2) Chainable assertions: .expect(200).expect(res
    => { expect(res.body.name).toBe(''Alice'') }), (3) Async/await support: const
    res = await request(app).post(''/api/users'').send(userData), (4) Tests real HTTP
    layer - tests routing, middleware, request parsing, response formatting. Benefits:
    (1) Fast - no network overhead, (2) Reliable - no port conflicts, (3) Complete
    - tests full request/response cycle including headers, status codes, body parsing.
    Example flow: Create user via POST → Verify 201 status → Verify response body
    → GET user by ID → Verify same data. SuperTest is essential for API integration
    tests. Alternative for Python: pytest with Flask/FastAPI test client: client.post(''/api/users'',
    json=data).'
  require_pass: true
