slug: lesson-3
title: Lesson 3
difficulty: easy
sequence_order: 3
estimated_minutes: 2
key_concepts: []
prerequisites: []
content_md: "# Microlesson \U0001F680\n\n# Component Design Patterns\n\n    Advanced\
  \ patterns for building flexible, reusable, and composable React components.\n\n\
  \    ## Compound Components Pattern\n\n    **Components that work together to form\
  \ a complete UI**\n\n    Like HTML elements: `<select>` and `<option>` work together.\n\
  \n    ```jsx\n    // Example: Accordion component\n    import { createContext, useContext,\
  \ useState } from 'react';\n\n    // Create context for sharing state\n    const\
  \ AccordionContext = createContext();\n\n    function Accordion({ children, defaultIndex\
  \ = 0 }) {\n      const [activeIndex, setActiveIndex] = useState(defaultIndex);\n\
  \n      const value = { activeIndex, setActiveIndex };\n\n      return (\n     \
  \   <AccordionContext.Provider value={value}>\n          <div className=\"accordion\"\
  >{children}</div>\n        </AccordionContext.Provider>\n      );\n    }\n\n   \
  \ function AccordionItem({ children, index }) {\n      const { activeIndex, setActiveIndex\
  \ } = useContext(AccordionContext);\n      const isActive = activeIndex === index;\n\
  \n      return (\n        <div className=\"accordion-item\">\n          <div\n \
  \           className=\"accordion-header\"\n            onClick={() => setActiveIndex(isActive\
  \ ? -1 : index)}\n          >\n            {children[0]} {/* AccordionHeader */}\n\
  \          </div>\n          {isActive && (\n            <div className=\"accordion-content\"\
  >\n              {children[1]} {/* AccordionPanel */}\n            </div>\n    \
  \      )}\n        </div>\n      );\n    }\n\n    function AccordionHeader({ children\
  \ }) {\n      return <h3>{children}</h3>;\n    }\n\n    function AccordionPanel({\
  \ children }) {\n      return <div>{children}</div>;\n    }\n\n    // Attach sub-components\n\
  \    Accordion.Item = AccordionItem;\n    Accordion.Header = AccordionHeader;\n\
  \    Accordion.Panel = AccordionPanel;\n\n    // Usage - Very flexible API!\n  \
  \  function App() {\n      return (\n        <Accordion defaultIndex={0}>\n    \
  \      <Accordion.Item index={0}>\n            <Accordion.Header>Section 1</Accordion.Header>\n\
  \            <Accordion.Panel>Content for section 1</Accordion.Panel>\n        \
  \  </Accordion.Item>\n\n          <Accordion.Item index={1}>\n            <Accordion.Header>Section\
  \ 2</Accordion.Header>\n            <Accordion.Panel>Content for section 2</Accordion.Panel>\n\
  \          </Accordion.Item>\n\n          <Accordion.Item index={2}>\n         \
  \   <Accordion.Header>Section 3</Accordion.Header>\n            <Accordion.Panel>Content\
  \ for section 3</Accordion.Panel>\n          </Accordion.Item>\n        </Accordion>\n\
  \      );\n    }\n    ```\n\n    ### Real-World Example: Tabs Component\n\n    ```jsx\n\
  \    const TabsContext = createContext();\n\n    function Tabs({ children, defaultTab\
  \ = 0 }) {\n      const [activeTab, setActiveTab] = useState(defaultTab);\n\n  \
  \    return (\n        <TabsContext.Provider value={{ activeTab, setActiveTab }}>\n\
  \          <div className=\"tabs\">{children}</div>\n        </TabsContext.Provider>\n\
  \      );\n    }\n\n    function TabList({ children }) {\n      return <div className=\"\
  tab-list\" role=\"tablist\">{children}</div>;\n    }\n\n    function Tab({ children,\
  \ index }) {\n      const { activeTab, setActiveTab } = useContext(TabsContext);\n\
  \      const isActive = activeTab === index;\n\n      return (\n        <button\n\
  \          role=\"tab\"\n          aria-selected={isActive}\n          className={\\\
  `tab \\${isActive ? 'active' : ''}\\`}\n          onClick={() => setActiveTab(index)}\n\
  \        >\n          {children}\n        </button>\n      );\n    }\n\n    function\
  \ TabPanels({ children }) {\n      return <div className=\"tab-panels\">{children}</div>;\n\
  \    }\n\n    function TabPanel({ children, index }) {\n      const { activeTab\
  \ } = useContext(TabsContext);\n\n      if (activeTab !== index) return null;\n\n\
  \      return (\n        <div role=\"tabpanel\" className=\"tab-panel\">\n     \
  \     {children}\n        </div>\n      );\n    }\n\n    Tabs.List = TabList;\n\
  \    Tabs.Tab = Tab;\n    Tabs.Panels = TabPanels;\n    Tabs.Panel = TabPanel;\n\
  \n    // Usage\n    function Dashboard() {\n      return (\n        <Tabs defaultTab={0}>\n\
  \          <Tabs.List>\n            <Tabs.Tab index={0}>Overview</Tabs.Tab>\n  \
  \          <Tabs.Tab index={1}>Analytics</Tabs.Tab>\n            <Tabs.Tab index={2}>Settings</Tabs.Tab>\n\
  \          </Tabs.List>\n\n          <Tabs.Panels>\n            <Tabs.Panel index={0}>\n\
  \              <Overview />\n            </Tabs.Panel>\n            <Tabs.Panel\
  \ index={1}>\n              <Analytics />\n            </Tabs.Panel>\n         \
  \   <Tabs.Panel index={2}>\n              <Settings />\n            </Tabs.Panel>\n\
  \          </Tabs.Panels>\n        </Tabs>\n      );\n    }\n    ```\n\n    ## Render\
  \ Props Pattern\n\n    **Share code between components using a prop whose value\
  \ is a function**\n\n    ```jsx\n    // Mouse tracker using render props\n    function\
  \ MouseTracker({ render }) {\n      const [position, setPosition] = useState({ x:\
  \ 0, y: 0 });\n\n      useEffect(() => {\n        const handleMouseMove = (e) =>\
  \ {\n          setPosition({ x: e.clientX, y: e.clientY });\n        };\n\n    \
  \    window.addEventListener('mousemove', handleMouseMove);\n        return () =>\
  \ window.removeEventListener('mousemove', handleMouseMove);\n      }, []);\n\n \
  \     return render(position);\n    }\n\n    // Usage - Complete control over rendering!\n\
  \    function App() {\n      return (\n        <div>\n          <h1>Move your mouse!</h1>\n\
  \n          <MouseTracker render={({ x, y }) => (\n            <p>Mouse position:\
  \ ({x}, {y})</p>\n          )} />\n\n          <MouseTracker render={({ x, y })\
  \ => (\n            <div\n              style={{\n                position: 'fixed',\n\
  \                left: x,\n                top: y,\n                width: 20,\n\
  \                height: 20,\n                borderRadius: '50%',\n           \
  \     backgroundColor: 'red',\n                pointerEvents: 'none'\n         \
  \     }}\n            />\n          )} />\n        </div>\n      );\n    }\n   \
  \ ```\n\n    ### Children as Function (Render Props Variant)\n\n    ```jsx\n   \
  \ // Data fetching with render props\n    function DataFetcher({ url, children })\
  \ {\n      const [data, setData] = useState(null);\n      const [loading, setLoading]\
  \ = useState(true);\n      const [error, setError] = useState(null);\n\n      useEffect(()\
  \ => {\n        let cancelled = false;\n\n        fetch(url)\n          .then(res\
  \ => res.json())\n          .then(json => {\n            if (!cancelled) {\n   \
  \           setData(json);\n              setLoading(false);\n            }\n  \
  \        })\n          .catch(err => {\n            if (!cancelled) {\n        \
  \      setError(err);\n              setLoading(false);\n            }\n       \
  \   });\n\n        return () => { cancelled = true; };\n      }, [url]);\n\n   \
  \   return children({ data, loading, error });\n    }\n\n    // Usage\n    function\
  \ UserProfile() {\n      return (\n        <DataFetcher url=\"/api/user\">\n   \
  \       {({ data, loading, error }) => {\n            if (loading) return <Spinner\
  \ />;\n            if (error) return <Error message={error.message} />;\n      \
  \      return <UserCard user={data} />;\n          }}\n        </DataFetcher>\n\
  \      );\n    }\n    ```\n\n    ## Higher-Order Components (HOC)\n\n    **Function\
  \ that takes a component and returns a new enhanced component**\n\n    ```jsx\n\
  \    // HOC for authentication\n    function withAuth(Component) {\n      return\
  \ function AuthenticatedComponent(props) {\n        const { user, loading } = useAuth();\
  \ // Custom hook\n\n        if (loading) {\n          return <Spinner />;\n    \
  \    }\n\n        if (!user) {\n          return <Navigate to=\"/login\" />;\n \
  \       }\n\n        return <Component {...props} user={user} />;\n      };\n  \
  \  }\n\n    // Usage\n    function Dashboard({ user }) {\n      return <h1>Welcome,\
  \ {user.name}!</h1>;\n    }\n\n    const AuthenticatedDashboard = withAuth(Dashboard);\n\
  \n    function App() {\n      return (\n        <Routes>\n          <Route path=\"\
  /dashboard\" element={<AuthenticatedDashboard />} />\n        </Routes>\n      );\n\
  \    }\n    ```\n\n    ### HOC for Data Fetching\n\n    ```jsx\n    // Generic data\
  \ fetching HOC\n    function withData(Component, endpoint) {\n      return function\
  \ DataComponent(props) {\n        const [data, setData] = useState(null);\n    \
  \    const [loading, setLoading] = useState(true);\n        const [error, setError]\
  \ = useState(null);\n\n        useEffect(() => {\n          fetch(endpoint)\n  \
  \          .then(res => res.json())\n            .then(setData)\n            .catch(setError)\n\
  \            .finally(() => setLoading(false));\n        }, []);\n\n        if (loading)\
  \ return <Spinner />;\n        if (error) return <Error error={error} />;\n\n  \
  \      return <Component {...props} data={data} />;\n      };\n    }\n\n    // Usage\n\
  \    function UserList({ data }) {\n      return (\n        <ul>\n          {data.map(user\
  \ => (\n            <li key={user.id}>{user.name}</li>\n          ))}\n        </ul>\n\
  \      );\n    }\n\n    const UserListWithData = withData(UserList, '/api/users');\n\
  \n    function PostList({ data }) {\n      return (\n        <ul>\n          {data.map(post\
  \ => (\n            <li key={post.id}>{post.title}</li>\n          ))}\n       \
  \ </ul>\n      );\n    }\n\n    const PostListWithData = withData(PostList, '/api/posts');\n\
  \    ```\n\n    ### Composing Multiple HOCs\n\n    ```jsx\n    // Compose HOCs together\n\
  \    import { compose } from 'lodash/fp'; // or write your own\n\n    function withLogging(Component)\
  \ {\n      return function LoggingComponent(props) {\n        useEffect(() => {\n\
  \          console.log('Component mounted:', Component.name);\n          return\
  \ () => console.log('Component unmounted:', Component.name);\n        }, []);\n\n\
  \        return <Component {...props} />;\n      };\n    }\n\n    function withAnalytics(Component)\
  \ {\n      return function AnalyticsComponent(props) {\n        useEffect(() =>\
  \ {\n          analytics.track('page_view', { component: Component.name });\n  \
  \      }, []);\n\n        return <Component {...props} />;\n      };\n    }\n\n\
  \    // Compose multiple HOCs\n    const enhance = compose(\n      withAuth,\n \
  \     withLogging,\n      withAnalytics\n    );\n\n    const EnhancedDashboard =\
  \ enhance(Dashboard);\n    ```\n\n    ## Control Props Pattern\n\n    **Let parent\
  \ component control component state (controlled vs uncontrolled)**\n\n    ```jsx\n\
  \    // Controlled + Uncontrolled component\n    function Counter({\n      value:\
  \ controlledValue,           // Controlled\n      defaultValue = 0,            \
  \     // Uncontrolled default\n      onChange,                         // Callback\
  \ for controlled mode\n      ...props\n    }) {\n      // Determine if controlled\
  \ or uncontrolled\n      const isControlled = controlledValue !== undefined;\n \
  \     const [uncontrolledValue, setUncontrolledValue] = useState(defaultValue);\n\
  \n      // Use controlled value if provided, otherwise use internal state\n    \
  \  const value = isControlled ? controlledValue : uncontrolledValue;\n\n      const\
  \ handleIncrement = () => {\n        const newValue = value + 1;\n\n        if (isControlled)\
  \ {\n          // Controlled: notify parent\n          onChange?.(newValue);\n \
  \       } else {\n          // Uncontrolled: update internal state\n          setUncontrolledValue(newValue);\n\
  \        }\n      };\n\n      const handleDecrement = () => {\n        const newValue\
  \ = value - 1;\n\n        if (isControlled) {\n          onChange?.(newValue);\n\
  \        } else {\n          setUncontrolledValue(newValue);\n        }\n      };\n\
  \n      return (\n        <div>\n          <button onClick={handleDecrement}>-</button>\n\
  \          <span>{value}</span>\n          <button onClick={handleIncrement}>+</button>\n\
  \        </div>\n      );\n    }\n\n    // Usage 1: Uncontrolled (component manages\
  \ state)\n    function App() {\n      return <Counter defaultValue={5} />;\n   \
  \ }\n\n    // Usage 2: Controlled (parent manages state)\n    function App() {\n\
  \      const [count, setCount] = useState(10);\n\n      return (\n        <div>\n\
  \          <Counter value={count} onChange={setCount} />\n          <p>Count from\
  \ parent: {count}</p>\n          <button onClick={() => setCount(0)}>Reset from\
  \ parent</button>\n        </div>\n      );\n    }\n    ```\n\n    ### Real-World\
  \ Example: Toggle Component\n\n    ```jsx\n    function Toggle({\n      on: controlledOn,\n\
  \      defaultOn = false,\n      onChange,\n      children\n    }) {\n      const\
  \ isControlled = controlledOn !== undefined;\n      const [uncontrolledOn, setUncontrolledOn]\
  \ = useState(defaultOn);\n\n      const on = isControlled ? controlledOn : uncontrolledOn;\n\
  \n      const toggle = () => {\n        const newOn = !on;\n        if (isControlled)\
  \ {\n          onChange?.(newOn);\n        } else {\n          setUncontrolledOn(newOn);\n\
  \        }\n      };\n\n      return children({ on, toggle });\n    }\n\n    //\
  \ Usage 1: Uncontrolled\n    function App() {\n      return (\n        <Toggle defaultOn={false}>\n\
  \          {({ on, toggle }) => (\n            <div>\n              <Switch on={on}\
  \ onClick={toggle} />\n              {on && <div>The switch is on!</div>}\n    \
  \        </div>\n          )}\n        </Toggle>\n      );\n    }\n\n    // Usage\
  \ 2: Controlled (with validation)\n    function App() {\n      const [isOn, setIsOn]\
  \ = useState(false);\n      const [confirmModalOpen, setConfirmModalOpen] = useState(false);\n\
  \n      const handleChange = (newValue) => {\n        if (newValue === true) {\n\
  \          // Show confirmation before turning on\n          setConfirmModalOpen(true);\n\
  \        } else {\n          setIsOn(false);\n        }\n      };\n\n      const\
  \ confirmTurnOn = () => {\n        setIsOn(true);\n        setConfirmModalOpen(false);\n\
  \      };\n\n      return (\n        <>\n          <Toggle on={isOn} onChange={handleChange}>\n\
  \            {({ on, toggle }) => (\n              <Switch on={on} onClick={toggle}\
  \ />\n            )}\n          </Toggle>\n\n          {confirmModalOpen && (\n\
  \            <Modal>\n              <p>Are you sure you want to turn this on?</p>\n\
  \              <button onClick={confirmTurnOn}>Yes</button>\n              <button\
  \ onClick={() => setConfirmModalOpen(false)}>No</button>\n            </Modal>\n\
  \          )}\n        </>\n      );\n    }\n    ```\n\n    ## State Reducer Pattern\n\
  \n    **Give users control over component's state management logic**\n\n    ```jsx\n\
  \    // Default reducer\n    function toggleReducer(state, action) {\n      switch\
  \ (action.type) {\n        case 'TOGGLE':\n          return { on: !state.on };\n\
  \        case 'SET_ON':\n          return { on: true };\n        case 'SET_OFF':\n\
  \          return { on: false };\n        default:\n          throw new Error(\\\
  `Unsupported action type: \\${action.type}\\`);\n      }\n    }\n\n    function\
  \ Toggle({ reducer = toggleReducer, initialOn = false, children }) {\n      const\
  \ [state, dispatch] = useReducer(reducer, { on: initialOn });\n\n      const toggle\
  \ = () => dispatch({ type: 'TOGGLE' });\n      const setOn = () => dispatch({ type:\
  \ 'SET_ON' });\n      const setOff = () => dispatch({ type: 'SET_OFF' });\n\n  \
  \    return children({ on: state.on, toggle, setOn, setOff });\n    }\n\n    //\
  \ Usage 1: Default behavior\n    function App() {\n      return (\n        <Toggle>\n\
  \          {({ on, toggle }) => (\n            <button onClick={toggle}>\n     \
  \         {on ? 'ON' : 'OFF'}\n            </button>\n          )}\n        </Toggle>\n\
  \      );\n    }\n\n    // Usage 2: Custom reducer with click limit\n    function\
  \ clickLimitReducer(state, action) {\n      const MAX_CLICKS = 4;\n\n      switch\
  \ (action.type) {\n        case 'TOGGLE':\n          if (state.clicks >= MAX_CLICKS)\
  \ {\n            // Prevent toggle after max clicks\n            return state;\n\
  \          }\n          return {\n            on: !state.on,\n            clicks:\
  \ state.clicks + 1\n          };\n        case 'SET_ON':\n          return { ...state,\
  \ on: true };\n        case 'SET_OFF':\n          return { ...state, on: false };\n\
  \        case 'RESET':\n          return { on: false, clicks: 0 };\n        default:\n\
  \          throw new Error(\\`Unsupported action type: \\${action.type}\\`);\n \
  \     }\n    }\n\n    function App() {\n      return (\n        <Toggle reducer={clickLimitReducer}\
  \ initialOn={false}>\n          {({ on, toggle }) => {\n            const [state,\
  \ dispatch] = useReducer(clickLimitReducer, { on: false, clicks: 0 });\n\n     \
  \       return (\n              <div>\n                <button onClick={toggle}\
  \ disabled={state.clicks >= 4}>\n                  {on ? 'ON' : 'OFF'}\n       \
  \         </button>\n                <p>Clicks: {state.clicks}/4</p>\n         \
  \       {state.clicks >= 4 && (\n                  <button onClick={() => dispatch({\
  \ type: 'RESET' })}>\n                    Reset\n                  </button>\n \
  \               )}\n              </div>\n            );\n          }}\n       \
  \ </Toggle>\n      );\n    }\n    ```\n\n    ## Pattern Comparison\n\n    | Pattern\
  \ | Best For | Flexibility | Complexity |\n    |---------|----------|-------------|------------|\n\
  \    | **Compound Components** | Related components working together | High | Medium\
  \ |\n    | **Render Props** | Sharing logic with full render control | Very High\
  \ | Low |\n    | **HOC** | Cross-cutting concerns, reusable logic | Medium | Medium\
  \ |\n    | **Control Props** | Making component controlled/uncontrolled | High |\
  \ Low |\n    | **State Reducer** | Giving users control over state logic | Very\
  \ High | High |\n\n    ## When to Use Each Pattern\n\n    ### Compound Components\n\
  \    ✅ Tabs, Accordions, Dropdowns, Modals\n    ✅ When components naturally work\
  \ together\n    ✅ Want flexible composition\n\n    ### Render Props\n    ✅ Data\
  \ fetching, Mouse tracking, Drag and drop\n    ✅ Need full control over rendering\n\
  \    ✅ Share logic without assuming UI\n\n    ### Higher-Order Components\n    ✅\
  \ Authentication, Logging, Analytics\n    ✅ Cross-cutting concerns across many components\n\
  \    ✅ Enhance components with same logic\n\n    ### Control Props\n    ✅ Form inputs,\
  \ Toggles, Any component that manages state\n    ✅ Want both controlled and uncontrolled\
  \ modes\n    ✅ Give users flexibility\n\n    ### State Reducer\n    ✅ Complex components\
  \ with custom behavior needs\n    ✅ Library components used in many contexts\n \
  \   ✅ Users need to customize state logic\n\n    ## Real-World Example: Dropdown\
  \ Menu\n\n    **Combining multiple patterns**\n\n    ```jsx\n    // Using Compound\
  \ Components + Control Props + Render Props\n    const DropdownContext = createContext();\n\
  \n    function Dropdown({\n      children,\n      isOpen: controlledIsOpen,\n  \
  \    defaultIsOpen = false,\n      onOpenChange\n    }) {\n      const isControlled\
  \ = controlledIsOpen !== undefined;\n      const [uncontrolledIsOpen, setUncontrolledIsOpen]\
  \ = useState(defaultIsOpen);\n\n      const isOpen = isControlled ? controlledIsOpen\
  \ : uncontrolledIsOpen;\n\n      const toggle = () => {\n        const newIsOpen\
  \ = !isOpen;\n        if (isControlled) {\n          onOpenChange?.(newIsOpen);\n\
  \        } else {\n          setUncontrolledIsOpen(newIsOpen);\n        }\n    \
  \  };\n\n      const open = () => {\n        if (isControlled) {\n          onOpenChange?.(true);\n\
  \        } else {\n          setUncontrolledIsOpen(true);\n        }\n      };\n\
  \n      const close = () => {\n        if (isControlled) {\n          onOpenChange?.(false);\n\
  \        } else {\n          setUncontrolledIsOpen(false);\n        }\n      };\n\
  \n      return (\n        <DropdownContext.Provider value={{ isOpen, toggle, open,\
  \ close }}>\n          {children}\n        </DropdownContext.Provider>\n      );\n\
  \    }\n\n    function DropdownTrigger({ children }) {\n      const { toggle } =\
  \ useContext(DropdownContext);\n      return <button onClick={toggle}>{children}</button>;\n\
  \    }\n\n    function DropdownMenu({ children }) {\n      const { isOpen } = useContext(DropdownContext);\n\
  \      if (!isOpen) return null;\n      return <div className=\"dropdown-menu\"\
  >{children}</div>;\n    }\n\n    function DropdownItem({ children, onClick }) {\n\
  \      const { close } = useContext(DropdownContext);\n\n      const handleClick\
  \ = () => {\n        onClick?.();\n        close();\n      };\n\n      return (\n\
  \        <button className=\"dropdown-item\" onClick={handleClick}>\n          {children}\n\
  \        </button>\n      );\n    }\n\n    Dropdown.Trigger = DropdownTrigger;\n\
  \    Dropdown.Menu = DropdownMenu;\n    Dropdown.Item = DropdownItem;\n\n    //\
  \ Usage\n    function UserMenu() {\n      return (\n        <Dropdown>\n       \
  \   <Dropdown.Trigger>\n            User Menu ▼\n          </Dropdown.Trigger>\n\
  \          <Dropdown.Menu>\n            <Dropdown.Item onClick={() => navigate('/profile')}>\n\
  \              Profile\n            </Dropdown.Item>\n            <Dropdown.Item\
  \ onClick={() => navigate('/settings')}>\n              Settings\n            </Dropdown.Item>\n\
  \            <Dropdown.Item onClick={handleLogout}>\n              Logout\n    \
  \        </Dropdown.Item>\n          </Dropdown.Menu>\n        </Dropdown>\n   \
  \   );\n    }\n    ```\n\n    ## Best Practices\n\n    1. **Start simple** - Don't\
  \ over-engineer. Use patterns when complexity demands it.\n    2. **Prefer hooks**\
  \ - Modern React favors hooks over HOCs and render props.\n    3. **Compound components\
  \ for related UI** - Great for flexible component APIs.\n    4. **Document your\
  \ patterns** - Make it clear how components should be used.\n    5. **Test thoroughly**\
  \ - Complex patterns need comprehensive tests.\n\n    **You've mastered advanced\
  \ React patterns! Use these to build flexible, reusable component libraries.**"
exercises: []
