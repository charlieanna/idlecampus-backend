slug: lesson-1
title: Lesson 1
difficulty: easy
sequence_order: 1
estimated_minutes: 2
key_concepts: []
prerequisites: []
content_md: "# Microlesson \U0001F680\n\n# Custom Hooks and Advanced Patterns\n\n\
  \    **Custom hooks** let you extract component logic into reusable functions, enabling\
  \ powerful composition patterns.\n\n    ## Why Custom Hooks?\n\n    **Problems custom\
  \ hooks solve:**\n    - Code duplication across components\n    - Complex component\
  \ logic\n    - Sharing stateful logic\n    - Abstracting imperative code\n\n   \
  \ ```jsx\n    // Without custom hook - duplicated logic\n    function UserProfile()\
  \ {\n      const [user, setUser] = useState(null);\n      const [loading, setLoading]\
  \ = useState(true);\n      const [error, setError] = useState(null);\n\n      useEffect(()\
  \ => {\n        fetch('/api/user')\n          .then(res => res.json())\n       \
  \   .then(setUser)\n          .catch(setError)\n          .finally(() => setLoading(false));\n\
  \      }, []);\n\n      // Component logic...\n    }\n\n    function PostList()\
  \ {\n      const [posts, setPosts] = useState(null);\n      const [loading, setLoading]\
  \ = useState(true);\n      const [error, setError] = useState(null);\n\n      useEffect(()\
  \ => {\n        fetch('/api/posts')\n          .then(res => res.json())\n      \
  \    .then(setPosts)\n          .catch(setError)\n          .finally(() => setLoading(false));\n\
  \      }, []);\n\n      // Same pattern repeated!\n    }\n    ```\n\n    ## Custom\
  \ Hook: useFetch\n\n    **Extract data fetching logic into a reusable hook**\n\n\
  \    ```jsx\n    // hooks/useFetch.js\n    import { useState, useEffect } from 'react';\n\
  \n    function useFetch(url, options = {}) {\n      const [data, setData] = useState(null);\n\
  \      const [loading, setLoading] = useState(true);\n      const [error, setError]\
  \ = useState(null);\n\n      useEffect(() => {\n        let cancelled = false;\n\
  \n        const fetchData = async () => {\n          try {\n            setLoading(true);\n\
  \            const response = await fetch(url, options);\n\n            if (!response.ok)\
  \ {\n              throw new Error(\\`HTTP error! status: \\${response.status}\\\
  `);\n            }\n\n            const json = await response.json();\n\n      \
  \      if (!cancelled) {\n              setData(json);\n              setError(null);\n\
  \            }\n          } catch (err) {\n            if (!cancelled) {\n     \
  \         setError(err.message);\n              setData(null);\n            }\n\
  \          } finally {\n            if (!cancelled) {\n              setLoading(false);\n\
  \            }\n          }\n        };\n\n        fetchData();\n\n        // Cleanup\
  \ function to prevent state updates on unmounted component\n        return () =>\
  \ {\n          cancelled = true;\n        };\n      }, [url, JSON.stringify(options)]);\
  \ // Re-fetch when URL or options change\n\n      return { data, loading, error\
  \ };\n    }\n\n    // Usage\n    function UserProfile() {\n      const { data: user,\
  \ loading, error } = useFetch('/api/user');\n\n      if (loading) return <div>Loading...</div>;\n\
  \      if (error) return <div>Error: {error}</div>;\n      return <div>Hello, {user.name}!</div>;\n\
  \    }\n\n    function PostList() {\n      const { data: posts, loading, error }\
  \ = useFetch('/api/posts');\n\n      if (loading) return <div>Loading...</div>;\n\
  \      if (error) return <div>Error: {error}</div>;\n      return (\n        <ul>\n\
  \          {posts.map(post => (\n            <li key={post.id}>{post.title}</li>\n\
  \          ))}\n        </ul>\n      );\n    }\n    ```\n\n    ## Custom Hook: useLocalStorage\n\
  \n    **Sync state with localStorage**\n\n    ```jsx\n    // hooks/useLocalStorage.js\n\
  \    import { useState, useEffect } from 'react';\n\n    function useLocalStorage(key,\
  \ initialValue) {\n      // Initialize state with value from localStorage or initialValue\n\
  \      const [storedValue, setStoredValue] = useState(() => {\n        try {\n \
  \         const item = window.localStorage.getItem(key);\n          return item\
  \ ? JSON.parse(item) : initialValue;\n        } catch (error) {\n          console.error(\\\
  `Error reading localStorage key \"\\${key}\":\\`, error);\n          return initialValue;\n\
  \        }\n      });\n\n      // Update localStorage when state changes\n     \
  \ const setValue = (value) => {\n        try {\n          // Allow value to be a\
  \ function (same API as useState)\n          const valueToStore = value instanceof\
  \ Function ? value(storedValue) : value;\n\n          setStoredValue(valueToStore);\n\
  \          window.localStorage.setItem(key, JSON.stringify(valueToStore));\n   \
  \     } catch (error) {\n          console.error(\\`Error setting localStorage key\
  \ \"\\${key}\":\\`, error);\n        }\n      };\n\n      // Listen to storage events\
  \ from other tabs/windows\n      useEffect(() => {\n        const handleStorageChange\
  \ = (e) => {\n          if (e.key === key && e.newValue !== null) {\n          \
  \  setStoredValue(JSON.parse(e.newValue));\n          }\n        };\n\n        window.addEventListener('storage',\
  \ handleStorageChange);\n        return () => window.removeEventListener('storage',\
  \ handleStorageChange);\n      }, [key]);\n\n      return [storedValue, setValue];\n\
  \    }\n\n    // Usage\n    function ThemeToggle() {\n      const [theme, setTheme]\
  \ = useLocalStorage('theme', 'light');\n\n      return (\n        <button onClick={()\
  \ => setTheme(theme === 'light' ? 'dark' : 'light')}>\n          Current theme:\
  \ {theme}\n        </button>\n      );\n    }\n\n    // Works across tabs - change\
  \ theme in one tab, updates in all tabs!\n    ```\n\n    ## Custom Hook: useDebounce\n\
  \n    **Delay updating a value until user stops typing**\n\n    ```jsx\n    // hooks/useDebounce.js\n\
  \    import { useState, useEffect } from 'react';\n\n    function useDebounce(value,\
  \ delay = 500) {\n      const [debouncedValue, setDebouncedValue] = useState(value);\n\
  \n      useEffect(() => {\n        // Set timeout to update debounced value\n  \
  \      const handler = setTimeout(() => {\n          setDebouncedValue(value);\n\
  \        }, delay);\n\n        // Clear timeout if value changes before delay\n\
  \        return () => {\n          clearTimeout(handler);\n        };\n      },\
  \ [value, delay]);\n\n      return debouncedValue;\n    }\n\n    // Usage: Search\
  \ with debouncing\n    function SearchUsers() {\n      const [searchTerm, setSearchTerm]\
  \ = useState('');\n      const debouncedSearchTerm = useDebounce(searchTerm, 500);\n\
  \      const { data: results, loading } = useFetch(\n        debouncedSearchTerm\n\
  \          ? \\`/api/users?q=\\${debouncedSearchTerm}\\`\n          : null\n   \
  \   );\n\n      return (\n        <div>\n          <input\n            type=\"text\"\
  \n            value={searchTerm}\n            onChange={(e) => setSearchTerm(e.target.value)}\n\
  \            placeholder=\"Search users...\"\n          />\n          {loading &&\
  \ <div>Searching...</div>}\n          {results && (\n            <ul>\n        \
  \      {results.map(user => (\n                <li key={user.id}>{user.name}</li>\n\
  \              ))}\n            </ul>\n          )}\n        </div>\n      );\n\
  \    }\n    // Only fetches after user stops typing for 500ms!\n    ```\n\n    ##\
  \ Custom Hook: useToggle\n\n    **Simple boolean state toggle**\n\n    ```jsx\n\
  \    // hooks/useToggle.js\n    import { useState, useCallback } from 'react';\n\
  \n    function useToggle(initialValue = false) {\n      const [value, setValue]\
  \ = useState(initialValue);\n\n      const toggle = useCallback(() => {\n      \
  \  setValue(v => !v);\n      }, []);\n\n      const setTrue = useCallback(() =>\
  \ {\n        setValue(true);\n      }, []);\n\n      const setFalse = useCallback(()\
  \ => {\n        setValue(false);\n      }, []);\n\n      return [value, { toggle,\
  \ setTrue, setFalse }];\n    }\n\n    // Usage\n    function Modal() {\n      const\
  \ [isOpen, { toggle, setTrue, setFalse }] = useToggle(false);\n\n      return (\n\
  \        <>\n          <button onClick={setTrue}>Open Modal</button>\n         \
  \ {isOpen && (\n            <div className=\"modal\">\n              <h2>Modal Content</h2>\n\
  \              <button onClick={setFalse}>Close</button>\n            </div>\n \
  \         )}\n        </>\n      );\n    }\n    ```\n\n    ## Hook Composition\n\
  \n    **Combine multiple hooks for complex functionality**\n\n    ```jsx\n    //\
  \ hooks/useApi.js\n    import { useState, useCallback } from 'react';\n\n    //\
  \ Composing useFetch with manual trigger\n    function useApi(url, options = {})\
  \ {\n      const [data, setData] = useState(null);\n      const [loading, setLoading]\
  \ = useState(false);\n      const [error, setError] = useState(null);\n\n      const\
  \ execute = useCallback(async (additionalOptions = {}) => {\n        try {\n   \
  \       setLoading(true);\n          setError(null);\n\n          const response\
  \ = await fetch(url, { ...options, ...additionalOptions });\n\n          if (!response.ok)\
  \ {\n            throw new Error(\\`HTTP error! status: \\${response.status}\\`);\n\
  \          }\n\n          const json = await response.json();\n          setData(json);\n\
  \          return json;\n        } catch (err) {\n          setError(err.message);\n\
  \          throw err;\n        } finally {\n          setLoading(false);\n     \
  \   }\n      }, [url, JSON.stringify(options)]);\n\n      return { data, loading,\
  \ error, execute };\n    }\n\n    // Usage: Manual data submission\n    function\
  \ CreatePost() {\n      const { data, loading, error, execute } = useApi('/api/posts',\
  \ {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json'\
  \ }\n      });\n\n      const handleSubmit = async (e) => {\n        e.preventDefault();\n\
  \        const formData = new FormData(e.target);\n        const post = Object.fromEntries(formData);\n\
  \n        try {\n          await execute({ body: JSON.stringify(post) });\n    \
  \      alert('Post created!');\n        } catch (err) {\n          // Error already\
  \ set in hook\n        }\n      };\n\n      return (\n        <form onSubmit={handleSubmit}>\n\
  \          <input name=\"title\" placeholder=\"Title\" required />\n          <textarea\
  \ name=\"content\" placeholder=\"Content\" required />\n          <button type=\"\
  submit\" disabled={loading}>\n            {loading ? 'Creating...' : 'Create Post'}\n\
  \          </button>\n          {error && <div className=\"error\">{error}</div>}\n\
  \        </form>\n      );\n    }\n    ```\n\n    ## useReducer for Complex State\n\
  \n    **When state updates depend on previous state or have complex logic**\n\n\
  \    ```jsx\n    import { useReducer } from 'react';\n\n    // State management\
  \ for a shopping cart\n    const initialState = {\n      items: [],\n      total:\
  \ 0\n    };\n\n    function cartReducer(state, action) {\n      switch (action.type)\
  \ {\n        case 'ADD_ITEM': {\n          const existingItem = state.items.find(item\
  \ => item.id === action.payload.id);\n\n          if (existingItem) {\n        \
  \    // Increase quantity\n            return {\n              ...state,\n     \
  \         items: state.items.map(item =>\n                item.id === action.payload.id\n\
  \                  ? { ...item, quantity: item.quantity + 1 }\n                \
  \  : item\n              ),\n              total: state.total + action.payload.price\n\
  \            };\n          } else {\n            // Add new item\n            return\
  \ {\n              ...state,\n              items: [...state.items, { ...action.payload,\
  \ quantity: 1 }],\n              total: state.total + action.payload.price\n   \
  \         };\n          }\n        }\n\n        case 'REMOVE_ITEM': {\n        \
  \  const item = state.items.find(item => item.id === action.payload);\n        \
  \  return {\n            ...state,\n            items: state.items.filter(item =>\
  \ item.id !== action.payload),\n            total: state.total - (item.price * item.quantity)\n\
  \          };\n        }\n\n        case 'UPDATE_QUANTITY': {\n          const item\
  \ = state.items.find(item => item.id === action.payload.id);\n          const oldQuantity\
  \ = item.quantity;\n          const newQuantity = action.payload.quantity;\n   \
  \       const quantityDiff = newQuantity - oldQuantity;\n\n          return {\n\
  \            ...state,\n            items: state.items.map(item =>\n           \
  \   item.id === action.payload.id\n                ? { ...item, quantity: newQuantity\
  \ }\n                : item\n            ),\n            total: state.total + (item.price\
  \ * quantityDiff)\n          };\n        }\n\n        case 'CLEAR_CART':\n     \
  \     return initialState;\n\n        default:\n          throw new Error(\\`Unknown\
  \ action: \\${action.type}\\`);\n      }\n    }\n\n    function ShoppingCart() {\n\
  \      const [state, dispatch] = useReducer(cartReducer, initialState);\n\n    \
  \  const addItem = (product) => {\n        dispatch({ type: 'ADD_ITEM', payload:\
  \ product });\n      };\n\n      const removeItem = (productId) => {\n        dispatch({\
  \ type: 'REMOVE_ITEM', payload: productId });\n      };\n\n      const updateQuantity\
  \ = (productId, quantity) => {\n        dispatch({ type: 'UPDATE_QUANTITY', payload:\
  \ { id: productId, quantity } });\n      };\n\n      const clearCart = () => {\n\
  \        dispatch({ type: 'CLEAR_CART' });\n      };\n\n      return (\n       \
  \ <div>\n          <h2>Shopping Cart</h2>\n          {state.items.map(item => (\n\
  \            <div key={item.id}>\n              <span>{item.name}</span>\n     \
  \         <input\n                type=\"number\"\n                value={item.quantity}\n\
  \                onChange={(e) => updateQuantity(item.id, parseInt(e.target.value))}\n\
  \                min=\"1\"\n              />\n              <span>\\${item.price\
  \ * item.quantity}</span>\n              <button onClick={() => removeItem(item.id)}>Remove</button>\n\
  \            </div>\n          ))}\n          <div>Total: \\${state.total.toFixed(2)}</div>\n\
  \          <button onClick={clearCart}>Clear Cart</button>\n        </div>\n   \
  \   );\n    }\n    ```\n\n    ## Context API Optimization\n\n    **Problem: Context\
  \ re-renders all consumers when any value changes**\n\n    ```jsx\n    // ❌ Bad:\
  \ Re-renders all consumers on any state change\n    const AppContext = React.createContext();\n\
  \n    function AppProvider({ children }) {\n      const [user, setUser] = useState(null);\n\
  \      const [theme, setTheme] = useState('light');\n      const [notifications,\
  \ setNotifications] = useState([]);\n\n      // All consumers re-render when ANY\
  \ of these change!\n      const value = { user, setUser, theme, setTheme, notifications,\
  \ setNotifications };\n\n      return <AppContext.Provider value={value}>{children}</AppContext.Provider>;\n\
  \    }\n    ```\n\n    ### Solution 1: Split Contexts\n\n    ```jsx\n    // ✅ Good:\
  \ Separate contexts for different concerns\n    const UserContext = React.createContext();\n\
  \    const ThemeContext = React.createContext();\n    const NotificationContext\
  \ = React.createContext();\n\n    function AppProvider({ children }) {\n      const\
  \ [user, setUser] = useState(null);\n      const [theme, setTheme] = useState('light');\n\
  \      const [notifications, setNotifications] = useState([]);\n\n      // Memoize\
  \ values to prevent unnecessary re-renders\n      const userValue = useMemo(() =>\
  \ ({ user, setUser }), [user]);\n      const themeValue = useMemo(() => ({ theme,\
  \ setTheme }), [theme]);\n      const notificationValue = useMemo(\n        () =>\
  \ ({ notifications, setNotifications }),\n        [notifications]\n      );\n\n\
  \      return (\n        <UserContext.Provider value={userValue}>\n          <ThemeContext.Provider\
  \ value={themeValue}>\n            <NotificationContext.Provider value={notificationValue}>\n\
  \              {children}\n            </NotificationContext.Provider>\n       \
  \   </ThemeContext.Provider>\n        </UserContext.Provider>\n      );\n    }\n\
  \n    // Components only subscribe to what they need\n    function UserProfile()\
  \ {\n      const { user } = useContext(UserContext); // Only re-renders when user\
  \ changes\n      return <div>{user?.name}</div>;\n    }\n\n    function ThemeToggle()\
  \ {\n      const { theme, setTheme } = useContext(ThemeContext); // Only re-renders\
  \ when theme changes\n      return <button onClick={() => setTheme(t => t === 'light'\
  \ ? 'dark' : 'light')}>{theme}</button>;\n    }\n    ```\n\n    ### Solution 2:\
  \ Use useReducer with Context\n\n    ```jsx\n    // Combine useReducer + Context\
  \ for complex state\n    const TodoContext = React.createContext();\n    const TodoDispatchContext\
  \ = React.createContext();\n\n    function todoReducer(state, action) {\n      switch\
  \ (action.type) {\n        case 'ADD_TODO':\n          return [...state, { id: Date.now(),\
  \ text: action.text, completed: false }];\n        case 'TOGGLE_TODO':\n       \
  \   return state.map(todo =>\n            todo.id === action.id ? { ...todo, completed:\
  \ !todo.completed } : todo\n          );\n        case 'DELETE_TODO':\n        \
  \  return state.filter(todo => todo.id !== action.id);\n        default:\n     \
  \     throw new Error(\\`Unknown action: \\${action.type}\\`);\n      }\n    }\n\
  \n    function TodoProvider({ children }) {\n      const [todos, dispatch] = useReducer(todoReducer,\
  \ []);\n\n      return (\n        <TodoContext.Provider value={todos}>\n       \
  \   <TodoDispatchContext.Provider value={dispatch}>\n            {children}\n  \
  \        </TodoDispatchContext.Provider>\n        </TodoContext.Provider>\n    \
  \  );\n    }\n\n    // Separate hooks for state and dispatch\n    function useTodos()\
  \ {\n      const context = useContext(TodoContext);\n      if (context === undefined)\
  \ {\n        throw new Error('useTodos must be used within TodoProvider');\n   \
  \   }\n      return context;\n    }\n\n    function useTodoDispatch() {\n      const\
  \ context = useContext(TodoDispatchContext);\n      if (context === undefined) {\n\
  \        throw new Error('useTodoDispatch must be used within TodoProvider');\n\
  \      }\n      return context;\n    }\n\n    // Components can subscribe to state\
  \ or dispatch separately\n    function TodoList() {\n      const todos = useTodos();\
  \ // Re-renders when todos change\n      return (\n        <ul>\n          {todos.map(todo\
  \ => (\n            <TodoItem key={todo.id} todo={todo} />\n          ))}\n    \
  \    </ul>\n      );\n    }\n\n    function TodoItem({ todo }) {\n      const dispatch\
  \ = useTodoDispatch(); // Never re-renders from context changes!\n\n      return\
  \ (\n        <li>\n          <input\n            type=\"checkbox\"\n           \
  \ checked={todo.completed}\n            onChange={() => dispatch({ type: 'TOGGLE_TODO',\
  \ id: todo.id })}\n          />\n          <span>{todo.text}</span>\n          <button\
  \ onClick={() => dispatch({ type: 'DELETE_TODO', id: todo.id })}>\n            Delete\n\
  \          </button>\n        </li>\n      );\n    }\n    ```\n\n    ## Real-World\
  \ Example: Form Management Hook\n\n    ```jsx\n    // hooks/useForm.js\n    import\
  \ { useState, useCallback } from 'react';\n\n    function useForm(initialValues\
  \ = {}, onSubmit) {\n      const [values, setValues] = useState(initialValues);\n\
  \      const [errors, setErrors] = useState({});\n      const [touched, setTouched]\
  \ = useState({});\n      const [isSubmitting, setIsSubmitting] = useState(false);\n\
  \n      const handleChange = useCallback((e) => {\n        const { name, value,\
  \ type, checked } = e.target;\n        setValues(prev => ({\n          ...prev,\n\
  \          [name]: type === 'checkbox' ? checked : value\n        }));\n      },\
  \ []);\n\n      const handleBlur = useCallback((e) => {\n        const { name }\
  \ = e.target;\n        setTouched(prev => ({ ...prev, [name]: true }));\n      },\
  \ []);\n\n      const validate = useCallback((values) => {\n        const errors\
  \ = {};\n        // Add validation logic here\n        if (!values.email) {\n  \
  \        errors.email = 'Email is required';\n        } else if (!/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\\
  \\.[A-Z]{2,}$/i.test(values.email)) {\n          errors.email = 'Invalid email address';\n\
  \        }\n        return errors;\n      }, []);\n\n      const handleSubmit =\
  \ useCallback(async (e) => {\n        e.preventDefault();\n\n        const validationErrors\
  \ = validate(values);\n        setErrors(validationErrors);\n\n        if (Object.keys(validationErrors).length\
  \ === 0) {\n          setIsSubmitting(true);\n          try {\n            await\
  \ onSubmit(values);\n          } catch (error) {\n            setErrors({ submit:\
  \ error.message });\n          } finally {\n            setIsSubmitting(false);\n\
  \          }\n        }\n      }, [values, validate, onSubmit]);\n\n      const\
  \ reset = useCallback(() => {\n        setValues(initialValues);\n        setErrors({});\n\
  \        setTouched({});\n        setIsSubmitting(false);\n      }, [initialValues]);\n\
  \n      return {\n        values,\n        errors,\n        touched,\n        isSubmitting,\n\
  \        handleChange,\n        handleBlur,\n        handleSubmit,\n        reset\n\
  \      };\n    }\n\n    // Usage\n    function SignupForm() {\n      const { values,\
  \ errors, touched, isSubmitting, handleChange, handleBlur, handleSubmit } =\n  \
  \      useForm(\n          { email: '', password: '', agreeToTerms: false },\n \
  \         async (values) => {\n            const response = await fetch('/api/signup',\
  \ {\n              method: 'POST',\n              headers: { 'Content-Type': 'application/json'\
  \ },\n              body: JSON.stringify(values)\n            });\n            if\
  \ (!response.ok) throw new Error('Signup failed');\n          }\n        );\n\n\
  \      return (\n        <form onSubmit={handleSubmit}>\n          <div>\n     \
  \       <input\n              name=\"email\"\n              type=\"email\"\n   \
  \           value={values.email}\n              onChange={handleChange}\n      \
  \        onBlur={handleBlur}\n              placeholder=\"Email\"\n            />\n\
  \            {touched.email && errors.email && <span className=\"error\">{errors.email}</span>}\n\
  \          </div>\n\n          <div>\n            <input\n              name=\"\
  password\"\n              type=\"password\"\n              value={values.password}\n\
  \              onChange={handleChange}\n              onBlur={handleBlur}\n    \
  \          placeholder=\"Password\"\n            />\n            {touched.password\
  \ && errors.password && <span className=\"error\">{errors.password}</span>}\n  \
  \        </div>\n\n          <button type=\"submit\" disabled={isSubmitting}>\n\
  \            {isSubmitting ? 'Signing up...' : 'Sign Up'}\n          </button>\n\
  \        </form>\n      );\n    }\n    ```\n\n    ## Best Practices\n\n    1. **Name\
  \ custom hooks with \"use\" prefix** - Required by React linting rules\n    2. **Keep\
  \ hooks focused** - One responsibility per hook\n    3. **Return arrays for simple\
  \ hooks** - Like useState: `[value, setValue]`\n    4. **Return objects for complex\
  \ hooks** - Named properties are clearer\n    5. **Memoize context values** - Prevent\
  \ unnecessary re-renders\n    6. **Split large contexts** - Separate concerns for\
  \ better performance\n    7. **Always cleanup effects** - Prevent memory leaks and\
  \ stale updates\n\n    **Next**: We'll explore performance optimization techniques\
  \ in React."
exercises:
- type: mcq
  sequence_order: 1
  question: What is the primary benefit of creating custom hooks in React?
  options:
  - Custom hooks make components render faster
  - Custom hooks extract and reuse stateful logic across multiple components
  - Custom hooks eliminate the need for props
  - Custom hooks automatically optimize performance
  correct_answer: Custom hooks extract and reuse stateful logic across multiple components
  explanation: 'Custom hooks solve the problem of code duplication by extracting stateful
    logic into reusable functions. Before custom hooks, sharing stateful logic required
    render props or higher-order components (HOCs), which led to wrapper hell and
    complicated component trees. Custom hooks enable: (1) Logic reuse - write once,
    use everywhere (e.g., useFetch hook for all API calls), (2) Separation of concerns
    - extract complex logic from components (data fetching, subscriptions, timers),
    (3) Composition - combine multiple hooks to build complex functionality, (4) Testability
    - test hooks independently from components. Example: Instead of duplicating useState
    + useEffect for data fetching in every component, create useFetch hook that encapsulates
    loading state, error handling, and data fetching. The hook must follow Rules of
    Hooks: (1) Name starts with "use", (2) Call only at top level, (3) Call only from
    React functions. Custom hooks can use other hooks (useState, useEffect, useContext,
    other custom hooks).'
  require_pass: true
- type: mcq
  sequence_order: 2
  question: Why is it important to include a cleanup function in custom hooks that
    use useEffect?
  options:
  - Cleanup functions make the hook run faster
  - Cleanup functions prevent memory leaks and stale state updates after component
    unmounts
  - React requires cleanup functions for all custom hooks
  - Cleanup functions automatically cancel network requests
  correct_answer: Cleanup functions prevent memory leaks and stale state updates after
    component unmounts
  explanation: 'Cleanup functions in useEffect are critical to prevent memory leaks
    and race conditions. Without cleanup: (1) Memory leaks - subscriptions, timers,
    event listeners continue running after component unmounts, consuming memory, (2)
    Stale state updates - async operations (fetch, setTimeout) try to update state
    on unmounted components, causing React warnings and bugs, (3) Race conditions
    - multiple fetches complete in wrong order, displaying stale data. Example: useFetch
    hook without cleanup: if component unmounts before fetch completes, setData()
    runs on unmounted component. Solution: useEffect cleanup function with cancelled
    flag: return () => { cancelled = true; }; if (!cancelled) setData(json);. Common
    cleanup scenarios: (1) Clear timers: return () => clearTimeout(timer), (2) Unsubscribe:
    return () => subscription.unsubscribe(), (3) Remove listeners: return () => element.removeEventListener(),
    (4) Cancel requests: return () => abortController.abort(). The cleanup runs before
    effect re-runs AND when component unmounts. Always cleanup side effects to avoid
    bugs in production.'
  require_pass: true
- type: mcq
  sequence_order: 3
  question: When should you split a single React Context into multiple separate contexts?
  options:
  - Always split contexts to follow best practices
  - When different parts of the context change at different frequencies and you want
    to prevent unnecessary re-renders
  - Never split contexts, as it makes the code more complex
  - Only when you have more than 5 values in the context
  correct_answer: When different parts of the context change at different frequencies
    and you want to prevent unnecessary re-renders
  explanation: 'Context splitting is a performance optimization technique to prevent
    unnecessary re-renders. Problem: When context value changes, ALL consumers re-render,
    even if they only use a small part of the value. Example: Single context with
    {user, theme, notifications} causes ThemeToggle component to re-render when user
    changes, even though ThemeToggle only uses theme. Solution: Split into UserContext,
    ThemeContext, NotificationContext. Now components only subscribe to what they
    need and re-render only when that specific value changes. When to split: (1) Values
    change at different rates (user rarely changes, notifications frequently), (2)
    Different components use different subsets of state, (3) Performance profiling
    shows excessive re-renders. Additional optimization: useMemo for context values
    to prevent new object references: const userValue = useMemo(() => ({ user, setUser
    }), [user]). Without memoization, {user, setUser} creates new object each render,
    triggering all consumers. Alternative pattern: Separate state and dispatch contexts
    (like React Query does) - components that only call actions don''t re-render when
    state changes.'
  require_pass: true
