slug: lesson-4
title: Lesson 4
difficulty: easy
sequence_order: 4
estimated_minutes: 2
key_concepts: []
prerequisites: []
content_md: "# Microlesson \U0001F680\n\n# TypeScript Fundamentals and Type System\n\
  \n    **TypeScript** is JavaScript with syntax for types. It's a strongly typed\
  \ superset of JavaScript that compiles to plain JavaScript.\n\n    ## Why TypeScript?\n\
  \n    ### JavaScript Pain Points\n\n    ```javascript\n    // JavaScript - No type\
  \ safety\n    function add(a, b) {\n      return a + b;\n    }\n\n    add(5, 10);\
  \        // 15 ✓\n    add(\"5\", \"10\");    // \"510\" - String concatenation!\n\
  \    add(5, \"10\");      // \"510\" - Type coercion!\n    add({}, []);       //\
  \ \"[object Object]\" - WTF?\n    ```\n\n    ### TypeScript Solution\n\n    ```typescript\n\
  \    // TypeScript - Type safety\n    function add(a: number, b: number): number\
  \ {\n      return a + b;\n    }\n\n    add(5, 10);        // 15 ✓\n    add(\"5\"\
  , \"10\");    // ❌ Error: Argument of type 'string' not assignable to 'number'\n\
  \    add(5, \"10\");      // ❌ Error: Argument of type 'string' not assignable to\
  \ 'number'\n    ```\n\n    **Benefits:**\n    - Catch errors at compile time (not\
  \ runtime!)\n    - Better IDE support (autocomplete, refactoring)\n    - Self-documenting\
  \ code\n    - Easier refactoring and maintenance\n\n    ## Basic Types\n\n    ###\
  \ Primitive Types\n\n    ```typescript\n    // String\n    let name: string = \"\
  Alice\";\n    let greeting: string = `Hello, ${name}`;\n\n    // Number (int, float,\
  \ hex, binary all are number)\n    let age: number = 30;\n    let price: number\
  \ = 99.99;\n    let hex: number = 0xf00d;\n    let binary: number = 0b1010;\n\n\
  \    // Boolean\n    let isDone: boolean = false;\n    let isActive: boolean = true;\n\
  \n    // Null and Undefined\n    let nothing: null = null;\n    let notDefined:\
  \ undefined = undefined;\n\n    // Any (avoid when possible!)\n    let anything:\
  \ any = \"string\";\n    anything = 42;        // OK\n    anything = true;     \
  \ // OK\n    anything = {};        // OK - defeats purpose of TypeScript!\n    ```\n\
  \n    ### Arrays\n\n    ```typescript\n    // Array of numbers\n    let numbers:\
  \ number[] = [1, 2, 3, 4, 5];\n    let nums: Array<number> = [1, 2, 3];  // Alternative\
  \ syntax\n\n    // Array of strings\n    let names: string[] = [\"Alice\", \"Bob\"\
  , \"Charlie\"];\n\n    // Mixed array (avoid!)\n    let mixed: any[] = [1, \"two\"\
  , true];\n\n    // Array methods are type-safe\n    numbers.push(6);        // OK\n\
  \    numbers.push(\"7\");      // ❌ Error: Argument of type 'string' not assignable\n\
  \n    // Array operations\n    const doubled = numbers.map(n => n * 2);  // Type:\
  \ number[]\n    const evens = numbers.filter(n => n % 2 === 0);  // Type: number[]\n\
  \    ```\n\n    ### Tuples\n\n    **Fixed-length arrays with specific types**\n\n\
  \    ```typescript\n    // Tuple: [string, number]\n    let person: [string, number]\
  \ = [\"Alice\", 30];\n\n    console.log(person[0].toUpperCase());  // \"ALICE\"\
  \ - knows it's a string\n    console.log(person[1].toFixed(2));     // \"30.00\"\
  \ - knows it's a number\n\n    // Error: Wrong types\n    person = [30, \"Alice\"\
  ];  // ❌ Error: Type 'number' not assignable to 'string'\n\n    // Error: Wrong\
  \ length\n    person = [\"Alice\", 30, true];  // ❌ Error: Type '[string, number,\
  \ boolean]' not assignable\n\n    // Common use case: React hooks\n    const [count,\
  \ setCount]: [number, (n: number) => void] = useState(0);\n\n    // Multiple return\
  \ values\n    function getCoordinates(): [number, number] {\n      return [10, 20];\n\
  \    }\n\n    const [x, y] = getCoordinates();  // x: number, y: number\n    ```\n\
  \n    ### Enums\n\n    **Named constants**\n\n    ```typescript\n    // Numeric\
  \ enum (default)\n    enum Direction {\n      Up,      // 0\n      Down,    // 1\n\
  \      Left,    // 2\n      Right    // 3\n    }\n\n    let dir: Direction = Direction.Up;\n\
  \    console.log(dir);  // 0\n\n    // String enum (recommended)\n    enum Status\
  \ {\n      Pending = \"PENDING\",\n      Approved = \"APPROVED\",\n      Rejected\
  \ = \"REJECTED\"\n    }\n\n    function updateStatus(status: Status) {\n      console.log(`Status\
  \ updated to: ${status}`);\n    }\n\n    updateStatus(Status.Approved);  // \"Status\
  \ updated to: APPROVED\"\n    updateStatus(\"APPROVED\");       // ❌ Error: Argument\
  \ type '\"APPROVED\"' not assignable\n\n    // Enum with custom values\n    enum\
  \ HttpStatus {\n      OK = 200,\n      BadRequest = 400,\n      Unauthorized = 401,\n\
  \      NotFound = 404,\n      ServerError = 500\n    }\n\n    // Const enum (better\
  \ performance - inlined at compile time)\n    const enum Color {\n      Red = \"\
  #FF0000\",\n      Green = \"#00FF00\",\n      Blue = \"#0000FF\"\n    }\n    ```\n\
  \n    ## Type Inference\n\n    **TypeScript infers types automatically**\n\n   \
  \ ```typescript\n    // Explicit type annotation\n    let count: number = 10;\n\n\
  \    // Type inference (preferred when obvious)\n    let inferredCount = 10;  //\
  \ Type: number (inferred)\n\n    // Function return type inference\n    function\
  \ add(a: number, b: number) {\n      return a + b;  // Return type inferred as number\n\
  \    }\n\n    // Array type inference\n    let numbers = [1, 2, 3];  // Type: number[]\n\
  \    let mixed = [1, \"two\"];   // Type: (string | number)[]\n\n    // Object type\
  \ inference\n    let user = {\n      name: \"Alice\",\n      age: 30\n    };\n \
  \   // Type: { name: string; age: number; }\n\n    user.name = \"Bob\";     // OK\n\
  \    user.age = \"thirty\";   // ❌ Error: Type 'string' not assignable to 'number'\n\
  \    ```\n\n    **When to use explicit types:**\n    - Function parameters (required)\n\
  \    - Public API boundaries\n    - When inference is unclear\n    - When you want\
  \ to enforce a specific type\n\n    ## Type Annotations\n\n    ### Function Types\n\
  \n    ```typescript\n    // Function with type annotations\n    function greet(name:\
  \ string): string {\n      return `Hello, ${name}!`;\n    }\n\n    // Arrow function\n\
  \    const greet2 = (name: string): string => `Hello, ${name}!`;\n\n    // Optional\
  \ parameters\n    function greet3(name: string, greeting?: string): string {\n \
  \     return `${greeting || \"Hello\"}, ${name}!`;\n    }\n\n    greet3(\"Alice\"\
  );           // \"Hello, Alice!\"\n    greet3(\"Alice\", \"Hi\");     // \"Hi, Alice!\"\
  \n\n    // Default parameters\n    function greet4(name: string, greeting: string\
  \ = \"Hello\"): string {\n      return `${greeting}, ${name}!`;\n    }\n\n    //\
  \ Rest parameters\n    function sum(...numbers: number[]): number {\n      return\
  \ numbers.reduce((total, n) => total + n, 0);\n    }\n\n    sum(1, 2, 3, 4, 5);\
  \  // 15\n\n    // Void return type (no return value)\n    function log(message:\
  \ string): void {\n      console.log(message);\n    }\n\n    // Never return type\
  \ (function never returns)\n    function throwError(message: string): never {\n\
  \      throw new Error(message);\n    }\n\n    function infiniteLoop(): never {\n\
  \      while (true) {}\n    }\n    ```\n\n    ### Object Types\n\n    ```typescript\n\
  \    // Object type annotation\n    let user: { name: string; age: number; email?:\
  \ string } = {\n      name: \"Alice\",\n      age: 30\n    };\n\n    // Optional\
  \ property (email?)\n    user.email = \"alice@example.com\";  // OK\n    delete\
  \ user.email;                 // OK\n\n    // Readonly properties\n    let config:\
  \ { readonly apiKey: string; timeout: number } = {\n      apiKey: \"secret123\"\
  ,\n      timeout: 5000\n    };\n\n    config.timeout = 10000;  // OK\n    config.apiKey\
  \ = \"new\";   // ❌ Error: Cannot assign to 'apiKey' (readonly)\n\n    // Index\
  \ signature (dynamic keys)\n    let scores: { [key: string]: number } = {\n    \
  \  math: 95,\n      english: 87,\n      science: 92\n    };\n\n    scores.history\
  \ = 88;  // OK - any string key allowed\n    scores.math = \"A\";    // ❌ Error:\
  \ Type 'string' not assignable to 'number'\n    ```\n\n    ## Interfaces vs Types\n\
  \n    ### Interfaces\n\n    ```typescript\n    // Interface definition\n    interface\
  \ User {\n      id: number;\n      name: string;\n      email: string;\n      age?:\
  \ number;  // Optional\n    }\n\n    const user1: User = {\n      id: 1,\n     \
  \ name: \"Alice\",\n      email: \"alice@example.com\"\n    };\n\n    // Interface\
  \ with methods\n    interface Product {\n      id: number;\n      name: string;\n\
  \      price: number;\n      calculateDiscount(percentage: number): number;\n  \
  \  }\n\n    const product: Product = {\n      id: 1,\n      name: \"Laptop\",\n\
  \      price: 1000,\n      calculateDiscount(percentage: number): number {\n   \
  \     return this.price * (percentage / 100);\n      }\n    };\n\n    // Extending\
  \ interfaces\n    interface Employee {\n      id: number;\n      name: string;\n\
  \    }\n\n    interface Manager extends Employee {\n      department: string;\n\
  \      subordinates: Employee[];\n    }\n\n    const manager: Manager = {\n    \
  \  id: 1,\n      name: \"Bob\",\n      department: \"Engineering\",\n      subordinates:\
  \ []\n    };\n\n    // Interface merging (declaration merging)\n    interface Window\
  \ {\n      customProperty: string;\n    }\n\n    interface Window {\n      anotherProperty:\
  \ number;\n    }\n\n    // Now Window has both properties\n    window.customProperty\
  \ = \"value\";\n    window.anotherProperty = 42;\n    ```\n\n    ### Type Aliases\n\
  \n    ```typescript\n    // Type alias\n    type User = {\n      id: number;\n \
  \     name: string;\n      email: string;\n      age?: number;\n    };\n\n    //\
  \ Union types (types only!)\n    type ID = string | number;\n\n    let userId: ID\
  \ = 123;     // OK\n    userId = \"abc-123\";       // OK\n\n    // Intersection\
  \ types\n    type Person = {\n      name: string;\n      age: number;\n    };\n\n\
  \    type Employee = {\n      employeeId: number;\n      department: string;\n \
  \   };\n\n    type EmployeePerson = Person & Employee;\n\n    const emp: EmployeePerson\
  \ = {\n      name: \"Alice\",\n      age: 30,\n      employeeId: 123,\n      department:\
  \ \"Engineering\"\n    };\n\n    // Literal types\n    type Status = \"pending\"\
  \ | \"approved\" | \"rejected\";\n    type Direction = \"north\" | \"south\" | \"\
  east\" | \"west\";\n\n    let status: Status = \"pending\";    // OK\n    status\
  \ = \"approved\";               // OK\n    status = \"cancelled\";             \
  \ // ❌ Error: Type '\"cancelled\"' not assignable\n\n    // Function type\n    type\
  \ MathOperation = (a: number, b: number) => number;\n\n    const add: MathOperation\
  \ = (a, b) => a + b;\n    const subtract: MathOperation = (a, b) => a - b;\n   \
  \ ```\n\n    ## Interfaces vs Types: When to Use What?\n\n    ### Use Interfaces\
  \ When:\n\n    ```typescript\n    // 1. Defining object shapes\n    interface User\
  \ {\n      id: number;\n      name: string;\n    }\n\n    // 2. Need to extend/inherit\n\
  \    interface Admin extends User {\n      permissions: string[];\n    }\n\n   \
  \ // 3. Working with classes\n    class UserAccount implements User {\n      constructor(public\
  \ id: number, public name: string) {}\n    }\n\n    // 4. Want declaration merging\n\
  \    interface Config {\n      apiUrl: string;\n    }\n\n    interface Config {\n\
  \      timeout: number;\n    }\n    ```\n\n    ### Use Types When:\n\n    ```typescript\n\
  \    // 1. Union types\n    type Result = Success | Error;\n\n    // 2. Intersection\
  \ types\n    type Combined = TypeA & TypeB;\n\n    // 3. Primitive aliases\n   \
  \ type ID = string | number;\n\n    // 4. Tuple types\n    type Point = [number,\
  \ number];\n\n    // 5. Function types\n    type Callback = (data: string) => void;\n\
  \n    // 6. Mapped types\n    type Readonly<T> = {\n      readonly [P in keyof T]:\
  \ T[P];\n    };\n    ```\n\n    **General rule:** Use `interface` for object shapes\
  \ and public APIs. Use `type` for unions, intersections, and utility types.\n\n\
  \    ## Real-World Example: User Management\n\n    ```typescript\n    // Types and\
  \ interfaces\n    type UserRole = \"admin\" | \"user\" | \"guest\";\n\n    interface\
  \ BaseUser {\n      id: string;\n      email: string;\n      createdAt: Date;\n\
  \    }\n\n    interface User extends BaseUser {\n      name: string;\n      role:\
  \ UserRole;\n      isActive: boolean;\n    }\n\n    interface UserWithProfile extends\
  \ User {\n      profile: {\n        bio?: string;\n        avatar?: string;\n  \
  \      location?: string;\n      };\n    }\n\n    // Function implementations\n\
  \    function createUser(\n      email: string,\n      name: string,\n      role:\
  \ UserRole = \"user\"\n    ): User {\n      return {\n        id: generateId(),\n\
  \        email,\n        name,\n        role,\n        isActive: true,\n       \
  \ createdAt: new Date()\n      };\n    }\n\n    function updateUser(\n      userId:\
  \ string,\n      updates: Partial<User>\n    ): User | null {\n      // Implementation\n\
  \      const user = findUserById(userId);\n      if (!user) return null;\n\n   \
  \   return { ...user, ...updates };\n    }\n\n    function findUsersByRole(role:\
  \ UserRole): User[] {\n      // Type-safe database query\n      return users.filter(u\
  \ => u.role === role);\n    }\n\n    // Usage\n    const newUser = createUser(\"\
  alice@example.com\", \"Alice\", \"admin\");\n    const updated = updateUser(newUser.id,\
  \ { isActive: false });\n    const admins = findUsersByRole(\"admin\");\n    ```\n\
  \n    ## Type Assertions\n\n    ```typescript\n    // Type assertion (when you know\
  \ more than TypeScript)\n    let someValue: any = \"this is a string\";\n\n    //\
  \ Angle-bracket syntax\n    let strLength1: number = (<string>someValue).length;\n\
  \n    // As syntax (preferred, required in JSX)\n    let strLength2: number = (someValue\
  \ as string).length;\n\n    // Common use case: DOM elements\n    const input =\
  \ document.getElementById(\"email\") as HTMLInputElement;\n    input.value = \"\
  alice@example.com\";  // OK - knows it's an input\n\n    // Non-null assertion (!)\n\
  \    function processUser(user: User | null) {\n      // If you're SURE it's not\
  \ null\n      console.log(user!.name);  // Tell TS: trust me, it's not null\n  \
  \  }\n    ```\n\n    ## Interview Tips\n\n    1. **Always prefer type inference\
  \ when obvious**\n    2. **Use strict mode** (`strict: true` in tsconfig.json)\n\
  \    3. **Avoid `any`** - use `unknown` if type is truly unknown\n    4. **Interfaces\
  \ for objects, types for everything else**\n    5. **Enums vs union types**: String\
  \ unions are often simpler\n    6. **Optional chaining**: `user?.profile?.bio`\n\
  \    7. **Nullish coalescing**: `value ?? defaultValue`\n\n    **Next**: We'll explore\
  \ generics and advanced type features!"
exercises: []
exercises:
  - type: mcq
    sequence_order: 1
    question: "What are generics in TypeScript and why are they useful?"
    options:
      - "A way to make code run faster"
      - "A way to write reusable code that works with multiple types while maintaining type safety"
      - "A type of function"
      - "A database feature"
    correct_answer: "A way to write reusable code that works with multiple types while maintaining type safety"
    explanation: "Generics allow you to write flexible, reusable code that works with multiple types while preserving type information:\n\n```typescript\n// Without generics - must duplicate or lose types\nfunction getFirst_String(arr: string[]): string {\n  return arr[0];\n}\nfunction getFirst_Number(arr: number[]): number {\n  return arr[0];\n}\n\n// With generics - one function, type-safe\nfunction getFirst<T>(arr: T[]): T {\n  return arr[0];\n}\n\nconst first = getFirst([1, 2, 3]);      // TypeScript infers T = number\nconst name = getFirst(['a', 'b', 'c']); // TypeScript infers T = string\n```\n\nBenefits: code reusability, type safety, better IDE support. Common uses: arrays, promises, React components, utility functions. Generics are fundamental to TypeScript's type system and enable powerful, flexible APIs while maintaining strict type checking."
    require_pass: true
  - type: mcq
    sequence_order: 2
    question: "What does this generic constraint mean: `<T extends string>`?"
    options:
      - "T must be exactly string"
      - "T can be string or any subtype of string"
      - "T cannot be string"
      - "It's invalid syntax"
    correct_answer: "T can be string or any subtype of string"
    explanation: "Generic constraints limit what types can be used as type parameters. `<T extends string>` means T must be string or a more specific type:\n\n```typescript\n// Without constraint - T can be anything\nfunction log<T>(value: T) {\n  console.log(value.toUpperCase()); // Error! T might not have toUpperCase\n}\n\n// With constraint - T must have string methods\nfunction logUpper<T extends string>(value: T) {\n  console.log(value.toUpperCase()); // OK, T is definitely string-like\n}\n\n// Common pattern: extends with interface\ninterface HasLength {\n  length: number;\n}\nfunction printLength<T extends HasLength>(item: T) {\n  console.log(item.length); // OK, T has length property\n}\n\nprintLength('hello');     // OK, string has length\nprintLength([1, 2, 3]);   // OK, array has length\nprintLength(123);         // Error! number doesn't have length\n```\n\nConstraints ensure generic types have required properties/methods."
    require_pass: true
