slug: lesson-6
title: Lesson 6
difficulty: easy
sequence_order: 6
estimated_minutes: 2
key_concepts: []
prerequisites: []
content_md: "# Microlesson \U0001F680\n\n# TypeScript in Practice\n\n    Learn how\
  \ to use TypeScript in real-world projects with React, Node.js, and proper configuration.\n\
  \n    ## Project Configuration\n\n    ### tsconfig.json\n\n    **The TypeScript\
  \ compiler configuration file**\n\n    ```json\n    {\n      \"compilerOptions\"\
  : {\n        // Language and Environment\n        \"target\": \"ES2020\",      \
  \              // Output JavaScript version\n        \"lib\": [\"ES2020\", \"DOM\"\
  ],              // Available APIs\n        \"jsx\": \"react-jsx\",             \
  \       // JSX support for React\n\n        // Modules\n        \"module\": \"ESNext\"\
  ,                    // Module system\n        \"moduleResolution\": \"node\", \
  \           // How to resolve modules\n        \"resolveJsonModule\": true,    \
  \         // Import JSON files\n        \"baseUrl\": \".\",                    \
  \    // Base directory for imports\n        \"paths\": {                       \
  \      // Path aliases\n          \"@components/*\": [\"src/components/*\"],\n \
  \         \"@utils/*\": [\"src/utils/*\"]\n        },\n\n        // Emit\n     \
  \   \"outDir\": \"./dist\",                    // Output directory\n        \"declaration\"\
  : true,                   // Generate .d.ts files\n        \"declarationMap\": true,\
  \                // Sourcemaps for .d.ts\n        \"sourceMap\": true,         \
  \            // Generate .map files\n        \"removeComments\": true,         \
  \       // Remove comments in output\n\n        // Type Checking (STRICT MODE -\
  \ RECOMMENDED!)\n        \"strict\": true,                        // Enable all\
  \ strict checks\n        \"noImplicitAny\": true,                 // Error on implicit\
  \ 'any'\n        \"strictNullChecks\": true,              // null/undefined are\
  \ not valid values\n        \"strictFunctionTypes\": true,           // Strict function\
  \ type checking\n        \"strictBindCallApply\": true,           // Strict bind/call/apply\n\
  \        \"noImplicitThis\": true,                // Error on implicit 'this'\n\
  \        \"alwaysStrict\": true,                  // Use strict mode\n\n       \
  \ // Additional Checks\n        \"noUnusedLocals\": true,                // Error\
  \ on unused variables\n        \"noUnusedParameters\": true,            // Error\
  \ on unused parameters\n        \"noImplicitReturns\": true,             // Error\
  \ if not all paths return\n        \"noFallthroughCasesInSwitch\": true,    // Error\
  \ on switch fallthrough\n\n        // Interop\n        \"esModuleInterop\": true,\
  \               // CommonJS/ES6 interop\n        \"allowSyntheticDefaultImports\"\
  : true,  // Allow default imports\n        \"forceConsistentCasingInFileNames\"\
  : true,  // Consistent file casing\n        \"skipLibCheck\": true             \
  \      // Skip type checking of .d.ts files\n      },\n      \"include\": [\n  \
  \      \"src/**/*\"                             // Files to compile\n      ],\n\
  \      \"exclude\": [\n        \"node_modules\",                        // Ignore\
  \ node_modules\n        \"dist\",                                // Ignore output\n\
  \        \"**/*.spec.ts\"                         // Ignore test files\n      ]\n\
  \    }\n    ```\n\n    ### Project Setup\n\n    ```bash\n    # Initialize TypeScript\
  \ project\n    npm init -y\n    npm install --save-dev typescript @types/node\n\n\
  \    # Generate tsconfig.json\n    npx tsc --init\n\n    # Install type definitions\n\
  \    npm install --save-dev @types/express @types/react @types/jest\n\n    # Compile\
  \ TypeScript\n    npx tsc\n\n    # Watch mode\n    npx tsc --watch\n    ```\n\n\
  \    ## TypeScript with React\n\n    ### Component Types\n\n    ```typescript\n\
  \    import React, { useState, useEffect, useRef } from 'react';\n\n    // Props\
  \ interface\n    interface UserCardProps {\n      name: string;\n      age: number;\n\
  \      email: string;\n      onEdit?: (id: string) => void;  // Optional callback\n\
  \      children?: React.ReactNode;     // Children prop\n    }\n\n    // Function\
  \ component (preferred)\n    const UserCard: React.FC<UserCardProps> = ({\n    \
  \  name,\n      age,\n      email,\n      onEdit,\n      children\n    }) => {\n\
  \      const [isEditing, setIsEditing] = useState<boolean>(false);\n\n      return\
  \ (\n        <div className=\"user-card\">\n          <h2>{name}</h2>\n        \
  \  <p>Age: {age}</p>\n          <p>Email: {email}</p>\n          {onEdit && (\n\
  \            <button onClick={() => onEdit(\"123\")}>Edit</button>\n          )}\n\
  \          {children}\n        </div>\n      );\n    };\n\n    // Alternative: Function\
  \ without React.FC (more common now)\n    function UserCard2(props: UserCardProps)\
  \ {\n      return <div>{props.name}</div>;\n    }\n\n    // Usage\n    <UserCard\n\
  \      name=\"Alice\"\n      age={30}\n      email=\"alice@example.com\"\n     \
  \ onEdit={(id) => console.log(id)}\n    >\n      <p>Additional info</p>\n    </UserCard>\n\
  \    ```\n\n    ### Hooks with TypeScript\n\n    ```typescript\n    import React,\
  \ { useState, useEffect, useRef, useContext } from 'react';\n\n    // useState\n\
  \    function Counter() {\n      const [count, setCount] = useState<number>(0);\n\
  \      const [user, setUser] = useState<User | null>(null);\n\n      return (\n\
  \        <button onClick={() => setCount(count + 1)}>\n          Count: {count}\n\
  \        </button>\n      );\n    }\n\n    // useEffect\n    function DataFetcher()\
  \ {\n      const [data, setData] = useState<User[]>([]);\n      const [loading,\
  \ setLoading] = useState<boolean>(true);\n      const [error, setError] = useState<Error\
  \ | null>(null);\n\n      useEffect(() => {\n        async function fetchData()\
  \ {\n          try {\n            const response = await fetch('/api/users');\n\
  \            const users: User[] = await response.json();\n            setData(users);\n\
  \          } catch (err) {\n            setError(err as Error);\n          } finally\
  \ {\n            setLoading(false);\n          }\n        }\n\n        fetchData();\n\
  \      }, []);  // Dependency array\n\n      if (loading) return <div>Loading...</div>;\n\
  \      if (error) return <div>Error: {error.message}</div>;\n\n      return (\n\
  \        <ul>\n          {data.map(user => (\n            <li key={user.id}>{user.name}</li>\n\
  \          ))}\n        </ul>\n      );\n    }\n\n    // useRef\n    function TextInput()\
  \ {\n      const inputRef = useRef<HTMLInputElement>(null);\n\n      const focusInput\
  \ = () => {\n        inputRef.current?.focus();  // Optional chaining\n      };\n\
  \n      return (\n        <>\n          <input ref={inputRef} type=\"text\" />\n\
  \          <button onClick={focusInput}>Focus Input</button>\n        </>\n    \
  \  );\n    }\n\n    // useContext\n    interface ThemeContextType {\n      theme:\
  \ 'light' | 'dark';\n      toggleTheme: () => void;\n    }\n\n    const ThemeContext\
  \ = React.createContext<ThemeContextType | undefined>(\n      undefined\n    );\n\
  \n    function useTheme() {\n      const context = useContext(ThemeContext);\n \
  \     if (!context) {\n        throw new Error('useTheme must be used within ThemeProvider');\n\
  \      }\n      return context;\n    }\n\n    // Custom hook\n    function useLocalStorage<T>(key:\
  \ string, initialValue: T) {\n      const [value, setValue] = useState<T>(() =>\
  \ {\n        const item = window.localStorage.getItem(key);\n        return item\
  \ ? JSON.parse(item) : initialValue;\n      });\n\n      useEffect(() => {\n   \
  \     window.localStorage.setItem(key, JSON.stringify(value));\n      }, [key, value]);\n\
  \n      return [value, setValue] as const;  // Tuple type\n    }\n\n    // Usage\n\
  \    function Settings() {\n      const [username, setUsername] = useLocalStorage<string>('username',\
  \ '');\n\n      return (\n        <input\n          value={username}\n         \
  \ onChange={(e) => setUsername(e.target.value)}\n        />\n      );\n    }\n \
  \   ```\n\n    ### Event Handling\n\n    ```typescript\n    import React from 'react';\n\
  \n    function Form() {\n      const handleSubmit = (e: React.FormEvent<HTMLFormElement>)\
  \ => {\n        e.preventDefault();\n        console.log('Form submitted');\n  \
  \    };\n\n      const handleChange = (e: React.ChangeEvent<HTMLInputElement>) =>\
  \ {\n        console.log(e.target.value);\n      };\n\n      const handleClick =\
  \ (e: React.MouseEvent<HTMLButtonElement>) => {\n        console.log('Button clicked');\n\
  \      };\n\n      const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>)\
  \ => {\n        if (e.key === 'Enter') {\n          console.log('Enter pressed');\n\
  \        }\n      };\n\n      return (\n        <form onSubmit={handleSubmit}>\n\
  \          <input\n            type=\"text\"\n            onChange={handleChange}\n\
  \            onKeyDown={handleKeyDown}\n          />\n          <button onClick={handleClick}>Submit</button>\n\
  \        </form>\n      );\n    }\n    ```\n\n    ## TypeScript with Node.js/Express\n\
  \n    ### Express Server\n\n    ```typescript\n    import express, { Request, Response,\
  \ NextFunction } from 'express';\n\n    const app = express();\n    app.use(express.json());\n\
  \n    // Type-safe request handlers\n    interface User {\n      id: number;\n \
  \     name: string;\n      email: string;\n    }\n\n    // GET endpoint\n    app.get('/api/users',\
  \ (req: Request, res: Response) => {\n      const users: User[] = [\n        { id:\
  \ 1, name: 'Alice', email: 'alice@example.com' },\n        { id: 2, name: 'Bob',\
  \ email: 'bob@example.com' }\n      ];\n      res.json(users);\n    });\n\n    //\
  \ POST endpoint with typed body\n    interface CreateUserBody {\n      name: string;\n\
  \      email: string;\n      password: string;\n    }\n\n    app.post('/api/users',\
  \ (req: Request<{}, {}, CreateUserBody>, res: Response) => {\n      const { name,\
  \ email, password } = req.body;\n\n      // Validation\n      if (!name || !email\
  \ || !password) {\n        return res.status(400).json({ error: 'Missing required\
  \ fields' });\n      }\n\n      const newUser: User = {\n        id: Date.now(),\n\
  \        name,\n        email\n      };\n\n      res.status(201).json(newUser);\n\
  \    });\n\n    // GET with params\n    app.get('/api/users/:id', (\n      req:\
  \ Request<{ id: string }>,\n      res: Response\n    ) => {\n      const userId\
  \ = parseInt(req.id);\n      // Find user logic\n      res.json({ id: userId });\n\
  \    });\n\n    // Middleware\n    const authMiddleware = (\n      req: Request,\n\
  \      res: Response,\n      next: NextFunction\n    ) => {\n      const token =\
  \ req.headers.authorization;\n\n      if (!token) {\n        return res.status(401).json({\
  \ error: 'No token provided' });\n      }\n\n      // Verify token logic\n     \
  \ next();\n    };\n\n    app.use('/api/protected', authMiddleware);\n\n    // Error\
  \ handling middleware\n    app.use((\n      err: Error,\n      req: Request,\n \
  \     res: Response,\n      next: NextFunction\n    ) => {\n      console.error(err.stack);\n\
  \      res.status(500).json({ error: 'Internal server error' });\n    });\n\n  \
  \  const PORT = process.env.PORT || 3000;\n    app.listen(PORT, () => {\n      console.log(`Server\
  \ running on port ${PORT}`);\n    });\n    ```\n\n    ### Async/Await with TypeScript\n\
  \n    ```typescript\n    // Database operations\n    interface DbUser {\n      id:\
  \ number;\n      name: string;\n      email: string;\n      createdAt: Date;\n \
  \   }\n\n    class UserService {\n      async findById(id: number): Promise<DbUser\
  \ | null> {\n        try {\n          // Simulated database query\n          const\
  \ user = await db.query<DbUser>(\n            'SELECT * FROM users WHERE id = $1',\n\
  \            [id]\n          );\n          return user || null;\n        } catch\
  \ (error) {\n          console.error('Database error:', error);\n          throw\
  \ new Error('Failed to fetch user');\n        }\n      }\n\n      async create(data:\
  \ Omit<DbUser, 'id' | 'createdAt'>): Promise<DbUser> {\n        const now = new\
  \ Date();\n        const user = await db.query<DbUser>(\n          'INSERT INTO\
  \ users (name, email, created_at) VALUES ($1, $2, $3) RETURNING *',\n          [data.name,\
  \ data.email, now]\n        );\n        return user;\n      }\n\n      async findAll():\
  \ Promise<DbUser[]> {\n        const users = await db.query<DbUser[]>('SELECT *\
  \ FROM users');\n        return users;\n      }\n    }\n    ```\n\n    ## Migration\
  \ Strategies\n\n    ### Gradual Migration from JavaScript\n\n    ```typescript\n\
  \    // Step 1: Rename .js to .ts (start with leaf files)\n    // user.js → user.ts\n\
  \n    // Step 2: Allow implicit any (temporarily)\n    // tsconfig.json: \"noImplicitAny\"\
  : false\n\n    // Step 3: Add basic types\n    // Before (JavaScript)\n    function\
  \ getUser(id) {\n      return users.find(u => u.id === id);\n    }\n\n    // After\
  \ (TypeScript - basic)\n    function getUser(id: number): User | undefined {\n \
  \     return users.find(u => u.id === id);\n    }\n\n    // Step 4: Add strict null\
  \ checks gradually\n    // tsconfig.json: \"strictNullChecks\": true\n\n    // Step\
  \ 5: Enable all strict checks\n    // tsconfig.json: \"strict\": true\n\n    //\
  \ Step 6: Fix errors one by one\n    // Use @ts-ignore sparingly for legacy code:\n\
  \    // @ts-ignore\n    const legacy = oldLibrary.method();\n    ```\n\n    ###\
  \ Type Definitions for JavaScript Libraries\n\n    ```typescript\n    // Install\
  \ type definitions\n    npm install --save-dev @types/lodash\n    npm install --save-dev\
  \ @types/express\n    npm install --save-dev @types/node\n\n    // If types don't\
  \ exist, create declaration file\n    // types/my-library.d.ts\n    declare module\
  \ 'my-library' {\n      export function doSomething(value: string): number;\n  \
  \    export interface Config {\n        apiKey: string;\n        timeout: number;\n\
  \      }\n    }\n\n    // Ambient declarations for global variables\n    // globals.d.ts\n\
  \    declare global {\n      interface Window {\n        myCustomProperty: string;\n\
  \      }\n\n      const API_URL: string;\n    }\n\n    export {};\n    ```\n\n \
  \   ## Best Practices\n\n    ### 1. Use Strict Mode\n\n    ```json\n    {\n    \
  \  \"compilerOptions\": {\n        \"strict\": true,\n        \"noImplicitAny\"\
  : true,\n        \"strictNullChecks\": true\n      }\n    }\n    ```\n\n    ###\
  \ 2. Avoid any, Use unknown\n\n    ```typescript\n    // Bad\n    function process(data:\
  \ any) {\n      return data.value;  // No type checking!\n    }\n\n    // Good\n\
  \    function process(data: unknown) {\n      if (typeof data === 'object' && data\
  \ !== null && 'value' in data) {\n        return (data as { value: string }).value;\n\
  \      }\n      throw new Error('Invalid data');\n    }\n    ```\n\n    ### 3. Use\
  \ const assertions\n\n    ```typescript\n    // Without const assertion\n    const\
  \ config = {\n      apiUrl: 'https://api.example.com',\n      timeout: 5000\n  \
  \  };\n    // Type: { apiUrl: string; timeout: number; }\n\n    // With const assertion\n\
  \    const config = {\n      apiUrl: 'https://api.example.com',\n      timeout:\
  \ 5000\n    } as const;\n    // Type: { readonly apiUrl: \"https://api.example.com\"\
  ; readonly timeout: 5000; }\n\n    // Const assertion for arrays\n    const colors\
  \ = ['red', 'green', 'blue'] as const;\n    // Type: readonly [\"red\", \"green\"\
  , \"blue\"]\n    type Color = typeof colors[number];  // \"red\" | \"green\" | \"\
  blue\"\n    ```\n\n    ### 4. Use Template Literal Types\n\n    ```typescript\n\
  \    // Create type-safe string patterns\n    type EventName = 'click' | 'focus'\
  \ | 'blur';\n    type EventHandlerName = `on${Capitalize<EventName>}`;\n    // Type:\
  \ \"onClick\" | \"onFocus\" | \"onBlur\"\n\n    // HTTP methods with paths\n   \
  \ type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';\n    type Route = '/users'\
  \ | '/posts' | '/comments';\n    type Endpoint = `${HttpMethod} ${Route}`;\n   \
  \ // Type: \"GET /users\" | \"GET /posts\" | ... (12 combinations)\n    ```\n\n\
  \    ### 5. Organize Types\n\n    ```typescript\n    // types/user.ts\n    export\
  \ interface User {\n      id: number;\n      name: string;\n      email: string;\n\
  \    }\n\n    export type CreateUserDTO = Omit<User, 'id'>;\n    export type UpdateUserDTO\
  \ = Partial<CreateUserDTO>;\n\n    // types/api.ts\n    export interface ApiResponse<T>\
  \ {\n      data: T;\n      status: number;\n      message: string;\n    }\n\n  \
  \  export type ApiError = {\n      status: number;\n      message: string;\n   \
  \   errors?: Record<string, string[]>;\n    };\n\n    // Import in other files\n\
  \    import { User, CreateUserDTO } from './types/user';\n    import { ApiResponse\
  \ } from './types/api';\n    ```\n\n    ### 6. Use Discriminated Unions for State\n\
  \n    ```typescript\n    // Type-safe state management\n    type LoadingState<T>\
  \ =\n      | { status: 'idle' }\n      | { status: 'loading' }\n      | { status:\
  \ 'success'; data: T }\n      | { status: 'error'; error: Error };\n\n    function\
  \ DataComponent() {\n      const [state, setState] = useState<LoadingState<User[]>>({\n\
  \        status: 'idle'\n      });\n\n      // TypeScript narrows the type based\
  \ on status\n      if (state.status === 'loading') {\n        return <div>Loading...</div>;\n\
  \      }\n\n      if (state.status === 'error') {\n        return <div>Error: {state.error.message}</div>;\n\
  \      }\n\n      if (state.status === 'success') {\n        return (\n        \
  \  <ul>\n            {state.data.map(user => (\n              <li key={user.id}>{user.name}</li>\n\
  \            ))}\n          </ul>\n        );\n      }\n\n      return <button onClick={fetchData}>Load\
  \ Data</button>;\n    }\n    ```\n\n    ## Common Pitfalls and Solutions\n\n   \
  \ ### 1. Optional Chaining\n\n    ```typescript\n    // Before\n    const city =\
  \ user && user.address && user.address.city;\n\n    // After (TypeScript 3.7+)\n\
  \    const city = user?.address?.city;\n    ```\n\n    ### 2. Nullish Coalescing\n\
  \n    ```typescript\n    // Before (falsy values treated as null)\n    const value\
  \ = user.count || 10;  // Problem: 0 is falsy!\n\n    // After (only null/undefined)\n\
  \    const value = user.count ?? 10;  // Only replaces null/undefined\n    ```\n\
  \n    ### 3. Type vs Interface\n\n    ```typescript\n    // Use interface for object\
  \ shapes\n    interface User {\n      id: number;\n      name: string;\n    }\n\n\
  \    // Use type for unions, intersections, primitives\n    type ID = string | number;\n\
  \    type Result = Success | Error;\n    ```\n\n    ## Interview Tips\n\n    1.\
  \ **Know tsconfig.json options** - especially strict mode\n    2. **Generics are\
  \ powerful** - use them for reusable code\n    3. **Type guards enable narrowing**\
  \ - typeof, instanceof, custom\n    4. **Utility types save time** - Partial, Pick,\
  \ Omit, Record\n    5. **React: avoid React.FC** - modern apps use direct function\
  \ types\n    6. **Express: type Request generics** - Request<Params, ResBody, ReqBody>\n\
  \    7. **Migration: gradual is ok** - start with allowJs, add types incrementally\n\
  \    8. **Avoid any** - use unknown when type is truly unknown\n    9. **Use const\
  \ assertions** - for literal types and readonly\n    10. **Discriminated unions**\
  \ - perfect for state management\n\n    ## Resources\n\n    - **Official Docs**:\
  \ https://www.typescriptlang.org/docs/\n    - **TypeScript Playground**: https://www.typescriptlang.org/play\n\
  \    - **React TypeScript Cheatsheet**: https://react-typescript-cheatsheet.netlify.app/\n\
  \    - **Type Challenges**: https://github.com/type-challenges/type-challenges\n\
  \n    **You now have the TypeScript skills to build type-safe, scalable applications!**"
exercises:
- type: mcq
  sequence_order: 1
  question: What does the "strict" flag in tsconfig.json do?
  options:
  - Makes TypeScript compile faster
  - Enables all strict type checking options (noImplicitAny, strictNullChecks, etc.)
    for maximum type safety
  - Prevents the code from compiling if there are any warnings
  - Enforces specific code formatting rules
  correct_answer: Enables all strict type checking options (noImplicitAny, strictNullChecks,
    etc.) for maximum type safety
  explanation: 'The "strict": true flag in tsconfig.json is the master switch that
    enables ALL strict type checking options in TypeScript, catching bugs at compile
    time instead of runtime. What it enables: (1) noImplicitAny - Error if TypeScript
    infers "any" type. function add(a, b) → Error: Need types. Forces explicit types:
    function add(a: number, b: number), (2) strictNullChecks - null and undefined
    are distinct from other types. let name: string = null → Error. Must use: let
    name: string | null = null, prevents "Cannot read property of null" errors, (3)
    strictFunctionTypes - Stricter checking of function parameter types (contravariance),
    (4) strictBindCallApply - Type checks bind/call/apply methods, (5) noImplicitThis
    - Error on "this" with implicit any type, (6) alwaysStrict - Emit "use strict"
    in JS output. Why use strict mode: (1) Catch bugs early - Many runtime errors
    become compile errors, (2) Better refactoring - Confident changes won''t break
    code, (3) Self-documenting - Types serve as inline documentation, (4) IDE support
    - Better autocomplete and refactoring. Trade-off: More upfront work (must add
    types), but saves debugging time later. Best practice: ALWAYS enable strict mode
    for new projects. Migration strategy for existing projects: Enable strict gradually
    file-by-file: // @ts-strict in individual files, Fix errors one module at a time.'
  require_pass: true
- type: mcq
  sequence_order: 2
  question: Why is it recommended to use "as const" when returning tuples from custom
    hooks?
  options:
  - as const makes the hook run faster
  - as const creates a readonly tuple type, preventing TypeScript from widening the
    type to a mutable array
  - as const is required for all hooks by React
  - as const automatically memoizes the values
  correct_answer: as const creates a readonly tuple type, preventing TypeScript from
    widening the type to a mutable array
  explanation: 'The "as const" assertion creates a readonly tuple type, essential
    for custom hooks that return fixed-length arrays with specific types at each position.
    The problem: Without as const, TypeScript infers mutable array type. function
    useLocalStorage(key: string, initial: string) { const [value, setValue] = useState(initial);
    return [value, setValue]; } TypeScript infers return type: (string | Dispatch<string>)[]
    - Array of mixed types, not tuple. Usage: const [name, setName] = useLocalStorage("name",
    "Alice"); TypeScript doesn''t know name is string and setName is function - type
    information lost! Solution: Return tuple with as const. return [value, setValue]
    as const; TypeScript infers: readonly [string, Dispatch<SetStateAction<string>>]
    - Tuple with exact types at each position. Now: const [name, setName] = useLocalStorage("name",
    "Alice") correctly infers name: string and setName: Dispatch. Benefits: (1) Correct
    types - Each position has specific type, (2) Array destructuring works - TypeScript
    knows what each element is, (3) Readonly - Prevents accidental mutation of tuple.
    Alternative: Explicit return type annotation. function useLocalStorage(key: string,
    initial: string): [string, Dispatch<SetStateAction<string>>] { return [value,
    setValue]; } When to use: Custom hooks returning arrays (tuple-like), Objects
    with const values. Not needed: Single value returns, Objects with mutable properties.'
  require_pass: true
- type: mcq
  sequence_order: 3
  question: What is the purpose of the "skipLibCheck" option in tsconfig.json?
  options:
  - Skips type checking of your own code
  - Skips type checking of .d.ts declaration files to speed up compilation
  - Skips downloading type definitions from npm
  - Disables all type checking
  correct_answer: Skips type checking of .d.ts declaration files to speed up compilation
  explanation: '"skipLibCheck": true tells TypeScript to skip type checking of declaration
    files (.d.ts), significantly improving compilation speed without sacrificing safety
    of your own code. What it does: TypeScript normally checks ALL .d.ts files including:
    Your project''s declaration files, All @types/* packages in node_modules (e.g.,
    @types/react, @types/node), Third-party library types. With skipLibCheck: true,
    TypeScript skips checking library declaration files, only checks YOUR code against
    those declarations. Benefits: (1) Faster compilation - Skips thousands of declaration
    files (especially in large projects with many dependencies), 2-5x faster compile
    times common, (2) Avoid third-party type errors - Some libraries have type errors
    in their .d.ts files that you can''t fix, skipLibCheck prevents these from blocking
    your build, (3) Version conflicts - Different packages may have conflicting type
    definitions for the same library, skipLibCheck ignores these conflicts. Trade-offs:
    (1) Misses errors in YOUR declaration files - If you write .d.ts files, errors
    in them won''t be caught, (2) Library type errors - Won''t catch if library types
    are incorrect (rare). Best practices: Enable for most projects (recommended by
    TypeScript team), Disable only if: Writing library with published types, Need
    to validate all type declarations. Alternative: Use strict for your code safety,
    skipLibCheck for compilation speed - best of both worlds.'
  require_pass: true
