slug: rate-limiter-channel-semaphore
title: 'Rate Limiter: Channel Semaphore'
difficulty: medium
sequence_order: 7
estimated_minutes: 2
key_concepts: []
prerequisites: []
content_md: '# Rate Limiter: Channel Semaphore ðŸš€


  Use a buffered channel as a semaphore to limit concurrent requests. Acquire by sending
  a token; release by receiving.


  ## Mental model

  `sem := make(chan struct{}, N)` provides N slots. Each worker `sem <- struct{}{}`
  before work; `defer func(){ <-sem }()` after.


  ## Validate

  Write tests that spawn M goroutines; assert at most N run at once.'
exercises:
- type: code
  problem_statement: Implement a rate limiter using a buffered channel as a semaphore to limit concurrent requests to N goroutines. Each worker should acquire a token before starting work and release it when done.
  language: go
  starter_code: |
    package main

    import "sync"

    // RateLimiter limits concurrent operations
    type RateLimiter struct {
        sem chan struct{}
    }

    // NewRateLimiter creates a limiter with max N concurrent operations
    func NewRateLimiter(n int) *RateLimiter {
        // TODO: Initialize the semaphore channel
        return &RateLimiter{}
    }

    // Acquire a token (blocks if limit reached)
    func (r *RateLimiter) Acquire() {
        // TODO: Implement acquire
    }

    // Release a token
    func (r *RateLimiter) Release() {
        // TODO: Implement release
    }
  expected_output: Working rate limiter that correctly limits concurrent operations using a buffered channel
  sequence_order: 1
  require_pass: true
