slug: fan-outfan-in-pipeline
title: Fan-out/Fan-in Pipeline
difficulty: easy
sequence_order: 1
estimated_minutes: 2
key_concepts: []
prerequisites: []
content_md: "# Fan-out/Fan-in Pipeline \U0001F680\n\nBuild a simple fetch→parse→store\
  \ pipeline using a bounded worker pool. Practice channel handoff and fan-in aggregation.\n\
  \n## Why it matters\n- Bounded concurrency prevents resource exhaustion and keeps\
  \ latency predictable.\n- Clear ownership of closing channels avoids deadlocks and\
  \ panics.\n\n## Mental model\nProducer → [N workers] → Aggregator (fan-in). The\
  \ aggregator owns the output channel and closes it once all workers finish.\n\n\
  ## Invariants\n- Output channel closes once (after all workers return)\n- No sends\
  \ after close, no goroutine leaks on early exit\n- Backpressure exists at the input\
  \ queue\n\n## Common failure modes\n- Double closing the output channel (panic)\n\
  - Workers blocked forever on send (aggregator not reading)\n- Goroutine leaks (no\
  \ ctx cancellation)\n\n## Quick snippet\n```go\nvar wg sync.WaitGroup\nout := make(chan\
  \ T)\nfor i := 0; i < n; i++ {\n  wg.Add(1)\n  go func() {\n    defer wg.Done()\n\
  \    for v := range in {\n      select {\n      case <-ctx.Done():\n        return\n\
  \      case out <- process(v):\n      }\n    }\n  }()\n}\ngo func() { wg.Wait();\
  \ close(out) }()\n```\n\n## Validate\nRun the pipeline tests in examples/go-concurrency-capstone.\n\
  \n```bash\ngo test ./examples/go-concurrency-capstone/internal/pipeline -run TestPipeline_ProcessesURLs\
  \ -race\n```\n\n## Key Points\n- Use a single input channel to feed workers\n- Aggregate\
  \ completion via WaitGroup and close the fan-in channel when done\n- Keep stages\
  \ small and testable (Fetcher, Parser, Store interfaces)"
exercises:
- type: terminal
  problem_statement: Run the pipeline test with race detector to validate that the fan-out/fan-in implementation correctly processes URLs without data races or panics
  expected_output: Test passes with no data races, panics, or goroutine leaks
  language: bash
  starter_code: "# Run pipeline test with race detector\n"
  sequence_order: 1
  command: go test ./examples/go-concurrency-capstone/internal/pipeline -run TestPipeline_ProcessesURLs
    -race
  description: Run pipeline test with race detector to validate fan-in correctness.
  validation:
    must_not_include:
    - DATA RACE
    - 'panic:'
  timeout_sec: 60
  require_pass: true
- type: mcq
  sequence_order: 2
  question: Who is responsible for closing the fan-in output channel?
  options:
  - The aggregator goroutine after all workers finish
  - Each worker after it sends its last result
  - The producer when it closes the input
  - Nobody; channels close themselves
  correct_answer: The aggregator goroutine after all workers finish
  explanation: "In a fan-in pattern, the aggregator goroutine is responsible for closing the output channel. It uses a WaitGroup to wait for all worker goroutines to complete, then closes the channel. If each worker closed the channel, it would cause a panic on subsequent close attempts. Proper ownership prevents double-close panics and ensures downstream consumers know when all data has been sent."
- type: code
  problem_statement: Implement a fan-out/fan-in pipeline with N worker goroutines that process items from an input channel and send results to an output channel. Use WaitGroup to coordinate completion and properly close the output channel.
  language: go
  starter_code: |
    package main

    import "sync"

    func fanOutFanIn(input <-chan int, n int) <-chan int {
        output := make(chan int)
        var wg sync.WaitGroup

        // TODO: Launch N worker goroutines
        // Each worker should:
        // 1. Read from input channel
        // 2. Process the value (square it for example)
        // 3. Send to output channel

        // TODO: Start a goroutine to close output after all workers finish

        return output
    }
  expected_output: Working fan-out/fan-in implementation that properly closes channels and avoids leaks
  sequence_order: 3
  require_pass: true
- type: sandbox
  sequence_order: 4
  hints:
  - Bounded worker count prevents runaway goroutines under CPU pressure.
  - Watch for timeouts or leaks when CPU is constrained.
  validation:
    must_not_include:
    - DATA RACE
  timeout_sec: 60
  require_pass: true
