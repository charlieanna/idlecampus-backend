slug: lesson-3
title: Lesson 3
difficulty: easy
sequence_order: 3
estimated_minutes: 2
key_concepts: []
prerequisites: []
content_md: "# Microlesson \U0001F680\n\n# Production GraphQL\n\n    ## Apollo Server\
  \ Setup\n\n    Apollo Server is the industry-standard GraphQL server for Node.js.\n\
  \n    ### Basic Production Setup\n\n    ```javascript\n    const { ApolloServer\
  \ } = require('apollo-server-express');\n    const express = require('express');\n\
  \    const helmet = require('helmet');\n    const cors = require('cors');\n    const\
  \ compression = require('compression');\n    const { createServer } = require('http');\n\
  \n    const app = express();\n\n    // Security middleware\n    app.use(helmet({\n\
  \      contentSecurityPolicy: false,\n      crossOriginEmbedderPolicy: false\n \
  \   }));\n\n    // CORS\n    app.use(cors({\n      origin: process.env.ALLOWED_ORIGINS?.split(',')\
  \ || '*',\n      credentials: true\n    }));\n\n    // Compression\n    app.use(compression());\n\
  \n    // Health check endpoint\n    app.get('/health', (req, res) => {\n      res.json({\
  \ status: 'healthy', timestamp: new Date().toISOString() });\n    });\n\n    //\
  \ Create Apollo Server\n    const server = new ApolloServer({\n      typeDefs,\n\
  \      resolvers,\n      context: async ({ req }) => ({\n        db,\n        user:\
  \ req.user,\n        loaders: createLoaders(db)\n      }),\n\n      // Production\
  \ settings\n      introspection: process.env.NODE_ENV !== 'production',\n      playground:\
  \ process.env.NODE_ENV !== 'production',\n\n      // Error handling\n      formatError:\
  \ (error) => {\n        // Log error\n        console.error('GraphQL Error:', error);\n\
  \n        // Don't expose internal errors in production\n        if (process.env.NODE_ENV\
  \ === 'production') {\n          // Remove stack traces\n          delete error.extensions?.exception;\n\
  \        }\n\n        return error;\n      },\n\n      // Performance monitoring\n\
  \      plugins: [\n        {\n          requestDidStart() {\n            const start\
  \ = Date.now();\n            return {\n              willSendResponse({ response\
  \ }) {\n                const duration = Date.now() - start;\n                console.log(\\\
  `Query took \\${duration}ms\\`);\n              }\n            };\n          }\n\
  \        }\n      ]\n    });\n\n    server.applyMiddleware({ app, path: '/graphql'\
  \ });\n\n    const httpServer = createServer(app);\n    server.installSubscriptionHandlers(httpServer);\n\
  \n    const PORT = process.env.PORT || 4000;\n    httpServer.listen(PORT, () =>\
  \ {\n      console.log(\\`\U0001F680 Server ready at http://localhost:\\${PORT}\\\
  ${server.graphqlPath}\\`);\n      console.log(\\`\U0001F50C Subscriptions ready\
  \ at ws://localhost:\\${PORT}\\${server.subscriptionsPath}\\`);\n    });\n    ```\n\
  \n    ## GraphQL with TypeScript\n\n    ### Type-Safe Schema\n\n    ```typescript\n\
  \    // types.ts\n    export interface User {\n      id: string;\n      name: string;\n\
  \      email: string;\n      role: Role;\n      createdAt: Date;\n      updatedAt:\
  \ Date;\n    }\n\n    export interface Post {\n      id: string;\n      title: string;\n\
  \      content: string;\n      authorId: string;\n      published: boolean;\n  \
  \    createdAt: Date;\n      updatedAt: Date;\n    }\n\n    export enum Role {\n\
  \      ADMIN = 'ADMIN',\n      USER = 'USER',\n      MODERATOR = 'MODERATOR'\n \
  \   }\n\n    export interface Context {\n      db: Database;\n      user: User |\
  \ null;\n      loaders: {\n        user: DataLoader<string, User>;\n        post:\
  \ DataLoader<string, Post>;\n      };\n    }\n\n    export interface CreatePostInput\
  \ {\n      title: string;\n      content: string;\n      tags?: string[];\n    \
  \  published?: boolean;\n    }\n    ```\n\n    ### Type-Safe Resolvers\n\n    ```typescript\n\
  \    import { IResolvers } from '@graphql-tools/utils';\n    import { Context, User,\
  \ Post, CreatePostInput } from './types';\n\n    export const resolvers: IResolvers<any,\
  \ Context> = {\n      Query: {\n        me: (parent, args, context): User | null\
  \ => {\n          return context.user;\n        },\n\n        user: async (\n  \
  \        parent,\n          args: { id: string },\n          context\n        ):\
  \ Promise<User | null> => {\n          return await context.loaders.user.load(args.id);\n\
  \        },\n\n        posts: async (\n          parent,\n          args: { limit?:\
  \ number; offset?: number },\n          context\n        ): Promise<Post[]> => {\n\
  \          const limit = args.limit || 10;\n          const offset = args.offset\
  \ || 0;\n\n          return await context.db.posts\n            .limit(limit)\n\
  \            .offset(offset)\n            .orderBy('createdAt', 'desc');\n     \
  \   }\n      },\n\n      Mutation: {\n        createPost: async (\n          parent,\n\
  \          args: { input: CreatePostInput },\n          context\n        ): Promise<Post>\
  \ => {\n          if (!context.user) {\n            throw new Error('Not authenticated');\n\
  \          }\n\n          const { input } = args;\n          const post = await\
  \ context.db.posts.create({\n            ...input,\n            authorId: context.user.id,\n\
  \            published: input.published ?? false\n          });\n\n          return\
  \ post;\n        }\n      },\n\n      // Field resolvers with types\n      User:\
  \ {\n        posts: async (parent: User, args, context): Promise<Post[]> => {\n\
  \          return await context.db.posts.where({ authorId: parent.id });\n     \
  \   }\n      },\n\n      Post: {\n        author: async (parent: Post, args, context):\
  \ Promise<User> => {\n          return await context.loaders.user.load(parent.authorId);\n\
  \        }\n      }\n    };\n    ```\n\n    ### Code Generation\n\n    **Use GraphQL\
  \ Code Generator for automatic type generation**\n\n    ```bash\n    npm install\
  \ -D @graphql-codegen/cli @graphql-codegen/typescript @graphql-codegen/typescript-resolvers\n\
  \    ```\n\n    ```yaml\n    # codegen.yml\n    schema: \"./schema.graphql\"\n \
  \   generates:\n      ./src/generated/graphql.ts:\n        plugins:\n          -\
  \ typescript\n          - typescript-resolvers\n        config:\n          contextType:\
  \ \"../types#Context\"\n          mappers:\n            User: \"../types#User\"\n\
  \            Post: \"../types#Post\"\n    ```\n\n    ```bash\n    # Generate types\n\
  \    npx graphql-codegen\n    ```\n\n    ## Caching Strategies\n\n    ### Response\
  \ Caching\n\n    ```javascript\n    const { ApolloServer } = require('apollo-server-express');\n\
  \    const responseCachePlugin = require('apollo-server-plugin-response-cache');\n\
  \    const { RedisCache } = require('apollo-server-cache-redis');\n\n    const server\
  \ = new ApolloServer({\n      typeDefs,\n      resolvers,\n      cache: new RedisCache({\n\
  \        host: process.env.REDIS_HOST,\n        port: process.env.REDIS_PORT\n \
  \     }),\n      plugins: [\n        responseCachePlugin({\n          // Cache by\
  \ session ID\n          sessionId: (requestContext) => {\n            return requestContext.request.http?.headers.get('session-id')\
  \ || null;\n          }\n        })\n      ]\n    });\n    ```\n\n    **Add cache\
  \ hints to schema:**\n\n    ```graphql\n    type Query {\n      # Cache for 60 seconds\n\
  \      posts: [Post!]! @cacheControl(maxAge: 60)\n\n      # Cache for 300 seconds,\
  \ public\n      publicPosts: [Post!]! @cacheControl(maxAge: 300, scope: PUBLIC)\n\
  \n      # Don't cache\n      me: User @cacheControl(maxAge: 0)\n    }\n\n    type\
  \ Post @cacheControl(maxAge: 60) {\n      id: ID!\n      title: String!\n      #\
  \ Override parent cache\n      viewCount: Int! @cacheControl(maxAge: 10)\n    }\n\
  \    ```\n\n    ### Persisted Queries\n\n    **Reduce bandwidth and improve security**\n\
  \n    ```javascript\n    const { ApolloServer } = require('apollo-server-express');\n\
  \    const { createPersistedQueryLink } = require('@apollo/client/link/persisted-queries');\n\
  \n    const server = new ApolloServer({\n      typeDefs,\n      resolvers,\n   \
  \   persistedQueries: {\n        cache: new RedisCache({\n          host: process.env.REDIS_HOST\n\
  \        })\n      }\n    });\n\n    // Client setup\n    import { createPersistedQueryLink\
  \ } from '@apollo/client/link/persisted-queries';\n    import { sha256 } from 'crypto-hash';\n\
  \n    const link = createPersistedQueryLink({ sha256 }).concat(httpLink);\n\n  \
  \  const client = new ApolloClient({\n      link,\n      cache: new InMemoryCache()\n\
  \    });\n\n    // First request: sends full query + hash\n    // Subsequent requests:\
  \ sends only hash (smaller payload)\n    ```\n\n    ## Query Complexity and Rate\
  \ Limiting\n\n    ### Query Complexity\n\n    **Prevent expensive queries**\n\n\
  \    ```javascript\n    const { createComplexityLimitRule } = require('graphql-validation-complexity');\n\
  \n    const server = new ApolloServer({\n      typeDefs,\n      resolvers,\n   \
  \   validationRules: [\n        createComplexityLimitRule(1000, {\n          onCost:\
  \ (cost) => {\n            console.log('Query cost:', cost);\n          },\n   \
  \       formatErrorMessage: (cost) => {\n            return \\`Query too complex:\
  \ \\${cost}. Maximum allowed: 1000\\`;\n          }\n        })\n      ]\n    });\n\
  \    ```\n\n    **Assign costs to fields:**\n\n    ```graphql\n    type Query {\n\
  \      user(id: ID!): User       # Cost: 1\n      users: [User!]!           # Cost:\
  \ 10 (returns multiple)\n    }\n\n    type User {\n      id: ID!               \
  \    # Cost: 0\n      name: String!             # Cost: 0\n      posts: [Post!]!\
  \           # Cost: 10 (N+1 potential)\n      followers: [User!]!       # Cost:\
  \ 10\n    }\n\n    # This query would have high cost:\n    query {\n      users\
  \ {                   # 10\n        posts {                 # 10 × users\n     \
  \     author {              # 1 × posts × users\n            followers {       \
  \  # 10 × posts × users\n              posts {           # 10 × followers × posts\
  \ × users\n                title\n              }\n            }\n          }\n\
  \        }\n      }\n    }\n    ```\n\n    ### Rate Limiting\n\n    ```javascript\n\
  \    const { RateLimiterRedis } = require('rate-limiter-flexible');\n    const Redis\
  \ = require('ioredis');\n\n    const redisClient = new Redis({\n      host: process.env.REDIS_HOST,\n\
  \      port: process.env.REDIS_PORT\n    });\n\n    const rateLimiter = new RateLimiterRedis({\n\
  \      storeClient: redisClient,\n      points: 100,        // Number of requests\n\
  \      duration: 60,       // Per 60 seconds\n      blockDuration: 60   // Block\
  \ for 60 seconds if exceeded\n    });\n\n    const server = new ApolloServer({\n\
  \      typeDefs,\n      resolvers,\n      context: async ({ req }) => {\n      \
  \  const ip = req.ip || req.connection.remoteAddress;\n\n        try {\n       \
  \   await rateLimiter.consume(ip);\n        } catch (error) {\n          throw new\
  \ Error('Too many requests. Please try again later.');\n        }\n\n        return\
  \ { db, user: req.user };\n      }\n    });\n    ```\n\n    ### Field-Level Rate\
  \ Limiting\n\n    ```javascript\n    const { shield, rule } = require('graphql-shield');\n\
  \n    const isAuthenticated = rule({ cache: 'contextual' })(\n      async (parent,\
  \ args, context) => {\n        return context.user !== null;\n      }\n    );\n\n\
  \    const rateLimit = rule({ cache: 'contextual' })(\n      async (parent, args,\
  \ context) => {\n        const key = \\`rate_limit:\\${context.user?.id || context.ip}\\\
  `;\n\n        try {\n          await rateLimiter.consume(key);\n          return\
  \ true;\n        } catch {\n          return new Error('Rate limit exceeded');\n\
  \        }\n      }\n    );\n\n    const permissions = shield({\n      Query: {\n\
  \        me: isAuthenticated,\n        searchPosts: rateLimit  // Rate limit search\n\
  \      },\n      Mutation: {\n        createPost: isAuthenticated,\n        uploadAvatar:\
  \ rateLimit  // Rate limit uploads\n      }\n    });\n\n    const server = new ApolloServer({\n\
  \      typeDefs,\n      resolvers,\n      middlewares: [permissions]\n    });\n\
  \    ```\n\n    ## Schema Stitching and Federation\n\n    ### Schema Stitching (Legacy)\n\
  \n    **Combine multiple GraphQL schemas**\n\n    ```javascript\n    const { stitchSchemas\
  \ } = require('@graphql-tools/stitch');\n\n    // User service\n    const userSchema\
  \ = makeExecutableSchema({\n      typeDefs: `\n        type User {\n          id:\
  \ ID!\n          name: String!\n        }\n        type Query {\n          user(id:\
  \ ID!): User\n        }\n      `,\n      resolvers: userResolvers\n    });\n\n \
  \   // Post service\n    const postSchema = makeExecutableSchema({\n      typeDefs:\
  \ `\n        type Post {\n          id: ID!\n          title: String!\n        \
  \  authorId: ID!\n        }\n        type Query {\n          post(id: ID!): Post\n\
  \        }\n      `,\n      resolvers: postResolvers\n    });\n\n    // Stitch schemas\
  \ together\n    const stitchedSchema = stitchSchemas({\n      subschemas: [\n  \
  \      { schema: userSchema },\n        { schema: postSchema }\n      ]\n    });\n\
  \    ```\n\n    ### Apollo Federation (Modern)\n\n    **Microservices architecture\
  \ for GraphQL**\n\n    ```javascript\n    // User service (subgraph)\n    const\
  \ { ApolloServer, gql } = require('apollo-server');\n    const { buildFederatedSchema\
  \ } = require('@apollo/federation');\n\n    const typeDefs = gql\\`\n      type\
  \ User @key(fields: \"id\") {\n        id: ID!\n        name: String!\n        email:\
  \ String!\n      }\n\n      extend type Post @key(fields: \"id\") {\n        id:\
  \ ID! @external\n        author: User\n      }\n\n      type Query {\n        user(id:\
  \ ID!): User\n      }\n    \\`;\n\n    const resolvers = {\n      User: {\n    \
  \    __resolveReference(user) {\n          return getUserById(user.id);\n      \
  \  }\n      },\n      Post: {\n        author(post) {\n          return { __typename:\
  \ 'User', id: post.authorId };\n        }\n      }\n    };\n\n    const server =\
  \ new ApolloServer({\n      schema: buildFederatedSchema([{ typeDefs, resolvers\
  \ }])\n    });\n\n    // Post service (subgraph)\n    const typeDefs = gql\\`\n\
  \      type Post @key(fields: \"id\") {\n        id: ID!\n        title: String!\n\
  \        content: String!\n        authorId: ID!\n      }\n\n      type Query {\n\
  \        post(id: ID!): Post\n        posts: [Post!]!\n      }\n    \\`;\n\n   \
  \ // Gateway (combines subgraphs)\n    const { ApolloGateway } = require('@apollo/gateway');\n\
  \n    const gateway = new ApolloGateway({\n      serviceList: [\n        { name:\
  \ 'users', url: 'http://localhost:4001/graphql' },\n        { name: 'posts', url:\
  \ 'http://localhost:4002/graphql' }\n      ]\n    });\n\n    const server = new\
  \ ApolloServer({ gateway });\n    ```\n\n    ## Monitoring and Performance\n\n \
  \   ### Apollo Studio\n\n    ```javascript\n    const { ApolloServer } = require('apollo-server');\n\
  \n    const server = new ApolloServer({\n      typeDefs,\n      resolvers,\n   \
  \   plugins: [\n        require('apollo-server-core').ApolloServerPluginUsageReporting({\n\
  \          sendVariableValues: { all: true },\n          sendHeaders: { all: true\
  \ }\n        })\n      ]\n    });\n\n    // Set APOLLO_KEY environment variable\n\
  \    // Metrics sent to Apollo Studio automatically\n    ```\n\n    ### Custom Metrics\n\
  \n    ```javascript\n    const prometheus = require('prom-client');\n\n    // Define\
  \ metrics\n    const queryDuration = new prometheus.Histogram({\n      name: 'graphql_query_duration_ms',\n\
  \      help: 'GraphQL query duration in milliseconds',\n      labelNames: ['operation_name']\n\
  \    });\n\n    const queryErrors = new prometheus.Counter({\n      name: 'graphql_query_errors_total',\n\
  \      help: 'Total GraphQL query errors',\n      labelNames: ['operation_name',\
  \ 'error_type']\n    });\n\n    const server = new ApolloServer({\n      typeDefs,\n\
  \      resolvers,\n      plugins: [\n        {\n          requestDidStart(requestContext)\
  \ {\n            const start = Date.now();\n            const operationName = requestContext.request.operationName;\n\
  \n            return {\n              willSendResponse() {\n                const\
  \ duration = Date.now() - start;\n                queryDuration.observe({ operation_name:\
  \ operationName }, duration);\n              },\n\n              didEncounterErrors(requestContext)\
  \ {\n                const { errors } = requestContext;\n                errors.forEach(error\
  \ => {\n                  queryErrors.inc({\n                    operation_name:\
  \ operationName,\n                    error_type: error.extensions?.code || 'UNKNOWN'\n\
  \                  });\n                });\n              }\n            };\n \
  \         }\n        }\n      ]\n    });\n\n    // Prometheus metrics endpoint\n\
  \    app.get('/metrics', async (req, res) => {\n      res.set('Content-Type', prometheus.register.contentType);\n\
  \      res.end(await prometheus.register.metrics());\n    });\n    ```\n\n    ###\
  \ Query Performance Logging\n\n    ```javascript\n    const server = new ApolloServer({\n\
  \      typeDefs,\n      resolvers,\n      plugins: [\n        {\n          requestDidStart()\
  \ {\n            return {\n              executionDidStart() {\n               \
  \ return {\n                  willResolveField({ info }) {\n                   \
  \ const start = Date.now();\n                    return () => {\n              \
  \        const duration = Date.now() - start;\n                      if (duration\
  \ > 100) {  // Log slow resolvers\n                        console.warn(\n     \
  \                     \\`Slow resolver: \\${info.parentType}.\\${info.fieldName}\
  \ took \\${duration}ms\\`\n                        );\n                      }\n\
  \                    };\n                  }\n                };\n             \
  \ }\n            };\n          }\n        }\n      ]\n    });\n    ```\n\n    ##\
  \ Production Best Practices\n\n    ### 1. Security\n\n    ```javascript\n    //\
  \ Disable introspection in production\n    introspection: process.env.NODE_ENV !==\
  \ 'production',\n\n    // Depth limiting\n    const depthLimit = require('graphql-depth-limit');\n\
  \    validationRules: [depthLimit(5)],\n\n    // Query whitelisting (persisted queries\
  \ only)\n    persistedQueries: {\n      ttl: 900\n    },\n\n    // Disable playground\
  \ in production\n    playground: false,\n\n    // CORS\n    cors: {\n      origin:\
  \ process.env.ALLOWED_ORIGINS.split(','),\n      credentials: true\n    }\n    ```\n\
  \n    ### 2. Performance\n\n    ```javascript\n    // DataLoader for all relations\n\
  \    loaders: createLoaders(db),\n\n    // Response caching\n    cache: new RedisCache(),\n\
  \n    // Query complexity limits\n    validationRules: [complexityLimit(1000)],\n\
  \n    // Connection pooling\n    db: new Pool({\n      max: 20,\n      idleTimeoutMillis:\
  \ 30000\n    })\n    ```\n\n    ### 3. Error Handling\n\n    ```javascript\n   \
  \ formatError: (error) => {\n      // Log all errors\n      logger.error('GraphQL\
  \ Error:', {\n        message: error.message,\n        path: error.path,\n     \
  \   code: error.extensions?.code\n      });\n\n      // Don't expose internals in\
  \ production\n      if (process.env.NODE_ENV === 'production') {\n        if (error.message.includes('database'))\
  \ {\n          return new Error('Internal server error');\n        }\n      }\n\n\
  \      return error;\n    }\n    ```\n\n    ### 4. Monitoring\n\n    - **Apollo\
  \ Studio** for query analytics\n    - **Prometheus** for metrics\n    - **DataDog/New\
  \ Relic** for APM\n    - **Sentry** for error tracking\n    - **CloudWatch/Grafana**\
  \ for infrastructure\n\n    ### 5. Documentation\n\n    ```graphql\n    \"\"\"\n\
  \    Represents a user in the system\n    \"\"\"\n    type User {\n      \"\"\"\n\
  \      Unique user identifier\n      \"\"\"\n      id: ID!\n\n      \"\"\"\n   \
  \   User's display name\n      \"\"\"\n      name: String!\n\n      \"\"\"\n   \
  \   User's email address (private, only visible to user)\n      \"\"\"\n      email:\
  \ String!\n    }\n\n    type Query {\n      \"\"\"\n      Get a user by ID\n   \
  \   @param id - The user's unique identifier\n      @returns User object or null\
  \ if not found\n      \"\"\"\n      user(id: ID!): User\n    }\n    ```\n\n    ##\
  \ Complete Production Example\n\n    ```javascript\n    require('dotenv').config();\n\
  \    const { ApolloServer } = require('apollo-server-express');\n    const express\
  \ = require('express');\n    const helmet = require('helmet');\n    const compression\
  \ = require('compression');\n    const { createServer } = require('http');\n   \
  \ const { RedisCache } = require('apollo-server-cache-redis');\n    const depthLimit\
  \ = require('graphql-depth-limit');\n    const { createComplexityLimitRule } = require('graphql-validation-complexity');\n\
  \n    const app = express();\n\n    // Middleware\n    app.use(helmet());\n    app.use(compression());\n\
  \    app.use(express.json());\n\n    // Health check\n    app.get('/health', (req,\
  \ res) => {\n      res.json({ status: 'healthy' });\n    });\n\n    // Apollo Server\n\
  \    const server = new ApolloServer({\n      typeDefs,\n      resolvers,\n    \
  \  cache: new RedisCache({\n        host: process.env.REDIS_HOST,\n        port:\
  \ process.env.REDIS_PORT\n      }),\n      context: async ({ req }) => ({\n    \
  \    db,\n        user: req.user,\n        loaders: createLoaders(db)\n      }),\n\
  \      introspection: process.env.NODE_ENV !== 'production',\n      playground:\
  \ process.env.NODE_ENV !== 'production',\n      validationRules: [\n        depthLimit(5),\n\
  \        createComplexityLimitRule(1000)\n      ],\n      formatError: (error) =>\
  \ {\n        console.error(error);\n        if (process.env.NODE_ENV === 'production')\
  \ {\n          delete error.extensions?.exception;\n        }\n        return error;\n\
  \      }\n    });\n\n    server.applyMiddleware({ app });\n\n    const httpServer\
  \ = createServer(app);\n    server.installSubscriptionHandlers(httpServer);\n\n\
  \    const PORT = process.env.PORT || 4000;\n    httpServer.listen(PORT, () => {\n\
  \      console.log(\\`\U0001F680 Server ready at http://localhost:\\${PORT}\\${server.graphqlPath}\\\
  `);\n    });\n    ```\n\n    **Congratulations!** You now have the knowledge to\
  \ build production-ready GraphQL APIs with best practices for performance, security,\
  \ and scalability."
exercises:
- type: mcq
  sequence_order: 1
  question: Why should you disable GraphQL introspection and playground in production
    environments?
  options:
  - They slow down query execution
  - They expose your schema structure to attackers, enabling reconnaissance and targeted
    attacks
  - They are required features that must always be enabled
  - They consume too much memory
  correct_answer: They expose your schema structure to attackers, enabling reconnaissance
    and targeted attacks
  explanation: 'GraphQL introspection and playground are developer tools that pose
    security risks in production. Introspection: Allows querying the schema structure
    via __schema and __type. Attackers can: (1) Discover all types, fields, mutations
    - learn your entire data model, (2) Find sensitive fields - user.password, internal.apiKey,
    admin.deleteAll, (3) Identify attack vectors - complex nested queries for DoS,
    (4) Map relationships - understand service architecture. Playground: Web UI for
    executing queries. Risks: (1) Enables manual exploitation, (2) Consumes server
    resources, (3) May bypass authentication if misconfigured. Attack scenario: (1)
    Attacker runs introspection query, (2) Discovers User.creditCardNumber field,
    (3) Crafts malicious query to exfiltrate all credit cards, (4) Discovers deeply
    nested query (users → posts → comments → author → posts...) for DoS. Best practices:
    (1) Disable in production: introspection: process.env.NODE_ENV !== ''production'',
    playground: false, (2) Enable only for authenticated admins if needed, (3) Use
    persisted queries (only allow pre-approved queries), (4) Implement query complexity
    limits, depth limits, (5) Rate limiting per client. Development: Keep enabled
    for debugging. Staging: Consider disabling or restricting by IP/auth. Production:
    Always disable. Alternative: Use schema registry for documentation instead of
    exposing introspection.'
  require_pass: true
- type: mcq
  sequence_order: 2
  question: What is the N+1 query problem in GraphQL and how do DataLoaders solve
    it?
  options:
  - N+1 means the database is queried N+1 times; DataLoaders batch requests into single
    query
  - N+1 is a GraphQL error code that DataLoaders fix
  - N+1 queries improve performance by parallelizing database access
  - DataLoaders are not related to query optimization
  correct_answer: N+1 means the database is queried N+1 times; DataLoaders batch requests
    into single query
  explanation: 'The N+1 query problem occurs when fetching a list and related data
    causes exponential database queries. Example: Query 10 posts with their authors.
    Without DataLoader: (1) Query: SELECT * FROM posts LIMIT 10 (1 query), (2) For
    each post: SELECT * FROM users WHERE id = ? (10 queries), (3) Total: 1 + 10 =
    11 queries. With 100 posts = 101 queries. This is terrible for performance. DataLoader
    solution: Batching and caching. (1) Collect all author IDs needed: [1, 5, 3, 1,
    7...], (2) Deduplicate: [1, 3, 5, 7], (3) Single batched query: SELECT * FROM
    users WHERE id IN (1,3,5,7) (1 query), (4) Return authors in order requested.
    Total: 1 + 1 = 2 queries. 50x improvement! Implementation: const DataLoader =
    require(''dataloader''); const userLoader = new DataLoader(async (userIds) =>
    { const users = await db.users.findAll({ where: { id: userIds } }); return userIds.map(id
    => users.find(u => u.id === id)); }); In resolver: author: (post, args, { loaders
    }) => loaders.user.load(post.authorId). DataLoader automatically: (1) Batches
    requests within single tick, (2) Caches results per request, (3) Handles errors
    gracefully. This transforms O(N) queries to O(1). Essential for GraphQL performance.
    Always use DataLoaders for relationships in production.'
  require_pass: true
- type: mcq
  sequence_order: 3
  question: What are persisted queries in GraphQL and why are they useful?
  options:
  - Persisted queries save query results in the cache
  - Persisted queries allow clients to send query hash instead of full query text,
    reducing bandwidth and improving security
  - Persisted queries automatically optimize slow queries
  - Persisted queries store queries in the database
  correct_answer: Persisted queries allow clients to send query hash instead of full
    query text, reducing bandwidth and improving security
  explanation: 'Persisted queries allow clients to send a hash/ID instead of the full
    query text, providing performance and security benefits. How it works: (1) During
    build: Extract all queries from client code, assign unique IDs/hashes, (2) Deploy:
    Upload query map to server: {"abc123": "query { users { id name } }"}, (3) Runtime:
    Client sends only hash: {queryId: "abc123", variables: {...}}, (4) Server looks
    up query by hash and executes. Benefits: (1) Bandwidth savings - Send 32-byte
    hash instead of 500-byte query. Mobile apps save significant bandwidth, (2) Security
    - Only pre-approved queries can execute. Prevents malicious queries (deeply nested,
    expensive operations). Acts as query allowlist, (3) Performance - Server can cache
    parsed/validated queries by hash, (4) Versioning - Track which queries are used,
    deprecate old queries. Implementation: Server: persistedQueries: { cache: new
    RedisCache() }. Client: @apollo/client automatically generates hashes. Automatic
    Persisted Queries (APQ): (1) Client sends query hash first, (2) If server doesn''t
    have it: "PersistedQueryNotFound", (3) Client sends full query, server caches
    by hash, (4) Subsequent requests use hash only. Use cases: Mobile apps (bandwidth),
    public APIs (security), high-traffic services (performance). Drawback: Requires
    build step, harder to debug. Development: Disable. Production: Enable for security
    and performance.'
  require_pass: true
