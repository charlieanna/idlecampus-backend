slug: lesson-4
title: Lesson 4
difficulty: easy
sequence_order: 4
estimated_minutes: 2
key_concepts: []
prerequisites: []
content_md: "# Microlesson \U0001F680\n\n# Continuous Integration & Deployment\n\n\
  \    **CI/CD** automates the software delivery pipeline from code commit to production\
  \ deployment.\n\n    ## CI vs CD vs Continuous Deployment\n\n    ### Continuous\
  \ Integration (CI)\n    **Automatically build and test code on every commit**\n\n\
  \    ```\n    Developer commits code\n      ↓\n    CI server detects change\n  \
  \    ↓\n    Build application\n      ↓\n    Run automated tests\n      ↓\n    Report\
  \ results (pass/fail)\n    ```\n\n    **Benefits:**\n    - Catch bugs early (minutes,\
  \ not days)\n    - Reduce integration problems\n    - Improve code quality\n   \
  \ - Enable faster development\n\n    **Example CI workflow:**\n    ```yaml\n   \
  \ # .github/workflows/ci.yml\n    name: CI\n    on: [push, pull_request]\n\n   \
  \ jobs:\n      test:\n        runs-on: ubuntu-latest\n        steps:\n         \
  \ - uses: actions/checkout@v3\n          - name: Install dependencies\n        \
  \    run: npm install\n          - name: Run tests\n            run: npm test\n\
  \          - name: Run linter\n            run: npm run lint\n    ```\n\n    ###\
  \ Continuous Delivery (CD)\n    **Automatically prepare code for production deployment**\n\
  \n    ```\n    CI passes\n      ↓\n    Build deployment artifacts\n      ↓\n   \
  \ Deploy to staging environment\n      ↓\n    Run integration tests\n      ↓\n \
  \   Ready for manual production release\n    ```\n\n    **Key point:** Deployment\
  \ to production requires manual approval.\n\n    **Benefits:**\n    - Deployment-ready\
  \ code at all times\n    - Reduced deployment risk\n    - Predictable release process\n\
  \    - Manual control over production releases\n\n    ### Continuous Deployment\n\
  \    **Automatically deploy to production on every successful build**\n\n    ```\n\
  \    CI passes\n      ↓\n    Build artifacts\n      ↓\n    Deploy to staging\n \
  \     ↓\n    Automated tests pass\n      ↓\n    Automatically deploy to production\n\
  \    ```\n\n    **Key point:** No manual approval - every passing build goes to\
  \ production.\n\n    **Benefits:**\n    - Fastest time to market\n    - Smaller,\
  \ lower-risk deployments\n    - Immediate user feedback\n    - Forces excellent\
  \ automated testing\n\n    **Trade-off:** Requires high confidence in automated\
  \ tests and monitoring.\n\n    ## Pipeline Stages\n\n    A typical CI/CD pipeline\
  \ has multiple stages:\n\n    ### 1. Source Stage\n    **Trigger pipeline on code\
  \ changes**\n\n    ```yaml\n    # GitHub Actions trigger\n    on:\n      push:\n\
  \        branches: [main, develop]\n      pull_request:\n        branches: [main]\n\
  \    ```\n\n    ### 2. Build Stage\n    **Compile and package application**\n\n\
  \    ```yaml\n    build:\n      runs-on: ubuntu-latest\n      steps:\n        -\
  \ uses: actions/checkout@v3\n\n        - name: Set up Node.js\n          uses: actions/setup-node@v3\n\
  \          with:\n            node-version: '18'\n\n        - name: Install dependencies\n\
  \          run: npm ci\n\n        - name: Build application\n          run: npm\
  \ run build\n\n        - name: Upload build artifacts\n          uses: actions/upload-artifact@v3\n\
  \          with:\n            name: dist\n            path: dist/\n    ```\n\n \
  \   ### 3. Test Stage\n    **Run automated tests**\n\n    ```yaml\n    test:\n \
  \     needs: build\n      runs-on: ubuntu-latest\n      steps:\n        - uses:\
  \ actions/checkout@v3\n\n        # Unit tests\n        - name: Run unit tests\n\
  \          run: npm run test:unit\n\n        # Integration tests\n        - name:\
  \ Run integration tests\n          run: npm run test:integration\n\n        # Code\
  \ coverage\n        - name: Generate coverage report\n          run: npm run test:coverage\n\
  \n        - name: Upload coverage to Codecov\n          uses: codecov/codecov-action@v3\n\
  \    ```\n\n    ### 4. Quality Stage\n    **Code quality checks**\n\n    ```yaml\n\
  \    quality:\n      runs-on: ubuntu-latest\n      steps:\n        - uses: actions/checkout@v3\n\
  \n        # Linting\n        - name: Run ESLint\n          run: npm run lint\n\n\
  \        # Security scanning\n        - name: Run security audit\n          run:\
  \ npm audit\n\n        # Static analysis\n        - name: SonarCloud scan\n    \
  \      uses: SonarSource/sonarcloud-github-action@master\n          env:\n     \
  \       GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n            SONAR_TOKEN: ${{\
  \ secrets.SONAR_TOKEN }}\n    ```\n\n    ### 5. Deploy Stage\n    **Deploy to environments**\n\
  \n    ```yaml\n    deploy-staging:\n      needs: [test, quality]\n      runs-on:\
  \ ubuntu-latest\n      environment: staging\n      steps:\n        - name: Download\
  \ artifacts\n          uses: actions/download-artifact@v3\n          with:\n   \
  \         name: dist\n\n        - name: Deploy to staging\n          run: |\n  \
  \          aws s3 sync dist/ s3://my-app-staging\n            aws cloudfront create-invalidation\
  \ \\\\\n              --distribution-id ${{ secrets.STAGING_DIST_ID }} \\\\\n  \
  \            --paths \"/*\"\n\n    deploy-production:\n      needs: deploy-staging\n\
  \      runs-on: ubuntu-latest\n      environment: production\n      if: github.ref\
  \ == 'refs/heads/main'\n      steps:\n        - name: Download artifacts\n     \
  \     uses: actions/download-artifact@v3\n          with:\n            name: dist\n\
  \n        - name: Deploy to production\n          run: |\n            aws s3 sync\
  \ dist/ s3://my-app-production\n            aws cloudfront create-invalidation \\\
  \\\n              --distribution-id ${{ secrets.PROD_DIST_ID }} \\\\\n         \
  \     --paths \"/*\"\n    ```\n\n    ## Artifact Management\n\n    **Artifacts**\
  \ are the build outputs that get deployed (JARs, Docker images, compiled binaries,\
  \ etc.).\n\n    ### Best Practices\n\n    **1. Version artifacts**\n    ```bash\n\
  \    # Semantic versioning\n    myapp-1.2.3.jar\n\n    # Git commit hash\n    myapp-abc123f.jar\n\
  \n    # Build number\n    myapp-build-456.jar\n    ```\n\n    **2. Store artifacts\
  \ in registries**\n    ```yaml\n    # Docker registry\n    docker build -t myapp:${{\
  \ github.sha }} .\n    docker tag myapp:${{ github.sha }} myapp:latest\n    docker\
  \ push myapp:${{ github.sha }}\n    docker push myapp:latest\n    ```\n\n    **3.\
  \ Artifact retention**\n    ```yaml\n    # GitHub Actions - keep artifacts for 30\
  \ days\n    - name: Upload artifacts\n      uses: actions/upload-artifact@v3\n \
  \     with:\n        name: build\n        path: dist/\n        retention-days: 30\n\
  \    ```\n\n    **4. Artifact promotion**\n    ```\n    Development: myapp:dev-abc123\n\
  \    Staging:     myapp:staging-abc123\n    Production:  myapp:v1.2.3 (same image,\
  \ promoted)\n    ```\n\n    ## Environment Strategies\n\n    ### Typical Environment\
  \ Flow\n\n    ```\n    Development → Staging → Production\n    ```\n\n    ### 1.\
  \ Development Environment\n    **Purpose:** Developer testing and integration\n\n\
  \    ```yaml\n    environment: development\n    config:\n      - Auto-deploy on\
  \ every commit\n      - Debug logging enabled\n      - Relaxed security for testing\n\
  \      - Synthetic test data\n      - Single instance\n    ```\n\n    ### 2. Staging\
  \ Environment\n    **Purpose:** Pre-production validation\n\n    ```yaml\n    environment:\
  \ staging\n    config:\n      - Production-like configuration\n      - Real-world\
  \ data volume (sanitized)\n      - Performance testing\n      - QA validation\n\
  \      - Load balancing (2-3 instances)\n    ```\n\n    ### 3. Production Environment\n\
  \    **Purpose:** End users\n\n    ```yaml\n    environment: production\n    config:\n\
  \      - High availability (multi-AZ)\n      - Monitoring and alerting\n      -\
  \ Automatic scaling\n      - Backup and disaster recovery\n      - Security hardening\n\
  \    ```\n\n    ### Environment Configuration\n\n    **Use environment variables:**\n\
  \    ```yaml\n    # GitHub Actions environments\n    deploy:\n      runs-on: ubuntu-latest\n\
  \      environment: production\n      steps:\n        - name: Deploy\n         \
  \ env:\n            DATABASE_URL: ${{ secrets.DATABASE_URL }}\n            API_KEY:\
  \ ${{ secrets.API_KEY }}\n            LOG_LEVEL: ${{ vars.LOG_LEVEL }}\n       \
  \   run: ./deploy.sh\n    ```\n\n    **Environment-specific configs:**\n    ```yaml\n\
  \    # config/staging.yml\n    database:\n      host: staging-db.example.com\n \
  \     pool_size: 10\n    logging:\n      level: debug\n    features:\n      new_ui:\
  \ true\n\n    # config/production.yml\n    database:\n      host: prod-db.example.com\n\
  \      pool_size: 50\n    logging:\n      level: warn\n    features:\n      new_ui:\
  \ false\n    ```\n\n    ## CI/CD Best Practices\n\n    ### 1. Fast Feedback\n  \
  \  **Fail fast, fail early**\n\n    ```yaml\n    # Run fast tests first\n    jobs:\n\
  \      lint:\n        runs-on: ubuntu-latest\n        steps:\n          - run: npm\
  \ run lint  # 30 seconds\n\n      unit-tests:\n        runs-on: ubuntu-latest\n\
  \        steps:\n          - run: npm run test:unit  # 2 minutes\n\n      integration-tests:\n\
  \        needs: unit-tests  # Only run if unit tests pass\n        runs-on: ubuntu-latest\n\
  \        steps:\n          - run: npm run test:integration  # 10 minutes\n    ```\n\
  \n    ### 2. Keep Pipelines Fast\n    **Target: Under 10 minutes for CI**\n\n  \
  \  Strategies:\n    - Parallel test execution\n    - Incremental builds\n    - Caching\
  \ dependencies\n    - Test only changed code\n\n    ```yaml\n    # Cache dependencies\n\
  \    - name: Cache node modules\n      uses: actions/cache@v3\n      with:\n   \
  \     path: ~/.npm\n        key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json')\
  \ }}\n        restore-keys: |\n          ${{ runner.os }}-node-\n    ```\n\n   \
  \ ### 3. Automate Everything\n    **If you do it twice, automate it**\n\n    - Testing\n\
  \    - Code quality checks\n    - Security scanning\n    - Database migrations\n\
  \    - Documentation generation\n\n    ### 4. Make Pipelines Reproducible\n    **Same\
  \ code + same pipeline = same result**\n\n    ```yaml\n    # Pin versions\n    -\
  \ uses: actions/checkout@v3  # ✅ Specific version\n    - uses: actions/setup-node@v3\n\
  \      with:\n        node-version: '18.16.0'  # ✅ Exact version\n\n    # ❌ Avoid\n\
  \    - uses: actions/checkout@main  # Unpredictable\n    - uses: actions/setup-node@v3\n\
  \      with:\n        node-version: '18'  # Might get different minor versions\n\
  \    ```\n\n    ### 5. Secure Your Pipeline\n    **Protect secrets and credentials**\n\
  \n    ```yaml\n    # ✅ Use secrets\n    - name: Deploy\n      env:\n        AWS_ACCESS_KEY_ID:\
  \ ${{ secrets.AWS_ACCESS_KEY_ID }}\n        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY\
  \ }}\n      run: ./deploy.sh\n\n    # ❌ Never hardcode\n    - name: Deploy\n   \
  \   env:\n        AWS_ACCESS_KEY_ID: AKIAIOSFODNN7EXAMPLE  # BAD!\n      run: ./deploy.sh\n\
  \    ```\n\n    ### 6. Monitor Pipeline Health\n    **Track metrics:**\n    - Build\
  \ success rate\n    - Average build time\n    - Time to detect failures\n    - Deployment\
  \ frequency\n    - Mean time to recovery (MTTR)\n\n    ### 7. Keep main Branch Green\n\
  \    **main/master should always be deployable**\n\n    Strategies:\n    - Required\
  \ PR reviews\n    - Status checks must pass\n    - Protected branches\n    - Revert\
  \ quickly if broken\n\n    ```yaml\n    # Branch protection rules\n    protection:\n\
  \      required_reviews: 1\n      required_status_checks:\n        - ci/build\n\
  \        - ci/test\n        - ci/lint\n      enforce_admins: true\n    ```\n\n \
  \   ## Summary\n\n    **CI/CD Pipeline:**\n    ```\n    Code Commit\n      ↓\n \
  \   CI: Build + Test + Quality Checks\n      ↓\n    CD: Deploy to Staging\n    \
  \  ↓\n    Continuous Deployment: Auto-deploy to Production\n    (or manual approval\
  \ for Continuous Delivery)\n    ```\n\n    **Key Principles:**\n    1. **Automate**\
  \ - Build, test, and deploy automatically\n    2. **Fast feedback** - Fail fast,\
  \ notify quickly\n    3. **Reproducible** - Same input → same output\n    4. **Secure**\
  \ - Protect secrets and credentials\n    5. **Monitor** - Track pipeline health\
  \ and metrics\n    6. **Incremental** - Small, frequent changes\n    7. **Rollback**\
  \ - Always have an escape hatch\n\n    **Next:** We'll build complete CI/CD pipelines\
  \ with GitHub Actions, GitLab CI, and Jenkins."
exercises:
- type: mcq
  sequence_order: 1
  question: What is the key difference between Continuous Delivery and Continuous Deployment?
  options:
  - Continuous Delivery requires manual approval for production deployment while Continuous
    Deployment automatically deploys every passing build to production
  - Continuous Deployment is slower than Continuous Delivery
  - They are the same thing with different names
  - Continuous Delivery only works with Docker while Continuous Deployment works with
    all platforms
  correct_answer: Continuous Delivery requires manual approval for production deployment
    while Continuous Deployment automatically deploys every passing build to production
  explanation: 'Continuous Delivery and Continuous Deployment represent different
    levels of automation in the deployment pipeline. Continuous Delivery (CD): Automatically
    builds, tests, and prepares code for production deployment but requires manual
    approval before deploying to production. Process: Code commit → CI passes → build
    artifacts → deploy to staging → integration tests pass → ready for manual release
    to production. Human gatekeeper decides when to deploy (during business hours,
    after stakeholder approval, coordinated with marketing launch). Benefits: Deployment-ready
    code at all times, predictable release process, manual control over production
    timing, reduced risk through human oversight. Use cases: Enterprise applications
    requiring change approval boards, regulated industries (finance, healthcare) needing
    audit trails, applications with marketing-coordinated releases, teams building
    confidence in automation. Continuous Deployment: Fully automated deployment to
    production with NO manual approval - every commit that passes tests automatically
    goes live. Process: Code commit → CI passes → build artifacts → deploy to staging
    → automated tests pass → automatically deploy to production. Zero human intervention
    in deployment decision. Benefits: Fastest time to market (features reach users
    in minutes), smaller deployments (lower risk per change), immediate user feedback,
    forces excellent automated testing and monitoring. Trade-offs: Requires very high
    confidence in automated tests, comprehensive monitoring and alerting, feature flags
    for incomplete features, fast rollback procedures. Use cases: SaaS products with
    rapid iteration, tech companies with strong DevOps culture (Netflix, Facebook),
    internal tools with forgiving users, teams with excellent test coverage (>80%).
    Example: Facebook uses Continuous Deployment pushing code to production multiple
    times per day automatically. Banks use Continuous Delivery requiring manual approval
    due to regulatory requirements.'
  require_pass: true
- type: mcq
  sequence_order: 2
  question: Why should CI/CD pipelines "fail fast" by running quick tests before slow
    tests?
  options:
  - To provide faster feedback to developers and save compute resources by avoiding
    expensive test runs when basic checks fail
  - Fast tests are more accurate than slow tests
  - Slow tests should never be run in CI/CD
  - Fast tests are the only tests that matter
  correct_answer: To provide faster feedback to developers and save compute resources
    by avoiding expensive test runs when basic checks fail
  explanation: 'The "fail fast" principle is a critical CI/CD optimization that prioritizes
    developer productivity and resource efficiency. Traditional approach (bad): Run
    all tests sequentially - linting (30s) → unit tests (2min) → integration tests
    (10min) → E2E tests (30min). If linting fails, developer waits 42 minutes to
    discover a formatting error that could be caught in 30 seconds. Wasted 41.5 minutes
    of developer time plus CI compute resources. Fail fast approach (good): Run tests
    in order of speed and likelihood of failure. Stage 1 (parallel): Linting (30s)
    + format check (30s) → fails immediately if code style wrong. Stage 2: Unit tests
    (2min) → fails if business logic broken. Stage 3: Integration tests (10min) →
    only runs if unit tests pass. Stage 4: E2E tests (30min) → only runs if integration
    tests pass. Result: Developer gets feedback in 30s for 60% of failures (linting/format),
    2.5min for 30% (unit tests), 12.5min for 8% (integration), 42.5min for 2% (E2E).
    Average feedback time drops from 42min to <5min. Resource savings: If 60% fail
    at lint stage, save 60% × 42min × $0.10/hour = significant cost reduction. Implementation
    example: GitHub Actions jobs with needs dependency - lint job has no dependencies
    (runs immediately), unit-tests needs lint, integration-tests needs unit-tests,
    e2e-tests needs integration-tests. If lint fails, entire pipeline stops in 30s
    rather than wasting resources on subsequent stages. Additional benefits: (1) Faster
    iteration cycle - developers fix issues quickly instead of waiting, (2) Parallel
    execution - run fast independent checks simultaneously, (3) Cost optimization
    - expensive compute for E2E tests only used when necessary, (4) Psychological
    impact - quick feedback keeps developers in flow state. Real-world example: Team
    with 20 developers making 10 commits/day each. Before fail fast: 200 commits ×
    42min average = 140 hours CI time. After fail fast: 200 commits × 5min average
    = 16.7 hours CI time. Saved 123 hours daily of compute resources and developer
    waiting time.'
  require_pass: true
