slug: docker-build-building-images-from-dockerfile
title: 'Docker Build: Building Images from Dockerfile'
difficulty: easy
sequence_order: 1
estimated_minutes: 2
key_concepts: []
prerequisites: []
content_md: "# Docker Build: Building Images from Dockerfile \U0001F680\n\n# Mastering\
  \ docker build: Creating Custom Docker Images\n\n    ## What is docker build?\n\
  \    `docker build` creates Docker images from a Dockerfile and a build context.\
  \ This is how you package your applications into portable, reproducible containers\
  \ - transforming source code and dependencies into ready-to-run images.\n\n    ##\
  \ Why Building Images Matters\n    - **Customization**: Create images tailored to\
  \ your application needs\n    - **Reproducibility**: Same Dockerfile produces identical\
  \ images everywhere\n    - **Version Control**: Track image changes through Dockerfile\
  \ history\n    - **Automation**: Integrate into CI/CD pipelines for automated builds\n\
  \    - **Efficiency**: Layer caching speeds up repeated builds\n\n    ## Basic Syntax\n\
  \    ```bash\n    docker build [OPTIONS] PATH | URL | -\n    ```\n\n    ## Common\
  \ Use Cases\n\n    ### 1. Basic Build from Current Directory\n    ```bash\n    docker\
  \ build .\n    ```\n    Builds image using Dockerfile in current directory.\n\n\
  \    ### 2. Build and Tag Image\n    ```bash\n    docker build -t myapp:1.0 .\n\
  \    ```\n    Creates image with name and version tag.\n\n    ### 3. Build with\
  \ Custom Dockerfile\n    ```bash\n    docker build -f Dockerfile.prod -t myapp:prod\
  \ .\n    ```\n    Uses different Dockerfile for production builds.\n\n    ### 4.\
  \ Build with Build Arguments\n    ```bash\n    docker build --build-arg NODE_VERSION=14\
  \ -t myapp .\n    ```\n    Passes variables to Dockerfile during build.\n\n    ##\
  \ How Docker Build Works\n\n    ```\n    1. Read Dockerfile\n       ↓\n    2. Send\
  \ build context to Docker daemon\n       ↓\n    3. Execute each instruction sequentially\n\
  \       ↓\n    4. Create layer for each instruction\n       ↓\n    5. Cache layers\
  \ for reuse\n       ↓\n    6. Tag final image\n       ↓\n    7. Return image ID\n\
  \    ```\n\n    ## Build Context Explained\n\n    The build context is the set of\
  \ files Docker can access during build:\n    ```bash\n    docker build .\n     \
  \            └─ Build context (current directory)\n    ```\n\n    **Important**:\
  \ Large contexts slow builds. Use `.dockerignore` to exclude files!\n\n    ## Layer\
  \ Caching\n\n    Docker caches each layer. If nothing changes, cached layer is reused:\n\
  \    ```\n    Step 1/5 : FROM node:14        ← Using cache\n    Step 2/5 : COPY\
  \ package.json   ← Using cache\n    Step 3/5 : RUN npm install     ← Using cache\n\
  \    Step 4/5 : COPY . .            ← Changed! Rebuild from here\n    Step 5/5 :\
  \ CMD [\"node\", \"app\"] ← Rebuild\n    ```\n\n    ## Essential Build Options\n\
  \n    | Option | Description | Example |\n    |--------|-------------|---------|\n\
  \    | `-t` | Tag image with name:version | `docker build -t app:1.0 .` |\n    |\
  \ `-f` | Specify Dockerfile path | `docker build -f custom.Dockerfile .` |\n   \
  \ | `--build-arg` | Set build-time variables | `docker build --build-arg VERSION=1.0\
  \ .` |\n    | `--no-cache` | Build without using cache | `docker build --no-cache\
  \ .` |\n    | `--target` | Build specific stage in multi-stage | `docker build --target\
  \ production .` |\n\n    ## Multi-Stage Builds\n\n    Build multiple images in one\
  \ Dockerfile:\n    ```dockerfile\n    # Build stage\n    FROM node:14 AS builder\n\
  \    COPY . .\n    RUN npm install && npm run build\n\n    # Production stage\n\
  \    FROM node:14-alpine\n    COPY --from=builder /app/dist /app\n    CMD [\"node\"\
  , \"app\"]\n    ```\n\n    Build specific stage:\n    ```bash\n    docker build\
  \ --target builder -t myapp:build .\n    ```\n\n    ## Common Mistakes to Avoid\n\
  \n    1. **Large build context**: Sending unnecessary files slows builds\n    2.\
  \ **No .dockerignore**: Including node_modules, .git, etc.\n    3. **Poor layer\
  \ ordering**: Put frequently changing layers last\n    4. **Not using cache wisely**:\
  \ Copy package.json before source code\n    5. **Running as root**: Always specify\
  \ USER in Dockerfile\n\n    ## Optimizing Build Performance\n\n    ### Bad Layer\
  \ Order\n    ```dockerfile\n    FROM node:14\n    COPY . .              ← Changes\
  \ often, invalidates cache\n    RUN npm install       ← Reinstalls every time\n\
  \    ```\n\n    ### Good Layer Order\n    ```dockerfile\n    FROM node:14\n    COPY\
  \ package*.json ./ ← Rarely changes\n    RUN npm install       ← Cached until package.json\
  \ changes\n    COPY . .              ← Source changes don't affect npm install\n\
  \    ```\n\n    ## .dockerignore File\n\n    Exclude files from build context:\n\
  \    ```\n    node_modules\n    .git\n    .env\n    *.log\n    .DS_Store\n    README.md\n\
  \    ```\n\n    ## Build Arguments vs Environment Variables\n\n    **Build Arguments\
  \ (--build-arg)**\n    - Available only during build\n    - Set with ARG in Dockerfile\n\
  \    - Example: versions, build modes\n\n    **Environment Variables (ENV)**\n \
  \   - Available at runtime\n    - Set with ENV in Dockerfile\n    - Example: API\
  \ URLs, ports\n\n    ## Practical Build Patterns\n\n    ### Development Build\n\
  \    ```bash\n    docker build -t myapp:dev --target development .\n    ```\n\n\
  \    ### Production Build with Version\n    ```bash\n    docker build -t myapp:1.0.3\
  \ -t myapp:latest .\n    ```\n\n    ### Build with Secrets (BuildKit)\n    ```bash\n\
  \    DOCKER_BUILDKIT=1 docker build --secret id=npmrc,src=$HOME/.npmrc .\n    ```\n\
  \n    ## Troubleshooting Builds\n\n    ### Build Fails Midway\n    ```bash\n   \
  \ # Check intermediate containers\n    docker ps -a\n\n    # Debug failed layer\n\
  \    docker run -it <intermediate-container-id> sh\n    ```\n\n    ### Clear Build\
  \ Cache\n    ```bash\n    docker builder prune\n    ```\n\n    ### Verbose Build\
  \ Output\n    ```bash\n    docker build --progress=plain --no-cache .\n    ```\n\
  \n    ## Pro Tips\n\n    1. **Use specific base image tags**: `node:14.17-alpine`\
  \ not `node:latest`\n    2. **Leverage multi-stage builds**: Smaller production\
  \ images\n    3. **Order layers by change frequency**: Least to most frequent\n\
  \    4. **Use .dockerignore**: Essential for large projects\n    5. **Enable BuildKit**:\
  \ `export DOCKER_BUILDKIT=1` for better performance\n    6. **Tag semantic versions**:\
  \ `app:1.0.0`, `app:1.0`, `app:latest`\n\n    ## When to Use docker build\n\n  \
  \  - Creating custom application images\n    - Packaging microservices\n    - Building\
  \ CI/CD pipeline artifacts\n    - Creating development environments\n    - Preparing\
  \ deployment artifacts\n\n## Syntax/Command\n\n```bash\ndocker build -t myapp:1.0\
  \ .\n```\n\n## Example\n\n```bash\ndocker build .\n```\n\n## Key Points\n\n- Basic\
  \ build: docker build .\n\n- Tag image: docker build -t myapp:1.0 .\n\n- Custom\
  \ Dockerfile: docker build -f Dockerfile.prod ."
exercises:
- type: terminal
  problem_statement: Build a Docker image from the Dockerfile in the current directory and tag it as myapp:1.0
  expected_output: Successfully built image with tag myapp:1.0
  language: bash
  starter_code: "# Build and tag Docker image\n"
  sequence_order: 1
  command: docker build -t myapp:1.0 .
  description: Build a Docker image from Dockerfile in current directory and tag it as myapp:1.0
  hints:
  - 'Basic build: docker build .'
  - 'Tag image: docker build -t myapp:1.0 .'
  - 'Custom Dockerfile: docker build -f Dockerfile.prod .'
  validation:
    must_not_include:
    - Error
    - 'panic:'
  timeout_sec: 60
  require_pass: true
- type: sandbox
  sequence_order: 99
  hints:
  - Run under CPU pressure to surface leaks or races
  - Keep commands idempotent in CI
  validation:
    must_not_include:
    - Error
    - 'panic:'
  timeout_sec: 60
  require_pass: true
- type: mcq
  sequence_order: 2
  question: What is the purpose of layer caching in Docker builds?
  options:
  - To reuse unchanged layers and speed up subsequent builds
  - To compress the final image size
  - To store images in a remote registry
  - To run multiple builds in parallel
  correct_answer: To reuse unchanged layers and speed up subsequent builds
  explanation: "Docker caches each layer during build. When rebuilding, if a layer's inputs haven't changed (same Dockerfile instruction and context), Docker reuses the cached layer instead of rebuilding it. This dramatically speeds up builds. Invalidating cache happens when an instruction changes or files it depends on change."
  require_pass: true
