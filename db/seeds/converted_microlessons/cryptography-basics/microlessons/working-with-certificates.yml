slug: working-with-certificates
title: Working with Certificates
difficulty: easy
sequence_order: 11
estimated_minutes: 2
key_concepts: []
prerequisites: []
content_md: "# Working with Certificates \U0001F680\n\n# Working with Certificates\n\
  \n    ## Generating Self-Signed Certificates\n\n    ### Quick Self-Signed Certificate\n\
  \    ```bash\n    # Generate private key and certificate in one command\n    openssl\
  \ req -x509 -newkey rsa:4096 -nodes \\\\\n      -keyout server.key \\\\\n      -out\
  \ server.crt \\\\\n      -days 365 \\\\\n      -subj \"/CN=localhost\"\n    ```\n\
  \n    ### Step-by-Step Certificate Generation\n\n    ```bash\n    # 1. Generate\
  \ private key\n    openssl genrsa -out server.key 2048\n\n    # 2. Create certificate\
  \ signing request (CSR)\n    openssl req -new -key server.key -out server.csr \\\
  \\\n      -subj \"/C=US/ST=CA/L=SF/O=MyOrg/CN=example.com\"\n\n    # 3. Self-sign\
  \ the certificate\n    openssl x509 -req -days 365 \\\\\n      -in server.csr \\\
  \\\n      -signkey server.key \\\\\n      -out server.crt\n    ```\n\n    ## Inspecting\
  \ Certificates\n\n    ### View Certificate Details\n    ```bash\n    # View certificate\
  \ contents\n    openssl x509 -in server.crt -text -noout\n\n    # Check certificate\
  \ dates\n    openssl x509 -in server.crt -noout -dates\n\n    # View subject and\
  \ issuer\n    openssl x509 -in server.crt -noout -subject -issuer\n\n    # Check\
  \ certificate fingerprint\n    openssl x509 -in server.crt -noout -fingerprint -sha256\n\
  \    ```\n\n    ### View Remote Server Certificate\n    ```bash\n    # Check server's\
  \ certificate\n    openssl s_client -connect example.com:443 -servername example.com\n\
  \n    # Get certificate expiry\n    echo | openssl s_client -connect example.com:443\
  \ 2>/dev/null | \\\\\n      openssl x509 -noout -dates\n    ```\n\n    ## Certificate\
  \ Formats\n\n    ### PEM (Privacy Enhanced Mail)\n    ```\n    -----BEGIN CERTIFICATE-----\n\
  \    Base64 encoded data\n    -----END CERTIFICATE-----\n    ```\n    - Most common\
  \ format\n    - Text-based\n    - Extensions: `.pem`, `.crt`, `.cer`, `.key`\n\n\
  \    ### DER (Distinguished Encoding Rules)\n    - Binary format\n    - Extensions:\
  \ `.der`, `.cer`\n\n    ```bash\n    # Convert PEM to DER\n    openssl x509 -in\
  \ cert.pem -outform DER -out cert.der\n\n    # Convert DER to PEM\n    openssl x509\
  \ -in cert.der -inform DER -out cert.pem\n    ```\n\n    ### PKCS#12 / PFX\n   \
  \ - Bundle: certificate + private key + chain\n    - Password protected\n    - Extension:\
  \ `.p12`, `.pfx`\n\n    ```bash\n    # Create PKCS#12 bundle\n    openssl pkcs12\
  \ -export \\\\\n      -in server.crt \\\\\n      -inkey server.key \\\\\n      -out\
  \ server.p12 \\\\\n      -name \"My Server Cert\"\n\n    # Extract from PKCS#12\n\
  \    openssl pkcs12 -in server.p12 -out server.pem -nodes\n    ```\n\n    ## Testing\
  \ HTTPS\n\n    ### Using curl\n    ```bash\n    # Test HTTPS endpoint\n    curl\
  \ https://example.com\n\n    # Show certificate details\n    curl -vI https://example.com\n\
  \n    # Ignore certificate validation (testing only!)\n    curl -k https://localhost:8443\n\
  \n    # Use specific CA certificate\n    curl --cacert custom-ca.crt https://internal.example.com\n\
  \    ```\n\n    ### Using wget\n    ```bash\n    # Download over HTTPS\n    wget\
  \ https://example.com/file.txt\n\n    # Ignore certificate (testing only!)\n   \
  \ wget --no-check-certificate https://localhost:8443/file.txt\n    ```\n\n    ##\
  \ Common Certificate Errors\n\n    ### 1. Certificate Expired\n    ```\n    ERROR:\
  \ certificate has expired\n    ```\n    - Certificate validity period has passed\n\
  \    - Renew certificate\n\n    ### 2. Hostname Mismatch\n    ```\n    ERROR: certificate\
  \ subject name does not match target host name\n    ```\n    - Certificate CN/SAN\
  \ doesn't match domain\n    - Need new certificate for correct domain\n\n    ###\
  \ 3. Self-Signed Certificate\n    ```\n    ERROR: self signed certificate\n    ```\n\
  \    - Certificate not signed by trusted CA\n    - Add certificate to trust store,\
  \ or use --insecure (dev only)\n\n    ### 4. Untrusted CA\n    ```\n    ERROR: unable\
  \ to get local issuer certificate\n    ```\n    - Issuing CA not in trust store\n\
  \    - Add CA certificate to system trust store\n\n    ## Certificate Best Practices\n\
  \n    1. **Use 2048-bit or higher** RSA keys (or Ed25519)\n    2. **Keep private\
  \ keys secure** - never commit to git, use 600 permissions\n    3. **Use strong\
  \ Subject Alternative Names (SANs)** for multiple domains\n    4. **Set appropriate\
  \ validity periods** (90 days recommended with auto-renewal)\n    5. **Use Let's\
  \ Encrypt** for public-facing services\n    6. **Monitor expiration dates** - automate\
  \ renewals\n    7. **Use TLS 1.2 or 1.3 only** - disable older versions"
exercises:
  - type: multiple_choice_question
    sequence_order: 1
    question: "What is the difference between a self-signed certificate and a CA-signed certificate?"
    options:
      - "Self-signed certificates are more secure"
      - "CA-signed certificates are signed by a trusted Certificate Authority, while self-signed certificates are signed by the owner"
      - "Self-signed certificates work in production, CA-signed don't"
      - "CA-signed certificates are free, self-signed certificates cost money"
    correct_answer: "CA-signed certificates are signed by a trusted Certificate Authority, while self-signed certificates are signed by the owner"
    explanation: "The fundamental difference is trust and validation. A CA-signed certificate is issued and digitally signed by a trusted Certificate Authority (CA) like Let's Encrypt, DigiCert, or Comodo. Browsers and operating systems come pre-configured to trust these CAs, so certificates they sign are automatically trusted without user intervention. When you visit an HTTPS site with a CA-signed certificate, your browser silently validates it and displays a lock icon. A self-signed certificate is created and signed by the certificate owner themselves, not a trusted third party. Browsers don't trust self-signed certificates by default and will display security warnings about the connection not being private. Self-signed certificates are appropriate for development, testing, and internal services where you can manually distribute trust, but should not be used for public-facing websites. They provide encryption (protecting confidentiality) but don't provide trusted authentication (proving identity). Let's Encrypt offers free CA-signed certificates with automated renewal, making self-signed certificates unnecessary for most production use cases. The security of the encryption itself is equivalent, but CA-signed certificates provide the additional critical property of verified identity through the chain of trust."
    require_pass: true
  - type: multiple_choice_question
    sequence_order: 2
    question: "What does the PEM certificate format look like?"
    options:
      - "Binary data that cannot be viewed in a text editor"
      - "Text format with base64 encoded data between BEGIN and END markers"
      - "Encrypted format that requires a password to view"
      - "JSON format with certificate fields"
    correct_answer: "Text format with base64 encoded data between BEGIN and END markers"
    explanation: "PEM (Privacy Enhanced Mail) is the most common certificate format and is text-based, making it easy to work with, view, and transfer. PEM certificates contain base64-encoded data wrapped between header and footer markers like '-----BEGIN CERTIFICATE-----' and '-----END CERTIFICATE-----'. The base64 encoding converts binary certificate data into printable ASCII characters that can be safely copied, pasted, emailed, and stored in text files without corruption. You can open PEM files in any text editor and see the encoded content. PEM format is used for certificates (.crt, .pem, .cer), private keys (.key, .pem), and certificate signing requests (.csr). Multiple PEM objects can be concatenated in a single file, which is common for certificate chains. This contrasts with DER format, which is binary and cannot be viewed in a text editor. PEM's text-based nature makes it preferred for most applications and is the default format for OpenSSL commands, web servers (nginx, Apache), and certificate management. While the content is encoded, PEM files aren't encrypted by default (though private keys can be encrypted with a passphrase). The format's ubiquity and ease of use make it the standard for SSL/TLS certificate management."
    require_pass: true
  - type: multiple_choice_question
    sequence_order: 3
    question: "What does the command 'openssl x509 -in cert.crt -noout -dates' show you?"
    options:
      - "The certificate's encryption algorithm"
      - "The certificate's validity period (start and end dates)"
      - "The certificate's file size"
      - "The certificate's serial number"
    correct_answer: "The certificate's validity period (start and end dates)"
    explanation: "This OpenSSL command displays the certificate's validity period, showing when the certificate becomes valid (notBefore) and when it expires (notAfter). This is critical information for certificate management because expired certificates cause connection failures and security warnings. The command breaks down as follows: 'openssl x509' operates on X.509 certificates (the standard format), '-in cert.crt' specifies the certificate file to examine, '-noout' suppresses the default output of the encoded certificate, and '-dates' requests display of the validity dates. The output shows two timestamps indicating the certificate's lifetime. Monitoring certificate expiration is essential for operational security â€“ expired certificates break services and create security vulnerabilities if administrators disable validation to work around them. Many organizations use automated monitoring to alert when certificates approach expiration. Let's Encrypt certificates expire after 90 days, encouraging automation and regular renewal. You can also use '-enddate' to see only the expiration date, or '-text' to see all certificate details including subject, issuer, public key, and signature. Regular expiration checking, ideally automated, prevents outages and security incidents caused by unexpected certificate expiration."
    require_pass: true
