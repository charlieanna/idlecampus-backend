slug: managing-secrets-securely
title: Managing Secrets Securely
difficulty: easy
sequence_order: 13
estimated_minutes: 2
key_concepts: []
prerequisites: []
content_md: "# Managing Secrets Securely \U0001F680\n\n# Managing Secrets Securely\n\
  \n    Secrets include passwords, API keys, tokens, certificates - anything that\
  \ grants access.\n\n    ## Common Mistakes ❌\n\n    ### 1. Hardcoding Secrets\n\
  \    ```python\n    # BAD - Never do this!\n    API_KEY = \"sk_live_abc123xyz789\"\
  \n    DATABASE_URL = \"postgres://user:password@host/db\"\n    ```\n\n    ### 2.\
  \ Committing Secrets to Git\n    ```bash\n    # BAD - Secrets in repository\n  \
  \  git add config.json\n    git commit -m \"Add API keys\"  # Now in git history\
  \ forever!\n    ```\n\n    ### 3. Logging Secrets\n    ```bash\n    # BAD - Secrets\
  \ in logs\n    echo \"Connecting with password: $DB_PASSWORD\"\n    ```\n\n    ###\
  \ 4. Sharing Secrets via Email/Chat\n    Insecure channels = compromised secrets.\n\
  \n    ## Environment Variables\n\n    ### Setting Environment Variables\n    ```bash\n\
  \    # Temporary (current session only)\n    export DATABASE_URL=\"postgres://localhost/mydb\"\
  \n    export API_KEY=\"secret_key_here\"\n\n    # In application\n    python app.py\n\
  \    ```\n\n    ### .env Files\n    ```bash\n    # .env file (NEVER commit this!)\n\
  \    DATABASE_URL=postgres://user:pass@localhost/db\n    API_KEY=sk_live_abc123\n\
  \    STRIPE_SECRET=sk_test_xyz789\n    JWT_SECRET=my_super_secret_key\n    ```\n\
  \n    **Always add .env to .gitignore:**\n    ```bash\n    echo \".env\" >> .gitignore\n\
  \    ```\n\n    ### .env.example Template\n    ```bash\n    # .env.example (safe\
  \ to commit)\n    DATABASE_URL=postgres://user:password@localhost/dbname\n    API_KEY=your_api_key_here\n\
  \    STRIPE_SECRET=your_stripe_secret_key\n    JWT_SECRET=generate_a_random_secret\n\
  \    ```\n\n    ## Docker Secrets\n\n    ### Environment Variables in Docker\n \
  \   ```bash\n    # Pass at runtime\n    docker run -e DATABASE_URL=\"postgres://...\"\
  \ myapp\n\n    # From .env file\n    docker run --env-file .env myapp\n    ```\n\
  \n    ### Docker Compose\n    ```yaml\n    version: '3.8'\n    services:\n     \
  \ app:\n        image: myapp\n        environment:\n          - DATABASE_URL=${DATABASE_URL}\n\
  \          - API_KEY=${API_KEY}\n        # Or use env_file\n        env_file:\n\
  \          - .env\n    ```\n\n    ### Docker Swarm Secrets\n    ```bash\n    # Create\
  \ secret\n    echo \"my_secret_password\" | docker secret create db_password -\n\
  \n    # Use in service\n    docker service create \\\\\n      --name myapp \\\\\n\
  \      --secret db_password \\\\\n      myimage\n\n    # Access in container: /run/secrets/db_password\n\
  \    ```\n\n    ## Kubernetes Secrets\n\n    ### Create Secret\n    ```bash\n  \
  \  # From literal\n    kubectl create secret generic db-creds \\\\\n      --from-literal=username=admin\
  \ \\\\\n      --from-literal=password=secret123\n\n    # From file\n    kubectl\
  \ create secret generic api-keys \\\\\n      --from-file=api-key.txt\n\n    # From\
  \ .env file\n    kubectl create secret generic app-secrets --from-env-file=.env\n\
  \    ```\n\n    ### Use Secret in Pod\n    ```yaml\n    apiVersion: v1\n    kind:\
  \ Pod\n    metadata:\n      name: myapp\n    spec:\n      containers:\n      - name:\
  \ app\n        image: myapp:latest\n        env:\n        - name: DB_PASSWORD\n\
  \          valueFrom:\n            secretKeyRef:\n              name: db-creds\n\
  \              key: password\n        volumeMounts:\n        - name: secrets-volume\n\
  \          mountPath: /etc/secrets\n          readOnly: true\n      volumes:\n \
  \     - name: secrets-volume\n        secret:\n          secretName: api-keys\n\
  \    ```\n\n    ## Secrets Management Tools\n\n    ### HashiCorp Vault\n    Industry\
  \ standard for secrets management.\n\n    ```bash\n    # Start Vault dev server\n\
  \    vault server -dev\n\n    # Store secret\n    vault kv put secret/myapp/db password=\"\
  secret123\" username=\"admin\"\n\n    # Read secret\n    vault kv get secret/myapp/db\n\
  \n    # Use in application\n    export VAULT_ADDR='http://127.0.0.1:8200'\n    export\
  \ VAULT_TOKEN='dev-token'\n    vault kv get -field=password secret/myapp/db\n  \
  \  ```\n\n    ### AWS Secrets Manager\n    ```bash\n    # Store secret\n    aws\
  \ secretsmanager create-secret \\\\\n      --name myapp/db \\\\\n      --secret-string\
  \ '{\"username\":\"admin\",\"password\":\"secret\"}'\n\n    # Retrieve secret\n\
  \    aws secretsmanager get-secret-value --secret-id myapp/db\n    ```\n\n    ###\
  \ Azure Key Vault\n    ```bash\n    # Create secret\n    az keyvault secret set\
  \ \\\\\n      --vault-name myvault \\\\\n      --name db-password \\\\\n      --value\
  \ \"secret123\"\n\n    # Get secret\n    az keyvault secret show --vault-name myvault\
  \ --name db-password\n    ```\n\n    ## Best Practices\n\n    ### 1. Never Commit\
  \ Secrets\n    - Use .gitignore for .env files\n    - Scan repos: `git-secrets`,\
  \ `truffleHog`\n    - Use pre-commit hooks\n\n    ### 2. Rotate Secrets Regularly\n\
  \    - API keys: every 90 days\n    - Passwords: every 60-90 days\n    - Certificates:\
  \ before expiry\n\n    ### 3. Principle of Least Privilege\n    - Grant minimum\
  \ permissions needed\n    - Separate dev/staging/prod secrets\n    - Use service\
  \ accounts, not personal credentials\n\n    ### 4. Encrypt at Rest\n    - Database\
  \ encryption\n    - Encrypted filesystems\n    - Secrets encrypted in etcd (Kubernetes)\n\
  \n    ### 5. Audit Access\n    - Log who accessed which secrets\n    - Monitor for\
  \ anomalies\n    - Set up alerts for unauthorized access\n\n    ### 6. Use Secure\
  \ Channels\n    - Share secrets via encrypted tools\n    - Use password managers\
  \ (1Password, LastPass, Bitwarden)\n    - Never email/Slack secrets in plain text\n\
  \n    ## Emergency Response\n\n    ### If Secret is Compromised:\n    1. **Rotate\
  \ immediately** - generate new secret\n    2. **Revoke old secret** - invalidate\
  \ compromised credential\n    3. **Audit access** - check who used the secret\n\
  \    4. **Update all systems** - deploy new secret\n    5. **Investigate** - how\
  \ was it compromised?\n    6. **Document** - post-mortem, lessons learned"
exercises:
  - type: multiple_choice_question
    sequence_order: 1
    question: "Why should you never commit a .env file to Git?"
    options:
      - "Because it makes the repository too large"
      - "Because it will cause merge conflicts"
      - "Because secrets in Git history remain forever and can be accessed by anyone with repository access"
      - "Because .env files don't work in production"
    correct_answer: "Because secrets in Git history remain forever and can be accessed by anyone with repository access"
    explanation: "Once a file is committed to Git, it becomes part of the repository's permanent history. Even if you delete the file in a later commit, it remains accessible in the Git history. This means any secrets (API keys, passwords, database credentials) committed to Git can be extracted by anyone who gains access to the repository, including through historical commits. Attackers often scan public repositories and their complete histories looking for accidentally committed secrets. Many security breaches have occurred because developers committed .env files containing production credentials. To prevent this, always add .env to your .gitignore file before making any commits. Use .env.example files with placeholder values that are safe to commit, showing what variables are needed without exposing actual secrets. If you accidentally commit secrets, simply deleting the file isn't enough – you must rotate the compromised secrets immediately, use git filter-branch or BFG Repo-Cleaner to remove them from history, and potentially treat the repository as compromised. Prevention through proper .gitignore configuration is far better than remediation."
    require_pass: true
  - type: multiple_choice_question
    sequence_order: 2
    question: "What is the recommended approach for sharing secrets between team members?"
    options:
      - "Send them via email for documentation"
      - "Post them in team Slack channels"
      - "Use encrypted tools like password managers or secrets management systems"
      - "Include them in code comments"
    correct_answer: "Use encrypted tools like password managers or secrets management systems"
    explanation: "Secrets should always be shared through encrypted channels designed for secret management, never through general communication tools like email or Slack. Enterprise password managers like 1Password, LastPass, or Bitwarden provide secure sharing features with encryption, access control, and audit logs. For infrastructure secrets, use dedicated secrets management systems like HashiCorp Vault, AWS Secrets Manager, Azure Key Vault, or Google Cloud Secret Manager. These tools provide encryption at rest and in transit, fine-grained access control, automatic rotation, versioning, and comprehensive audit trails. Email and chat applications lack these security features and often store messages in plain text on servers, creating multiple copies that can be compromised. Additionally, they don't provide access revocation when team members leave or role-based access control. Secrets management tools also enable the principle of least privilege, allowing you to grant exactly the access needed for specific roles. They typically integrate with CI/CD pipelines and deployment systems, enabling automated secure secret injection without human handling. Proper secret sharing infrastructure is essential for maintaining security as teams scale."
    require_pass: true
  - type: multiple_choice_question
    sequence_order: 3
    question: "What should you do immediately if a secret is compromised?"
    options:
      - "Change the password in the .env file and recommit"
      - "Rotate the secret immediately and revoke the old one"
      - "Wait until the next scheduled rotation period"
      - "Just delete the secret from the repository"
    correct_answer: "Rotate the secret immediately and revoke the old one"
    explanation: "When a secret is compromised, immediate action is critical. First, generate a new secret to replace the compromised one. Second, revoke or invalidate the old secret to prevent its use. Third, update all systems and applications that use this secret with the new value. Fourth, audit access logs to determine who may have used the compromised secret and what they accessed. Fifth, investigate how the compromise occurred to prevent recurrence. Sixth, document the incident for post-mortem analysis. Simply changing it in configuration files isn't enough if the old secret remains valid – attackers who obtained it can continue using it. Waiting for scheduled rotation gives attackers time to exploit the secret. Deleting from the repository doesn't help if the secret was already exposed, as it's still in Git history and may have been copied by attackers. Time is critical in incident response: every minute the compromised secret remains valid represents potential unauthorized access to your systems. Many organizations maintain runbooks for secret rotation procedures to ensure rapid response. Consider the compromise as a potential security breach requiring full incident response protocols, not just a configuration change."
    require_pass: true
