slug: lesson-9
title: Lesson 9
difficulty: easy
sequence_order: 9
estimated_minutes: 2
key_concepts: []
prerequisites: []
content_md: "# Microlesson \U0001F680\n\n# Introduction to Channels\n\n    ### What\
  \ is a Channel?\n\n    A **channel** is a typed pipe through which you can send\
  \ and receive values between goroutines. It's Go's way of **safely sharing data**\
  \ between concurrent code.\n\n    **Think of it as:**\n    - A pipe/tube connecting\
  \ goroutines\n    - A message queue\n    - A safe way to communicate\n\n    **The\
  \ golden rule:** \"Don't communicate by sharing memory; share memory by communicating.\"\
  \n\n    ### Why Channels?\n\n    **The Problem (shared memory):**\n    ```go\n \
  \   var counter int  // Shared variable\n\n    go func() { counter++ }()  // Goroutine\
  \ 1\n    go func() { counter++ }()  // Goroutine 2\n    // RACE CONDITION! Unsafe!\n\
  \    ```\n\n    **The Solution (channels):**\n    ```go\n    ch := make(chan int)\n\
  \n    go func() { ch <- 1 }()  // Send to channel\n    value := <-ch           \
  \ // Receive from channel\n    // Safe! No race conditions!\n    ```\n\n    ###\
  \ Creating Channels\n\n    **Syntax:**\n    ```go\n    ch := make(chan Type)  //\
  \ Unbuffered channel\n    ch := make(chan Type, capacity)  // Buffered channel\n\
  \    ```\n\n    **Examples:**\n    ```go\n    messages := make(chan string)    \
  \   // String channel\n    numbers := make(chan int)           // Int channel\n\
  \    results := make(chan bool, 10)      // Buffered channel (capacity 10)\n   \
  \ ```\n\n    ### Sending and Receiving\n\n    **Sending (arrow points INTO channel):**\n\
  \    ```go\n    ch <- value  // Send value to channel\n    ```\n\n    **Receiving\
  \ (arrow points OUT OF channel):**\n    ```go\n    value := <-ch  // Receive from\
  \ channel\n    ```\n\n    **Complete example:**\n    ```go\n    package main\n\n\
  \    import \"fmt\"\n\n    func main() {\n        messages := make(chan string)\n\
  \n        // Send in goroutine\n        go func() {\n            messages <- \"\
  Hello from goroutine!\"\n        }()\n\n        // Receive in main\n        msg\
  \ := <-messages\n        fmt.Println(msg)  // \"Hello from goroutine!\"\n    }\n\
  \    ```\n\n    ### Unbuffered vs Buffered Channels\n\n    **Unbuffered Channel\
  \ (synchronous):**\n    ```go\n    ch := make(chan int)  // No buffer\n    ```\n\
  \n    **Behavior:**\n    - Sender BLOCKS until receiver is ready\n    - Receiver\
  \ BLOCKS until sender sends\n    - Synchronization point (handshake)\n\n    **Example:**\n\
  \    ```go\n    ch := make(chan int)\n\n    go func() {\n        fmt.Println(\"\
  Sending...\")\n        ch <- 42  // Blocks until someone receives\n        fmt.Println(\"\
  Sent!\")\n    }()\n\n    time.Sleep(2 * time.Second)\n    fmt.Println(\"Receiving...\"\
  )\n    value := <-ch  // Unblocks sender\n    fmt.Println(\"Received:\", value)\n\
  \n    // Output:\n    // Sending...\n    // (2 second pause)\n    // Receiving...\n\
  \    // Sent!\n    // Received: 42\n    ```\n\n    **Buffered Channel (asynchronous):**\n\
  \    ```go\n    ch := make(chan int, 3)  // Buffer of 3\n    ```\n\n    **Behavior:**\n\
  \    - Sender only blocks when buffer is FULL\n    - Receiver only blocks when buffer\
  \ is EMPTY\n    - Can send multiple values without receiver\n\n    **Example:**\n\
  \    ```go\n    ch := make(chan int, 2)  // Buffer size 2\n\n    ch <- 1  // Doesn't\
  \ block (buffer has space)\n    ch <- 2  // Doesn't block (buffer full now)\n  \
  \  // ch <- 3  // Would block! Buffer full\n\n    fmt.Println(<-ch)  // 1\n    fmt.Println(<-ch)\
  \  // 2\n    ```\n\n    ### Channel Directions\n\n    **Bi-directional (default):**\n\
  \    ```go\n    ch := make(chan int)  // Can send AND receive\n    ```\n\n    **Send-only:**\n\
  \    ```go\n    func sendOnly(ch chan<- int) {\n        ch <- 42  // Can send\n\
  \        // value := <-ch  // ERROR: can't receive\n    }\n    ```\n\n    **Receive-only:**\n\
  \    ```go\n    func receiveOnly(ch <-chan int) {\n        value := <-ch  // Can\
  \ receive\n        // ch <- 42  // ERROR: can't send\n    }\n    ```\n\n    **Why\
  \ use directional channels?**\n    - Type safety (compiler enforces correct usage)\n\
  \    - Clear intent (function signature shows behavior)\n    - Prevent mistakes\n\
  \n    **Complete example:**\n    ```go\n    func producer(ch chan<- int) {  // Send-only\n\
  \        for i := 0; i < 5; i++ {\n            ch <- i\n        }\n        close(ch)\n\
  \    }\n\n    func consumer(ch <-chan int) {  // Receive-only\n        for value\
  \ := range ch {\n            fmt.Println(\"Received:\", value)\n        }\n    }\n\
  \n    func main() {\n        ch := make(chan int)  // Bi-directional\n        go\
  \ producer(ch)       // Implicitly converts to send-only\n        consumer(ch) \
  \         // Implicitly converts to receive-only\n    }\n    ```\n\n    ### Closing\
  \ Channels\n\n    **Why close channels?**\n    - Signal \"no more values will be\
  \ sent\"\n    - Allow range loops to terminate\n    - Prevent goroutine leaks\n\n\
  \    **How to close:**\n    ```go\n    close(ch)  // Only sender should close!\n\
  \    ```\n\n    ⚠️ **Rules:**\n    1. **Only sender closes** (not receiver)\n  \
  \  2. **Never send on closed channel** (panic!)\n    3. **Can receive from closed\
  \ channel** (gets zero value)\n\n    **Detecting closed channels:**\n    ```go\n\
  \    value, ok := <-ch\n    if !ok {\n        fmt.Println(\"Channel closed!\")\n\
  \    }\n    ```\n\n    **Using range (stops when channel closes):**\n    ```go\n\
  \    for value := range ch {\n        fmt.Println(value)\n    }\n    // Loop exits\
  \ when ch is closed\n    ```\n\n    **Complete example:**\n    ```go\n    func generator(ch\
  \ chan int) {\n        for i := 0; i < 5; i++ {\n            ch <- i\n        }\n\
  \        close(ch)  // Signal done\n    }\n\n    func main() {\n        ch := make(chan\
  \ int)\n        go generator(ch)\n\n        for value := range ch {  // Receives\
  \ until closed\n            fmt.Println(value)\n        }\n        fmt.Println(\"\
  Channel closed, loop exited\")\n    }\n    ```\n\n    ### Select Statement: Multiplexing\
  \ Channels\n\n    **What is select?**\n    Like a `switch` for channels - waits\
  \ on multiple channel operations.\n\n    **Basic syntax:**\n    ```go\n    select\
  \ {\n    case msg := <-ch1:\n        fmt.Println(\"Received from ch1:\", msg)\n\
  \    case msg := <-ch2:\n        fmt.Println(\"Received from ch2:\", msg)\n    case\
  \ ch3 <- value:\n        fmt.Println(\"Sent to ch3\")\n    default:\n        fmt.Println(\"\
  No channel ready\")\n    }\n    ```\n\n    **Example: Timeout pattern:**\n    ```go\n\
  \    select {\n    case result := <-ch:\n        fmt.Println(\"Got result:\", result)\n\
  \    case <-time.After(1 * time.Second):\n        fmt.Println(\"Timeout!\")\n  \
  \  }\n    ```\n\n    **Example: Non-blocking receive:**\n    ```go\n    select {\n\
  \    case msg := <-ch:\n        fmt.Println(\"Received:\", msg)\n    default:\n\
  \        fmt.Println(\"No message available\")\n    }\n    ```\n\n    **Example:\
  \ Fan-in (merge multiple channels):**\n    ```go\n    func fanIn(ch1, ch2 <-chan\
  \ int) <-chan int {\n        out := make(chan int)\n        go func() {\n      \
  \      for {\n                select {\n                case v := <-ch1:\n     \
  \               out <- v\n                case v := <-ch2:\n                   \
  \ out <- v\n                }\n            }\n        }()\n        return out\n\
  \    }\n    ```\n\n    ### Common Channel Patterns\n\n    **1. Worker Pool:**\n\
  \    ```go\n    func worker(id int, jobs <-chan int, results chan<- int) {\n   \
  \     for job := range jobs {\n            fmt.Printf(\"Worker %d processing job\
  \ %d\\\\n\", id, job)\n            results <- job * 2\n        }\n    }\n\n    func\
  \ main() {\n        jobs := make(chan int, 100)\n        results := make(chan int,\
  \ 100)\n\n        // Start 3 workers\n        for w := 1; w <= 3; w++ {\n      \
  \      go worker(w, jobs, results)\n        }\n\n        // Send jobs\n        for\
  \ j := 1; j <= 9; j++ {\n            jobs <- j\n        }\n        close(jobs)\n\
  \n        // Collect results\n        for a := 1; a <= 9; a++ {\n            <-results\n\
  \        }\n    }\n    ```\n\n    **2. Pipeline:**\n    ```go\n    func generator(nums\
  \ ...int) <-chan int {\n        out := make(chan int)\n        go func() {\n   \
  \         for _, n := range nums {\n                out <- n\n            }\n  \
  \          close(out)\n        }()\n        return out\n    }\n\n    func square(in\
  \ <-chan int) <-chan int {\n        out := make(chan int)\n        go func() {\n\
  \            for n := range in {\n                out <- n * n\n            }\n\
  \            close(out)\n        }()\n        return out\n    }\n\n    func main()\
  \ {\n        // Set up pipeline: generate -> square\n        for n := range square(generator(2,\
  \ 3, 4)) {\n            fmt.Println(n)  // 4, 9, 16\n        }\n    }\n    ```\n\
  \n    **3. Done channel (cancellation):**\n    ```go\n    func worker(done <-chan\
  \ bool) {\n        for {\n            select {\n            case <-done:\n     \
  \           fmt.Println(\"Worker stopping\")\n                return\n         \
  \   default:\n                fmt.Println(\"Working...\")\n                time.Sleep(500\
  \ * time.Millisecond)\n            }\n        }\n    }\n\n    func main() {\n  \
  \      done := make(chan bool)\n        go worker(done)\n\n        time.Sleep(2\
  \ * time.Second)\n        close(done)  // Signal worker to stop\n        time.Sleep(1\
  \ * time.Second)\n    }\n    ```\n\n    ### Nil Channels\n\n    **What happens with\
  \ nil channels?**\n    - Send on nil channel: **blocks forever**\n    - Receive\
  \ on nil channel: **blocks forever**\n\n    **Why is this useful?**\n    Disable\
  \ a case in select:\n\n    ```go\n    var ch1, ch2 chan int  // nil channels\n\n\
  \    select {\n    case <-ch1:  // Disabled (nil channel)\n        fmt.Println(\"\
  ch1\")\n    case <-ch2:  // Disabled (nil channel)\n        fmt.Println(\"ch2\"\
  )\n    }\n    // select blocks forever!\n    ```\n\n    **Useful pattern:**\n  \
  \  ```go\n    ch1 := make(chan int)\n    ch2 := make(chan int)\n\n    for ch1 !=\
  \ nil || ch2 != nil {\n        select {\n        case v, ok := <-ch1:\n        \
  \    if !ok {\n                ch1 = nil  // Disable this case\n               \
  \ continue\n            }\n            fmt.Println(\"ch1:\", v)\n        case v,\
  \ ok := <-ch2:\n            if !ok {\n                ch2 = nil  // Disable this\
  \ case\n                continue\n            }\n            fmt.Println(\"ch2:\"\
  , v)\n        }\n    }\n    ```\n\n    ### Common Mistakes\n\n    **1. Deadlock\
  \ - no receiver:**\n    ```go\n    ch := make(chan int)\n    ch <- 42  // Blocks\
  \ forever - no receiver!\n    // fatal error: all goroutines are asleep - deadlock!\n\
  \    ```\n\n    **2. Sending on closed channel:**\n    ```go\n    ch := make(chan\
  \ int)\n    close(ch)\n    ch <- 42  // PANIC: send on closed channel\n    ```\n\
  \n    **3. Closing receive-only channel:**\n    ```go\n    func receiver(ch <-chan\
  \ int) {\n        close(ch)  // ERROR: cannot close receive-only channel\n    }\n\
  \    ```\n\n    **4. Forgetting to close channel:**\n    ```go\n    for value :=\
  \ range ch {  // Waits forever if ch never closes\n        fmt.Println(value)\n\
  \    }\n    ```\n\n    ### Best Practices\n\n    **1. Only sender closes channels:**\n\
  \    ```go\n    // ✅ GOOD\n    func sender(ch chan int) {\n        ch <- 42\n  \
  \      close(ch)\n    }\n\n    // ❌ BAD\n    func receiver(ch chan int) {\n    \
  \    <-ch\n        close(ch)  // Receiver shouldn't close!\n    }\n    ```\n\n \
  \   **2. Use buffered channels for performance:**\n    ```go\n    // Unbuffered:\
  \ each send waits for receive (slow)\n    ch := make(chan int)\n\n    // Buffered:\
  \ sends don't wait until buffer full (faster)\n    ch := make(chan int, 100)\n \
  \   ```\n\n    **3. Use directional channels in function signatures:**\n    ```go\n\
  \    func send(ch chan<- int) { ch <- 42 }  // Can only send\n    func receive(ch\
  \ <-chan int) { <-ch }   // Can only receive\n    ```\n\n    **4. Use select for\
  \ timeouts:**\n    ```go\n    select {\n    case result := <-ch:\n        return\
  \ result\n    case <-time.After(1 * time.Second):\n        return errors.New(\"\
  timeout\")\n    }\n    ```\n\n    ### Performance Characteristics\n\n    **Unbuffered\
  \ channel:**\n    - Send/Receive: ~50-100 ns\n    - Synchronization overhead\n\n\
  \    **Buffered channel:**\n    - Send/Receive (when not full/empty): ~10-20 ns\n\
  \    - Faster, but uses more memory\n\n    **Memory:**\n    - Channel struct: ~96\
  \ bytes\n    - Buffered: + (capacity × element size)\n\n    ### Key Takeaways\n\n\
  \    1. Channels safely communicate between goroutines\n    2. Unbuffered channels\
  \ synchronize (block sender/receiver)\n    3. Buffered channels allow async sends\
  \ (up to capacity)\n    4. Always close channels from sender side\n    5. Use `select`\
  \ to multiplex multiple channels\n    6. Use directional channels for type safety\n\
  \    7. Common patterns: worker pool, pipeline, fan-in/fan-out\n\n    **Next:**\
  \ Learn advanced concurrency patterns with channels!"
exercises:
  - type: multiple_choice
    sequence_order: 1
    question: "What is the fundamental difference between unbuffered and buffered channels in Go?"
    options:
      - "Unbuffered channels are faster than buffered channels"
      - "Unbuffered channels block the sender until a receiver is ready, while buffered channels allow sends without blocking until the buffer is full"
      - "Buffered channels can only send integers while unbuffered channels can send any type"
      - "Unbuffered channels automatically close when done, buffered channels must be closed manually"
    correct_answer: "Unbuffered channels block the sender until a receiver is ready, while buffered channels allow sends without blocking until the buffer is full"
    explanation: "The difference between unbuffered and buffered channels defines different synchronization semantics. An unbuffered channel created with make(chan T) provides synchronous communication - when you send a value, the operation blocks until another goroutine is ready to receive it. This creates a rendezvous or handshake point where sender and receiver must be present simultaneously. Unbuffered channels guarantee that when a send completes, the value has been received. In contrast, a buffered channel created with make(chan T, capacity) allows asynchronous communication. Sends only block when the buffer is full, and receives only block when the buffer is empty. This decouples sender and receiver timing - you can send multiple values without a receiver being ready, up to the buffer capacity. Buffered channels are useful for smoothing out temporary speed mismatches between producers and consumers, implementing worker pools, or reducing context switching overhead. However, they also mask timing issues and can hide bugs. Choose unbuffered channels when you want explicit synchronization and buffered channels when you need performance or decoupling, but always with a justified capacity based on your specific use case."
    require_pass: true
  - type: multiple_choice
    sequence_order: 2
    question: "Why should only the sender close a channel in Go, not the receiver?"
    options:
      - "The receiver doesn't have permission to close channels"
      - "Sending on a closed channel causes a panic, and only the sender knows when no more values will be sent"
      - "Closed channels consume more memory"
      - "It's just a convention with no technical reason"
    correct_answer: "Sending on a closed channel causes a panic, and only the sender knows when no more values will be sent"
    explanation: "The 'sender closes' rule is a critical safety principle in Go channel programming. When you attempt to send a value to a closed channel, Go panics with 'send on closed channel' error. If a receiver closed the channel, any goroutine trying to send would crash unexpectedly. Only the sender has the knowledge of when it's done sending values - it knows its work is complete and no more data will come. The receiver, on the other hand, can't know if more sends are coming without out-of-band communication. Closing a channel signals to receivers that no more values will arrive, allowing range loops over channels to terminate cleanly and preventing goroutine leaks. When a channel is closed, receives don't panic - they return the zero value for the channel's type, and you can detect closure with the two-value receive: value, ok := <-ch where ok is false for closed channels. This asymmetric behavior makes sender-closes the only safe pattern. In scenarios with multiple senders, you need coordination (like a sync.Once) to ensure the channel is closed exactly once, or use alternative patterns like a separate done channel. Understanding this rule prevents one of the most common sources of panics in concurrent Go programs."
    require_pass: true
  - type: multiple_choice
    sequence_order: 3
    question: "What does the select statement do in Go?"
    options:
      - "Selects the fastest goroutine to execute"
      - "Allows a goroutine to wait on multiple channel operations simultaneously, proceeding with whichever operation is ready first"
      - "Automatically closes channels that are no longer needed"
      - "Selects which error to return from a function"
    correct_answer: "Allows a goroutine to wait on multiple channel operations simultaneously, proceeding with whichever operation is ready first"
    explanation: "The select statement is Go's multiplexing primitive for channel operations, similar to how a switch statement works for values. It allows a goroutine to wait on multiple channel operations simultaneously and proceed with whichever operation becomes ready first. If multiple operations are ready, select chooses one at random to avoid starvation. This is fundamentally different from sequential channel operations which would block on the first channel until it's ready. Select enables powerful concurrency patterns: timeouts using time.After(), non-blocking operations with a default case, combining multiple input channels, implementing cancellation with context or done channels, and building responsive systems that can handle multiple event sources. For example, a select with a timeout case prevents your goroutine from hanging forever if a channel operation never completes. The default case makes operations non-blocking - if no channel is ready, the default executes immediately instead of waiting. Select is essential for building robust concurrent programs because it gives you fine-grained control over blocking behavior and allows implementing sophisticated coordination patterns between goroutines without explicit locks. Understanding select is key to mastering Go's concurrency model."
    require_pass: true
