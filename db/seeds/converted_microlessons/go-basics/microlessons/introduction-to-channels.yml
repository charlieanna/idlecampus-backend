slug: introduction-to-channels
title: Introduction to Channels
difficulty: easy
sequence_order: 4
estimated_minutes: 2
key_concepts: []
prerequisites: []
content_md: "# Introduction to Channels \U0001F680\n\n# Introduction to Channels\n\
  \n    **Channels** are Go's way of letting goroutines communicate safely. Think\
  \ of them as pipes that connect concurrent functions.\n\n    ## Creating Channels\n\
  \n    ```go\n    // Create a channel of integers\n    ch := make(chan int)\n\n \
  \   // Buffered channel (can hold 5 values)\n    buffered := make(chan string, 5)\n\
  \n    // Receive-only channel (can only receive)\n    var receive <-chan int\n\n\
  \    // Send-only channel (can only send)\n    var send chan<- int\n    ```\n\n\
  \    ## Channel Operations\n\n    ### Send\n    ```go\n    ch <- 42  // Send value\
  \ 42 to channel ch\n    ```\n\n    ### Receive\n    ```go\n    value := <-ch  //\
  \ Receive value from channel and assign to value\n\n    // Receive and discard\n\
  \    <-ch\n\n    // Check if channel is closed\n    value, ok := <-ch\n    if !ok\
  \ {\n        fmt.Println(\"Channel closed!\")\n    }\n    ```\n\n    ### Close\n\
  \    ```go\n    close(ch)  // Close the channel (no more sends allowed)\n    ```\n\
  \n    ## Basic Example\n\n    ```go\n    package main\n\n    import \"fmt\"\n\n\
  \    func sendData(ch chan string) {\n        ch <- \"Hello from goroutine!\"\n\
  \    }\n\n    func main() {\n        // Create channel\n        messageChan := make(chan\
  \ string)\n\n        // Start goroutine\n        go sendData(messageChan)\n\n  \
  \      // Receive from channel (blocks until data arrives)\n        message := <-messageChan\n\
  \        fmt.Println(message)\n    }\n    ```\n\n    ## Unbuffered vs Buffered Channels\n\
  \n    ### Unbuffered Channels (Default)\n\n    ```go\n    ch := make(chan int) \
  \ // Unbuffered\n\n    // Send blocks until someone receives\n    // Receive blocks\
  \ until someone sends\n    ```\n\n    **Characteristics:**\n    - Send blocks until\
  \ receive happens\n    - Receive blocks until send happens\n    - Provides **synchronization**\n\
  \    - Guarantees delivery\n\n    **Visual:**\n    ```\n    Sender ─────[Handshake]─────>\
  \ Receiver\n            (both must be ready)\n    ```\n\n    Example:\n    ```go\n\
  \    func main() {\n        ch := make(chan int)\n\n        go func() {\n      \
  \      fmt.Println(\"Goroutine: Sending...\")\n            ch <- 42  // Blocks until\
  \ main receives\n            fmt.Println(\"Goroutine: Sent!\")\n        }()\n\n\
  \        time.Sleep(2 * time.Second)\n        fmt.Println(\"Main: Receiving...\"\
  )\n        value := <-ch  // Blocks until goroutine sends\n        fmt.Println(\"\
  Main: Received\", value)\n    }\n    ```\n\n    Output:\n    ```\n    Goroutine:\
  \ Sending...\n    (2 second pause)\n    Main: Receiving...\n    Goroutine: Sent!\n\
  \    Main: Received 42\n    ```\n\n    ### Buffered Channels\n\n    ```go\n    ch\
  \ := make(chan int, 3)  // Buffer size of 3\n\n    // Can send 3 values without\
  \ blocking\n    ch <- 1  // Doesn't block\n    ch <- 2  // Doesn't block\n    ch\
  \ <- 3  // Doesn't block\n    ch <- 4  // BLOCKS (buffer full)\n    ```\n\n    **Visual:**\n\
  \    ```\n    Sender → [Buffer: |||] → Receiver\n             (can hold 3 items)\n\
  \    ```\n\n    Example:\n    ```go\n    func main() {\n        ch := make(chan\
  \ string, 2)\n\n        // Send 2 values (won't block, buffer holds them)\n    \
  \    ch <- \"first\"\n        ch <- \"second\"\n        // ch <- \"third\"  // Would\
  \ block! Buffer full\n\n        // Receive them\n        fmt.Println(<-ch)  // \"\
  first\"\n        fmt.Println(<-ch)  // \"second\"\n    }\n    ```\n\n    ## Channel\
  \ Directions\n\n    Restrict channel operations for safety:\n\n    ```go\n    //\
  \ Send-only channel\n    func sendOnly(ch chan<- int) {\n        ch <- 42\n    \
  \    // value := <-ch  // ERROR: can't receive\n    }\n\n    // Receive-only channel\n\
  \    func receiveOnly(ch <-chan int) {\n        value := <-ch\n        // ch <-\
  \ 42  // ERROR: can't send\n    }\n\n    func main() {\n        ch := make(chan\
  \ int)\n\n        go sendOnly(ch)\n        receiveOnly(ch)\n    }\n    ```\n\n \
  \   ## Range Over Channels\n\n    Loop until channel is closed:\n\n    ```go\n \
  \   func producer(ch chan int) {\n        for i := 0; i < 5; i++ {\n           \
  \ ch <- i\n        }\n        close(ch)  // Signal: no more data\n    }\n\n    func\
  \ main() {\n        ch := make(chan int)\n\n        go producer(ch)\n\n        //\
  \ Range reads until channel is closed\n        for value := range ch {\n       \
  \     fmt.Println(value)\n        }\n    }\n    ```\n\n    Output:\n    ```\n  \
  \  0\n    1\n    2\n    3\n    4\n    ```\n\n    ## Common Patterns\n\n    ### 1.\
  \ Worker Pool\n\n    ```go\n    func worker(id int, jobs <-chan int, results chan<-\
  \ int) {\n        for job := range jobs {\n            fmt.Printf(\"Worker %d processing\
  \ job %d\\\\n\", id, job)\n            time.Sleep(time.Second)\n            results\
  \ <- job * 2\n        }\n    }\n\n    func main() {\n        jobs := make(chan int,\
  \ 100)\n        results := make(chan int, 100)\n\n        // Start 3 workers\n \
  \       for w := 1; w <= 3; w++ {\n            go worker(w, jobs, results)\n   \
  \     }\n\n        // Send 9 jobs\n        for j := 1; j <= 9; j++ {\n         \
  \   jobs <- j\n        }\n        close(jobs)\n\n        // Collect results\n  \
  \      for a := 1; a <= 9; a++ {\n            <-results\n        }\n    }\n    ```\n\
  \n    ### 2. Pipeline\n\n    ```go\n    // Stage 1: Generate numbers\n    func generate(nums\
  \ ...int) <-chan int {\n        out := make(chan int)\n        go func() {\n   \
  \         for _, n := range nums {\n                out <- n\n            }\n  \
  \          close(out)\n        }()\n        return out\n    }\n\n    // Stage 2:\
  \ Square numbers\n    func square(in <-chan int) <-chan int {\n        out := make(chan\
  \ int)\n        go func() {\n            for n := range in {\n                out\
  \ <- n * n\n            }\n            close(out)\n        }()\n        return out\n\
  \    }\n\n    func main() {\n        // Pipeline: generate → square\n        numbers\
  \ := generate(1, 2, 3, 4)\n        squares := square(numbers)\n\n        // Print\
  \ results\n        for result := range squares {\n            fmt.Println(result)\n\
  \        }\n    }\n    ```\n\n    Output:\n    ```\n    1\n    4\n    9\n    16\n\
  \    ```\n\n    ### 3. Fan-out, Fan-in\n\n    ```go\n    func fanOut(input <-chan\
  \ int, workers int) []<-chan int {\n        channels := make([]<-chan int, workers)\n\
  \        for i := 0; i < workers; i++ {\n            channels[i] = doWork(input)\n\
  \        }\n        return channels\n    }\n\n    func fanIn(channels ...<-chan\
  \ int) <-chan int {\n        out := make(chan int)\n        var wg sync.WaitGroup\n\
  \n        for _, ch := range channels {\n            wg.Add(1)\n            go func(c\
  \ <-chan int) {\n                defer wg.Done()\n                for n := range\
  \ c {\n                    out <- n\n                }\n            }(ch)\n    \
  \    }\n\n        go func() {\n            wg.Wait()\n            close(out)\n \
  \       }()\n\n        return out\n    }\n    ```\n\n    ## Deadlock\n\n    **Deadlock**\
  \ occurs when goroutines are waiting for each other indefinitely.\n\n    ❌ **Causes\
  \ deadlock:**\n    ```go\n    func main() {\n        ch := make(chan int)\n    \
  \    ch <- 42  // Blocks forever (no receiver)\n        fmt.Println(<-ch)\n    }\n\
  \    // fatal error: all goroutines are asleep - deadlock!\n    ```\n\n    ✅ **Fixed:**\n\
  \    ```go\n    func main() {\n        ch := make(chan int)\n\n        go func()\
  \ {\n            ch <- 42  // Send in goroutine\n        }()\n\n        fmt.Println(<-ch)\
  \  // Receive in main\n    }\n    ```\n\n    ## Best Practices\n\n    1. **Close\
  \ channels from sender side**: Never close from receiver\n    2. **Don't close twice**:\
  \ Panic! Check if closed before closing\n    3. **Closing is optional**: For signaling\
  \ \"done\" or when using `range`\n    4. **Buffered for known capacity**: Use buffered\
  \ when you know max pending items\n    5. **Unbuffered for synchronization**: When\
  \ you need handshake guarantee\n\n    ## Channel Axioms\n\n    1. Send to `nil`\
  \ channel blocks forever\n    2. Receive from `nil` channel blocks forever\n   \
  \ 3. Send to closed channel panics\n    4. Receive from closed channel returns zero\
  \ value immediately\n    5. Closing `nil` channel panics\n    6. Closing closed\
  \ channel panics\n\n    Next: Learn the **select** statement for multiplexing channels!"
exercises:
- type: mcq
  sequence_order: 1
  question: What is the key difference in blocking behavior between unbuffered and
    buffered channels in Go?
  options:
  - Unbuffered channels block on send until receive; buffered channels only block
    when the buffer is full
  - Buffered channels are non-blocking; unbuffered channels always block
  - Unbuffered channels can hold one value; buffered channels can hold multiple values
  - Buffered channels automatically close when full; unbuffered channels must be closed
    manually
  correct_answer: Unbuffered channels block on send until receive; buffered channels
    only block when the buffer is full
  explanation: 'Unbuffered channels (make(chan int)) provide synchronization through
    blocking: a send operation blocks until another goroutine receives from the channel,
    creating a "handshake" where both goroutines must be ready simultaneously. This
    guarantees delivery and provides built-in synchronization. Buffered channels (make(chan
    int, n)) have internal storage for n values. Sends only block when the buffer
    is completely full, and receives only block when the buffer is empty. This allows
    asynchronous communication where the sender can "fire and forget" values up to
    the buffer capacity. For example, ch := make(chan int, 3) allows you to send 3
    values without any receiver present - the 4th send would block. This is useful
    when you want to decouple sender and receiver timing, like in producer-consumer
    patterns. However, buffered channels can hide concurrency bugs since they delay
    blocking, so unbuffered channels are often preferred unless you have a specific
    reason for buffering.'
  require_pass: true
- type: mcq
  sequence_order: 2
  question: What happens when you try to receive from a closed channel in Go?
  options:
  - The program panics immediately with a runtime error
  - The receive operation blocks forever waiting for data
  - The receive operation returns the zero value for the channel type immediately,
    and ok is false
  - The channel automatically reopens and waits for new data
  correct_answer: The receive operation returns the zero value for the channel type
    immediately, and ok is false
  explanation: 'When you receive from a closed channel in Go, the operation succeeds
    immediately and returns the zero value for the channel''s type (0 for int, ""
    for string, nil for pointers, etc.) along with false for the ok value in the two-value
    receive form: value, ok := <-ch. If ok is false, it means the channel is closed
    and the value is a zero value (not real data). This behavior allows for clean
    shutdown patterns: you can range over a channel (for value := range ch) and the
    loop terminates when the channel closes. In contrast, other operations have different
    behaviors: (1) sending to a closed channel causes a panic, (2) receiving from
    a nil channel blocks forever, (3) sending to a nil channel blocks forever, (4)
    closing a nil or already-closed channel causes a panic. Understanding these channel
    axioms is critical for writing correct concurrent Go code. Always check the ok
    value when receiving if you need to distinguish between real data and closed-channel
    zero values.'
  require_pass: true
- type: mcq
  sequence_order: 3
  question: Why is it a best practice to close channels from the sender side rather
    than the receiver side?
  options:
  - Because receivers cannot close channels due to Go language restrictions
  - Because sending to a closed channel panics, and only the sender knows when no
    more data will be sent
  - Because closing from the receiver side causes memory leaks
  - Because the receiver might still need to read remaining buffered values
  correct_answer: Because sending to a closed channel panics, and only the sender
    knows when no more data will be sent
  explanation: 'Closing channels from the sender side is a best practice because sending
    to a closed channel causes a panic (runtime crash). Only the sender knows when
    it''s finished sending all data, so only the sender should signal completion by
    closing the channel. If a receiver closes the channel, another goroutine might
    still try to send to it, causing a panic. Consider a worker pool: if workers (receivers)
    close the job channel, the dispatcher (sender) would panic when trying to send
    new jobs. The pattern is: senders close channels to signal "no more data coming,"
    and receivers detect this via the two-value receive (value, ok := <-ch) or range
    loop termination. However, closing is optional - channels don''t need to be closed
    unless you''re using them for signaling (like range loops or select statements).
    Garbage collection handles channels like any other object. The "sender closes"
    rule prevents race conditions and panics, making concurrent code safer and more
    predictable.'
  require_pass: true
