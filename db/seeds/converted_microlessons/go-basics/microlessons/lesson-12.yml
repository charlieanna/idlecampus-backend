slug: lesson-12
title: Lesson 12
difficulty: easy
sequence_order: 12
estimated_minutes: 2
key_concepts: []
prerequisites: []
content_md: "# Microlesson \U0001F680\n\n# Context Package: Managing Goroutine Lifecycles\n\
  \n    ### What is Context?\n\n    The **context package** is Go's standard way to\
  \ manage cancellation, deadlines, and request-scoped values across goroutines. It's\
  \ essential for production Go applications.\n\n    **Why Context matters:**\n  \
  \  - ✅ Cancel long-running operations\n    - ✅ Set timeouts for operations\n   \
  \ - ✅ Pass request-scoped data (like user IDs, trace IDs)\n    - ✅ Prevent goroutine\
  \ leaks\n    - ✅ Clean shutdown of services\n\n    **Import:**\n    ```go\n    import\
  \ \"context\"\n    ```\n\n    ### The Context Interface\n\n    ```go\n    type Context\
  \ interface {\n        Deadline() (deadline time.Time, ok bool)\n        Done()\
  \ <-chan struct{}\n        Err() error\n        Value(key interface{}) interface{}\n\
  \    }\n    ```\n\n    **Four key methods:**\n    - `Deadline()` - Returns when\
  \ context will be cancelled\n    - `Done()` - Channel that closes when context is\
  \ cancelled\n    - `Err()` - Returns why context was cancelled\n    - `Value(key)`\
  \ - Retrieves request-scoped values\n\n    ### Creating Contexts\n\n    **1. Background\
  \ Context (root context):**\n    ```go\n    ctx := context.Background()\n    //\
  \ Use for main function, initialization, tests\n    ```\n\n    **2. TODO Context\
  \ (placeholder):**\n    ```go\n    ctx := context.TODO()\n    // Use when you're\
  \ not sure which context to use yet\n    ```\n\n    **3. WithCancel - Manual cancellation:**\n\
  \    ```go\n    ctx, cancel := context.WithCancel(context.Background())\n    defer\
  \ cancel()  // Always call cancel to free resources\n\n    // Later, to cancel:\n\
  \    cancel()\n    ```\n\n    **4. WithTimeout - Automatic cancellation after duration:**\n\
  \    ```go\n    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\
  \    defer cancel()\n\n    // Automatically cancelled after 5 seconds\n    ```\n\
  \n    **5. WithDeadline - Cancel at specific time:**\n    ```go\n    deadline :=\
  \ time.Now().Add(1 * time.Hour)\n    ctx, cancel := context.WithDeadline(context.Background(),\
  \ deadline)\n    defer cancel()\n\n    // Automatically cancelled at deadline\n\
  \    ```\n\n    **6. WithValue - Attach request-scoped data:**\n    ```go\n    ctx\
  \ := context.WithValue(context.Background(), \"userID\", 12345)\n\n    // Later,\
  \ retrieve value:\n    userID := ctx.Value(\"userID\").(int)\n    ```\n\n    ###\
  \ Basic Cancellation Pattern\n\n    **Problem: Goroutine that never stops:**\n \
  \   ```go\n    // ❌ BAD: No way to stop this goroutine!\n    go func() {\n     \
  \   for {\n            // Do work forever\n            doWork()\n        }\n   \
  \ }()\n    ```\n\n    **Solution: Use context:**\n    ```go\n    // ✅ GOOD: Respects\
  \ cancellation\n    func worker(ctx context.Context) {\n        for {\n        \
  \    select {\n            case <-ctx.Done():\n                fmt.Println(\"Worker\
  \ cancelled:\", ctx.Err())\n                return\n            default:\n     \
  \           doWork()\n            }\n        }\n    }\n\n    ctx, cancel := context.WithCancel(context.Background())\n\
  \    go worker(ctx)\n\n    // Later, when you want to stop:\n    cancel()\n    ```\n\
  \n    ### Timeout Pattern\n\n    **Prevent operations from running forever:**\n\
  \    ```go\n    func fetchData(ctx context.Context, url string) ([]byte, error)\
  \ {\n        req, err := http.NewRequestWithContext(ctx, \"GET\", url, nil)\n  \
  \      if err != nil {\n            return nil, err\n        }\n\n        resp,\
  \ err := http.DefaultClient.Do(req)\n        if err != nil {\n            return\
  \ nil, err\n        }\n        defer resp.Body.Close()\n\n        return io.ReadAll(resp.Body)\n\
  \    }\n\n    // Usage with timeout\n    ctx, cancel := context.WithTimeout(context.Background(),\
  \ 3*time.Second)\n    defer cancel()\n\n    data, err := fetchData(ctx, \"https://api.example.com/data\"\
  )\n    if err != nil {\n        if err == context.DeadlineExceeded {\n         \
  \   fmt.Println(\"Request timed out!\")\n        }\n        return err\n    }\n\
  \    ```\n\n    ### Propagating Context Through Call Stack\n\n    **Context should\
  \ be the first parameter:**\n    ```go\n    func processRequest(ctx context.Context,\
  \ userID int) error {\n        // Check if already cancelled\n        if err :=\
  \ ctx.Err(); err != nil {\n            return err\n        }\n\n        // Pass\
  \ context down to other functions\n        data, err := fetchUserData(ctx, userID)\n\
  \        if err != nil {\n            return err\n        }\n\n        return saveData(ctx,\
  \ data)\n    }\n\n    func fetchUserData(ctx context.Context, userID int) (*UserData,\
  \ error) {\n        // This function also respects cancellation\n        select\
  \ {\n        case <-ctx.Done():\n            return nil, ctx.Err()\n        default:\n\
  \            // Fetch data\n        }\n    }\n    ```\n\n    ### Real-World Example:\
  \ HTTP Server with Timeout\n\n    ```go\n    package main\n\n    import (\n    \
  \    \"context\"\n        \"fmt\"\n        \"net/http\"\n        \"time\"\n    )\n\
  \n    func slowHandler(w http.ResponseWriter, r *http.Request) {\n        // Create\
  \ context with 5-second timeout\n        ctx, cancel := context.WithTimeout(r.Context(),\
  \ 5*time.Second)\n        defer cancel()\n\n        // Simulate slow operation\n\
  \        result := make(chan string, 1)\n        go func() {\n            time.Sleep(10\
  \ * time.Second)  // Simulates slow work\n            result <- \"Success\"\n  \
  \      }()\n\n        // Wait for result or timeout\n        select {\n        case\
  \ <-ctx.Done():\n            http.Error(w, \"Request timeout\", http.StatusRequestTimeout)\n\
  \            fmt.Println(\"Request cancelled:\", ctx.Err())\n        case res :=\
  \ <-result:\n            fmt.Fprintf(w, \"Result: %s\", res)\n        }\n    }\n\
  \n    func main() {\n        http.HandleFunc(\"/slow\", slowHandler)\n        http.ListenAndServe(\"\
  :8080\", nil)\n    }\n    ```\n\n    ### Context Values: Request-Scoped Data\n\n\
  \    **Passing data through call chain:**\n    ```go\n    type contextKey string\n\
  \n    const (\n        userIDKey    contextKey = \"userID\"\n        requestIDKey\
  \ contextKey = \"requestID\"\n    )\n\n    func handler(w http.ResponseWriter, r\
  \ *http.Request) {\n        // Extract user from authentication\n        userID\
  \ := getUserFromAuth(r)\n\n        // Add to context\n        ctx := context.WithValue(r.Context(),\
  \ userIDKey, userID)\n        ctx = context.WithValue(ctx, requestIDKey, generateRequestID())\n\
  \n        // Process with context\n        processRequest(ctx)\n    }\n\n    func\
  \ processRequest(ctx context.Context) {\n        // Retrieve values\n        userID,\
  \ ok := ctx.Value(userIDKey).(int)\n        if !ok {\n            log.Println(\"\
  No user ID in context\")\n            return\n        }\n\n        requestID :=\
  \ ctx.Value(requestIDKey).(string)\n        log.Printf(\"Processing request %s for\
  \ user %d\", requestID, userID)\n    }\n    ```\n\n    **⚠️ Best Practice: Use typed\
  \ keys, not strings:**\n    ```go\n    // ❌ BAD: String keys can collide\n    ctx\
  \ := context.WithValue(ctx, \"userID\", 123)\n\n    // ✅ GOOD: Use custom type\n\
  \    type contextKey string\n    const userIDKey contextKey = \"userID\"\n    ctx\
  \ := context.WithValue(ctx, userIDKey, 123)\n    ```\n\n    ### Practical Pattern:\
  \ Database Query with Timeout\n\n    ```go\n    func getUserByID(ctx context.Context,\
  \ db *sql.DB, id int) (*User, error) {\n        // Database query respects context\n\
  \        query := \"SELECT id, name, email FROM users WHERE id = ?\"\n\n       \
  \ var user User\n        err := db.QueryRowContext(ctx, query, id).Scan(\n     \
  \       &user.ID,\n            &user.Name,\n            &user.Email,\n        )\n\
  \n        if err != nil {\n            return nil, err\n        }\n        return\
  \ &user, nil\n    }\n\n    // Usage with timeout\n    func main() {\n        ctx,\
  \ cancel := context.WithTimeout(context.Background(), 2*time.Second)\n        defer\
  \ cancel()\n\n        user, err := getUserByID(ctx, db, 123)\n        if err !=\
  \ nil {\n            if err == context.DeadlineExceeded {\n                log.Println(\"\
  Database query timed out\")\n            }\n            return\n        }\n    \
  \    fmt.Printf(\"Found user: %+v\\\\n\", user)\n    }\n    ```\n\n    ### Context\
  \ with Multiple Goroutines\n\n    **Cancelling multiple workers:**\n    ```go\n\
  \    func fanOut(ctx context.Context, jobs <-chan int, numWorkers int) {\n     \
  \   var wg sync.WaitGroup\n\n        for i := 0; i < numWorkers; i++ {\n       \
  \     wg.Add(1)\n            go func(workerID int) {\n                defer wg.Done()\n\
  \n                for {\n                    select {\n                    case\
  \ <-ctx.Done():\n                        fmt.Printf(\"Worker %d stopped\\\\n\",\
  \ workerID)\n                        return\n                    case job, ok :=\
  \ <-jobs:\n                        if !ok {\n                            return\n\
  \                        }\n                        processJob(ctx, job)\n     \
  \               }\n                }\n            }(i)\n        }\n\n        wg.Wait()\n\
  \    }\n\n    func processJob(ctx context.Context, job int) {\n        // Check\
  \ context before expensive work\n        if err := ctx.Err(); err != nil {\n   \
  \         return\n        }\n\n        // Do work...\n        time.Sleep(100 * time.Millisecond)\n\
  \        fmt.Printf(\"Processed job %d\\\\n\", job)\n    }\n\n    // Usage\n   \
  \ ctx, cancel := context.WithCancel(context.Background())\n    jobs := make(chan\
  \ int, 10)\n\n    // Start workers\n    go fanOut(ctx, jobs, 5)\n\n    // Send jobs\n\
  \    for i := 0; i < 20; i++ {\n        jobs <- i\n    }\n    close(jobs)\n\n  \
  \  // Cancel all workers after 1 second\n    time.Sleep(1 * time.Second)\n    cancel()\n\
  \    ```\n\n    ### Graceful Shutdown Pattern\n\n    ```go\n    package main\n\n\
  \    import (\n        \"context\"\n        \"fmt\"\n        \"os\"\n        \"\
  os/signal\"\n        \"syscall\"\n        \"time\"\n    )\n\n    func main() {\n\
  \        // Create context that cancels on SIGINT/SIGTERM\n        ctx, cancel :=\
  \ context.WithCancel(context.Background())\n        defer cancel()\n\n        //\
  \ Handle shutdown signals\n        sigChan := make(chan os.Signal, 1)\n        signal.Notify(sigChan,\
  \ syscall.SIGINT, syscall.SIGTERM)\n\n        go func() {\n            <-sigChan\n\
  \            fmt.Println(\"\\\\nShutdown signal received\")\n            cancel()\n\
  \        }()\n\n        // Start workers\n        var wg sync.WaitGroup\n      \
  \  for i := 0; i < 3; i++ {\n            wg.Add(1)\n            go worker(ctx, &wg,\
  \ i)\n        }\n\n        // Wait for graceful shutdown\n        wg.Wait()\n  \
  \      fmt.Println(\"All workers stopped. Clean shutdown complete.\")\n    }\n\n\
  \    func worker(ctx context.Context, wg *sync.WaitGroup, id int) {\n        defer\
  \ wg.Done()\n\n        ticker := time.NewTicker(500 * time.Millisecond)\n      \
  \  defer ticker.Stop()\n\n        for {\n            select {\n            case\
  \ <-ctx.Done():\n                fmt.Printf(\"Worker %d shutting down\\\\n\", id)\n\
  \                return\n            case <-ticker.C:\n                fmt.Printf(\"\
  Worker %d working\\\\n\", id)\n            }\n        }\n    }\n    ```\n\n    ###\
  \ Context Best Practices\n\n    **1. Always pass context as first parameter:**\n\
  \    ```go\n    // ✅ GOOD\n    func processData(ctx context.Context, data []byte)\
  \ error\n\n    // ❌ BAD\n    func processData(data []byte, ctx context.Context)\
  \ error\n    ```\n\n    **2. Never store context in structs:**\n    ```go\n    //\
  \ ❌ BAD\n    type Handler struct {\n        ctx context.Context\n    }\n\n    //\
  \ ✅ GOOD\n    type Handler struct {\n        // other fields\n    }\n\n    func\
  \ (h *Handler) Handle(ctx context.Context) error {\n        // Use context as parameter\n\
  \    }\n    ```\n\n    **3. Always call cancel() from WithCancel/WithTimeout:**\n\
  \    ```go\n    // ✅ GOOD: Always call cancel\n    ctx, cancel := context.WithTimeout(ctx,\
  \ 5*time.Second)\n    defer cancel()  // Frees resources\n    ```\n\n    **4. Check\
  \ context before expensive operations:**\n    ```go\n    func expensiveOperation(ctx\
  \ context.Context) error {\n        // Check early\n        if err := ctx.Err();\
  \ err != nil {\n            return err\n        }\n\n        // Do expensive work...\n\
  \n        // Check again during long operation\n        select {\n        case <-ctx.Done():\n\
  \            return ctx.Err()\n        default:\n            // Continue work\n\
  \        }\n    }\n    ```\n\n    **5. Use context.Value() sparingly:**\n    ```go\n\
  \    // ✅ GOOD: Request-scoped values (user ID, trace ID)\n    ctx = context.WithValue(ctx,\
  \ requestIDKey, uuid.New())\n\n    // ❌ BAD: Passing optional parameters\n    ctx\
  \ = context.WithValue(ctx, \"option1\", true)\n    ctx = context.WithValue(ctx,\
  \ \"option2\", \"value\")\n    ```\n\n    **6. Never pass nil context:**\n    ```go\n\
  \    // ❌ BAD\n    processData(nil, data)\n\n    // ✅ GOOD\n    processData(context.Background(),\
  \ data)\n    // or\n    processData(context.TODO(), data)\n    ```\n\n    ### Context\
  \ Errors\n\n    **Two standard errors:**\n    ```go\n    if err := ctx.Err(); err\
  \ != nil {\n        switch err {\n        case context.Canceled:\n            //\
  \ Context was cancelled via cancel()\n            fmt.Println(\"Operation cancelled\"\
  )\n        case context.DeadlineExceeded:\n            // Context timed out\n  \
  \          fmt.Println(\"Operation timed out\")\n        }\n    }\n    ```\n\n \
  \   ### Common Mistakes\n\n    **1. Not checking context during loops:**\n    ```go\n\
  \    // ❌ BAD: Loop never checks cancellation\n    for i := 0; i < 1000000; i++\
  \ {\n        processItem(item)\n    }\n\n    // ✅ GOOD: Check context periodically\n\
  \    for i := 0; i < 1000000; i++ {\n        select {\n        case <-ctx.Done():\n\
  \            return ctx.Err()\n        default:\n            processItem(item)\n\
  \        }\n    }\n    ```\n\n    **2. Ignoring context in blocking calls:**\n \
  \   ```go\n    // ❌ BAD: Doesn't respect context\n    data, err := http.Get(url)\n\
  \n    // ✅ GOOD: Use context\n    req, _ := http.NewRequestWithContext(ctx, \"GET\"\
  , url, nil)\n    data, err := http.DefaultClient.Do(req)\n    ```\n\n    **3. Creating\
  \ context per goroutine:**\n    ```go\n    // ❌ BAD: Each worker has separate context\n\
  \    for i := 0; i < 10; i++ {\n        ctx := context.Background()\n        go\
  \ worker(ctx)  // Can't cancel all at once!\n    }\n\n    // ✅ GOOD: Share parent\
  \ context\n    ctx, cancel := context.WithCancel(context.Background())\n    for\
  \ i := 0; i < 10; i++ {\n        go worker(ctx)  // All can be cancelled together\n\
  \    }\n    ```\n\n    ### Real-World Example: API Client with Retries\n\n    ```go\n\
  \    func fetchWithRetry(ctx context.Context, url string, maxRetries int) ([]byte,\
  \ error) {\n        var lastErr error\n\n        for i := 0; i < maxRetries; i++\
  \ {\n            // Check if context cancelled\n            if err := ctx.Err();\
  \ err != nil {\n                return nil, err\n            }\n\n            //\
  \ Create request with context\n            req, err := http.NewRequestWithContext(ctx,\
  \ \"GET\", url, nil)\n            if err != nil {\n                return nil, err\n\
  \            }\n\n            resp, err := http.DefaultClient.Do(req)\n        \
  \    if err == nil && resp.StatusCode == 200 {\n                defer resp.Body.Close()\n\
  \                return io.ReadAll(resp.Body)\n            }\n\n            lastErr\
  \ = err\n            if i < maxRetries-1 {\n                // Exponential backoff\
  \ with context\n                select {\n                case <-time.After(time.Second\
  \ * time.Duration(1<<i)):\n                case <-ctx.Done():\n                \
  \    return nil, ctx.Err()\n                }\n            }\n        }\n\n    \
  \    return nil, fmt.Errorf(\"failed after %d retries: %w\", maxRetries, lastErr)\n\
  \    }\n\n    // Usage\n    ctx, cancel := context.WithTimeout(context.Background(),\
  \ 10*time.Second)\n    defer cancel()\n\n    data, err := fetchWithRetry(ctx, \"\
  https://api.example.com/data\", 3)\n    ```\n\n    ### Key Takeaways\n\n    1. **Context\
  \ manages lifecycles** - cancellation, timeouts, deadlines\n    2. **Always pass\
  \ as first parameter** - `func foo(ctx context.Context, ...)`\n    3. **Always defer\
  \ cancel()** - frees resources\n    4. **Check ctx.Done()** - respect cancellation\n\
  \    5. **Use WithTimeout** for operations that shouldn't run forever\n    6. **Propagate\
  \ context** through call stack\n    7. **Don't store context** in structs\n    8.\
  \ **Use context.Value() sparingly** - only for request-scoped data\n    9. **context.Background()**\
  \ - for main, init, tests\n    10. **Graceful shutdown** - cancel on signals\n\n\
  \    **Context is essential for production Go - it prevents goroutine leaks and\
  \ enables clean shutdowns!**"
exercises:
- type: mcq
  sequence_order: 1
  question: What is the primary purpose of the Go context package?
  options:
  - To store global variables across goroutines
  - To manage cancellation signals, deadlines, and request-scoped values across API
    boundaries and goroutines
  - To automatically parallelize functions
  - To handle HTTP requests exclusively
  correct_answer: To manage cancellation signals, deadlines, and request-scoped values
    across API boundaries and goroutines
  explanation: 'The context package provides a standardized way to manage cancellation,
    deadlines, and request-scoped values across goroutines and API boundaries. Use
    cases: (1) Cancellation - Stop long-running operations gracefully: HTTP request
    cancelled → cancel database query, user closes browser → stop processing, (2)
    Timeouts - Prevent operations from running forever: API call must complete in
    5 seconds, database query timeout to prevent blocking, (3) Request-scoped values
    - Pass data through call chain without function parameters: user ID, request ID,
    trace ID for logging. How it works: Parent context creates child contexts with
    ctx, cancel := context.WithCancel(parent). When cancel() called or deadline reached,
    ctx.Done() channel closes. All goroutines monitoring ctx.Done() can react: select
    { case <-ctx.Done(): cleanup and return }. Benefits: (1) Prevents goroutine leaks
    - Long-running goroutines can be stopped, (2) Resource management - Database connections,
    HTTP clients respect cancellation, (3) Cascading cancellation - Cancelling parent
    cancels all children automatically. Real-world example: HTTP request with 3-second
    timeout. User makes request → create context.WithTimeout(3s) → pass to database
    → pass to cache → if any times out, entire call chain cancels. Always pass context
    as first parameter: func ProcessOrder(ctx context.Context, orderID int).'
  require_pass: true
- type: mcq
  sequence_order: 2
  question: Why is it critical to always call the cancel function returned by context.WithCancel/WithTimeout?
  options:
  - To make the context reusable
  - To free resources and prevent memory leaks - the cancel function releases goroutines
    and timers
  - To send the cancellation signal to parent contexts
  - cancel() is optional and only needed for error cases
  correct_answer: To free resources and prevent memory leaks - the cancel function
    releases goroutines and timers
  explanation: 'Always calling cancel() is critical to prevent resource leaks, even
    if the context completes normally. Why cancel is needed: Context with timeout/deadline
    creates internal goroutine and timer. If not cancelled, these resources persist
    until timeout expires, causing memory leaks. Even if operation completes quickly,
    resources remain allocated until timeout. Best practice pattern: ctx, cancel :=
    context.WithTimeout(parent, 5*time.Second); defer cancel() ensures cleanup happens.
    When cancel runs: (1) Internal timer is stopped immediately (frees memory), (2)
    ctx.Done() channel closes (signals all listeners), (3) Goroutines monitoring Done()
    can exit, (4) Resources are released back to Go runtime. Resource leak example:
    for i := 0; i < 10000; i++ { ctx, cancel := context.WithTimeout(background, 1*time.Hour);
    doQuickWork(ctx) } creates 10,000 timers that live for 1 hour each! Memory grows
    continuously. With defer cancel(): Timers cleaned up immediately after doQuickWork()
    completes, constant memory usage. Additional benefits of calling cancel: (1) Immediate
    cleanup - Don''t wait for timeout, (2) Signal propagation - Child contexts also
    cancelled, (3) Good practice - Makes cancellation explicit and visible. Note:
    Calling cancel() multiple times is safe (idempotent), but not calling it even
    once causes leaks.'
  require_pass: true
- type: mcq
  sequence_order: 3
  question: What is the difference between context.Background() and context.TODO()?
  options:
  - Background is for production, TODO is for testing
  - Background is the root context for real use; TODO is a placeholder when you're
    unsure which context to use
  - Background has a timeout, TODO does not
  - They are identical with no difference
  correct_answer: Background is the root context for real use; TODO is a placeholder
    when you're unsure which context to use
  explanation: 'Both context.Background() and context.TODO() return empty contexts,
    but their semantic purposes differ. context.Background(): Production root context.
    Use for: (1) main() function initialization, (2) Top-level request handlers (HTTP,
    gRPC), (3) Test setup, (4) When you definitely need a root context. Example: func
    main() { ctx := context.Background(); startServer(ctx) }. HTTP handler: func HandleRequest(w
    http.ResponseWriter, r *http.Request) { ctx := r.Context() // or context.Background()
    }. context.TODO(): Temporary placeholder during development. Use when: (1) You
    need a context but haven''t decided which one yet, (2) Refactoring code to add
    context support, (3) Not sure if you should use Background or receive context
    from caller. Example during refactoring: func oldFunction() { ctx := context.TODO();
    // TODO: Decide if this should be parameter newFunctionWithContext(ctx) }. Similarities:
    Both return non-nil, empty contexts, Neither has deadline, values, or cancellation,
    Both are never cancelled. Key difference: Intent and documentation. Background
    signals "this is intentional root context". TODO signals "this needs attention/decision".
    Best practices: Prefer Background() for production code, Use TODO() temporarily
    during development, then replace, Code review should flag TODO() contexts - they
    indicate incomplete work. In production, most functions should receive context
    as parameter, not create Background/TODO.'
  require_pass: true
