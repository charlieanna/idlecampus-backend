slug: lesson-16
title: Lesson 16
difficulty: easy
sequence_order: 16
estimated_minutes: 2
key_concepts: []
prerequisites: []
content_md: "# Microlesson \U0001F680\n\n# Structs: Building Custom Types\n\n    ###\
  \ What is a Struct?\n\n    A **struct** (short for \"structure\") is a **composite\
  \ data type** that groups together variables (called fields) under a single name.\
  \ Think of it as a blueprint for creating custom types that model real-world entities.\n\
  \n    **Real-world analogy:**\n    - A Person has: name, age, email\n    - A Car\
  \ has: make, model, year, color\n    - A Book has: title, author, pages, ISBN\n\n\
  \    Structs let you model these entities in code!\n\n    ### Defining Structs\n\
  \n    **Basic syntax:**\n    ```go\n    type StructName struct {\n        FieldName\
  \ FieldType\n        AnotherField AnotherType\n    }\n    ```\n\n    **Example:\
  \ Person struct**\n    ```go\n    type Person struct {\n        Name    string\n\
  \        Age     int\n        Email   string\n        IsActive bool\n    }\n   \
  \ ```\n\n    **Key points:**\n    - `type` keyword declares a new type\n    - `Person`\
  \ is the name of your custom type\n    - `struct` indicates it's a structure\n \
  \   - Each field has a name and type\n    - Field names starting with capital letters\
  \ are **exported** (public)\n    - Field names starting with lowercase are **unexported**\
  \ (private to package)\n\n    ### Creating Struct Instances\n\n    **Method 1: Literal\
  \ with field names (recommended)**\n    ```go\n    person := Person{\n        Name:\
  \     \"Alice\",\n        Age:      25,\n        Email:    \"alice@example.com\"\
  ,\n        IsActive: true,\n    }\n    ```\n\n    **Why this is best:**\n    - Clear\
  \ and self-documenting\n    - Order doesn't matter\n    - Can omit fields (they\
  \ get zero values)\n    - Resistant to changes in struct definition\n\n    **Method\
  \ 2: Positional arguments**\n    ```go\n    person := Person{\"Alice\", 25, \"alice@example.com\"\
  , true}\n    ```\n\n    ⚠️ **Not recommended because:**\n    - Must provide ALL\
  \ fields in exact order\n    - Breaks if struct changes\n    - Hard to read (what\
  \ does each value mean?)\n\n    **Method 3: Empty struct (all zero values)**\n \
  \   ```go\n    var person Person  // All fields have zero values\n    // person.Name\
  \ = \"\"\n    // person.Age = 0\n    // person.Email = \"\"\n    // person.IsActive\
  \ = false\n    ```\n\n    **Method 4: new() function**\n    ```go\n    person :=\
  \ new(Person)  // Returns *Person (pointer)\n    // All fields are zero values\n\
  \    ```\n\n    ### Accessing and Modifying Fields\n\n    **Dot notation:**\n  \
  \  ```go\n    person := Person{\n        Name: \"Alice\",\n        Age:  25,\n \
  \   }\n\n    // Access fields\n    fmt.Println(person.Name)  // \"Alice\"\n    fmt.Println(person.Age)\
  \   // 25\n\n    // Modify fields\n    person.Age = 26\n    person.Email = \"alice@newdomain.com\"\
  \n\n    fmt.Println(person.Age)  // 26\n    ```\n\n    ### Anonymous Structs\n\n\
  \    **Define and use without creating a named type:**\n    ```go\n    // Useful\
  \ for one-off data structures\n    config := struct {\n        Host string\n   \
  \     Port int\n    }{\n        Host: \"localhost\",\n        Port: 8080,\n    }\n\
  \n    fmt.Println(config.Host)  // \"localhost\"\n    ```\n\n    **Common use cases:**\n\
  \    - Configuration objects\n    - Test data\n    - JSON unmarshaling\n    - Quick\
  \ data grouping\n\n    ### Nested Structs\n\n    **Structs can contain other structs:**\n\
  \    ```go\n    type Address struct {\n        Street  string\n        City    string\n\
  \        ZipCode string\n    }\n\n    type Person struct {\n        Name    string\n\
  \        Age     int\n        Address Address  // Nested struct\n    }\n\n    person\
  \ := Person{\n        Name: \"Alice\",\n        Age:  25,\n        Address: Address{\n\
  \            Street:  \"123 Main St\",\n            City:    \"Springfield\",\n\
  \            ZipCode: \"12345\",\n        },\n    }\n\n    // Access nested fields\n\
  \    fmt.Println(person.Address.City)  // \"Springfield\"\n    ```\n\n    ### Struct\
  \ Embedding (Composition)\n\n    **Go doesn't have inheritance, but has composition:**\n\
  \    ```go\n    type Employee struct {\n        Person        // Embedded struct\
  \ (no field name)\n        EmployeeID string\n        Department string\n    }\n\
  \n    employee := Employee{\n        Person: Person{\n            Name: \"Bob\"\
  ,\n            Age:  30,\n        },\n        EmployeeID: \"E12345\",\n        Department:\
  \ \"Engineering\",\n    }\n\n    // Can access embedded fields directly!\n    fmt.Println(employee.Name)\
  \  // \"Bob\" (promoted from Person)\n    fmt.Println(employee.Age)   // 30\n\n\
  \    // Or through the embedded struct\n    fmt.Println(employee.Person.Name)  //\
  \ \"Bob\"\n    ```\n\n    **How field promotion works:**\n    - Embedded struct\
  \ fields are \"promoted\" to parent\n    - Can access them as if they're in the\
  \ parent struct\n    - If there's a name conflict, use explicit path\n\n    ###\
  \ Comparing Structs\n\n    **Structs are comparable if all their fields are comparable:**\n\
  \    ```go\n    type Point struct {\n        X, Y int\n    }\n\n    p1 := Point{X:\
  \ 1, Y: 2}\n    p2 := Point{X: 1, Y: 2}\n    p3 := Point{X: 3, Y: 4}\n\n    fmt.Println(p1\
  \ == p2)  // true (same values)\n    fmt.Println(p1 == p3)  // false (different\
  \ values)\n    ```\n\n    **Not comparable if contains slices, maps, or functions:**\n\
  \    ```go\n    type Container struct {\n        Items []int  // Slice makes it\
  \ non-comparable\n    }\n\n    c1 := Container{Items: []int{1, 2, 3}}\n    c2 :=\
  \ Container{Items: []int{1, 2, 3}}\n    // c1 == c2  // ERROR: invalid operation!\n\
  \    ```\n\n    ### Struct Tags\n\n    **Metadata attached to struct fields:**\n\
  \    ```go\n    type User struct {\n        Name  string \\`json:\"name\"\\`\n \
  \       Email string \\`json:\"email\" validate:\"required,email\"\\`\n        Age\
  \   int    \\`json:\"age,omitempty\"\\`\n    }\n    ```\n\n    **Common uses:**\n\
  \    - JSON marshaling/unmarshaling\n    - Database column mapping\n    - Validation\
  \ rules\n    - Documentation\n\n    **Example with JSON:**\n    ```go\n    import\
  \ \"encoding/json\"\n\n    type Person struct {\n        Name string \\`json:\"\
  name\"\\`\n        Age  int    \\`json:\"age\"\\`\n    }\n\n    person := Person{Name:\
  \ \"Alice\", Age: 25}\n\n    // Marshal to JSON\n    jsonData, _ := json.Marshal(person)\n\
  \    fmt.Println(string(jsonData))\n    // Output: {\"name\":\"Alice\",\"age\":25}\n\
  \n    // Unmarshal from JSON\n    var p2 Person\n    json.Unmarshal(jsonData, &p2)\n\
  \    fmt.Println(p2.Name)  // \"Alice\"\n    ```\n\n    ### Zero Values for Structs\n\
  \n    **Uninitialized fields get zero values:**\n    ```go\n    type Stats struct\
  \ {\n        Count   int     // 0\n        Average float64 // 0.0\n        Name\
  \    string  // \"\"\n        Active  bool    // false\n    }\n\n    var stats Stats\n\
  \    fmt.Println(stats.Count)    // 0\n    fmt.Println(stats.Average)  // 0.0\n\
  \    fmt.Println(stats.Name)     // \"\"\n    fmt.Println(stats.Active)   // false\n\
  \    ```\n\n    ### Structs as Function Parameters\n\n    **Structs are passed by\
  \ value (copied):**\n    ```go\n    func updateAge(p Person, newAge int) {\n   \
  \     p.Age = newAge  // Modifies COPY, not original!\n    }\n\n    person := Person{Name:\
  \ \"Alice\", Age: 25}\n    updateAge(person, 26)\n    fmt.Println(person.Age)  //\
  \ Still 25! (original unchanged)\n    ```\n\n    **To modify original, use pointer\
  \ (covered in Pointers lesson):**\n    ```go\n    func updateAge(p *Person, newAge\
  \ int) {\n        p.Age = newAge  // Modifies original!\n    }\n\n    person :=\
  \ Person{Name: \"Alice\", Age: 25}\n    updateAge(&person, 26)\n    fmt.Println(person.Age)\
  \  // 26 (original modified)\n    ```\n\n    ### Practical Example: Modeling a Book\
  \ Store\n\n    ```go\n    type Book struct {\n        Title       string\n     \
  \   Author      string\n        ISBN        string\n        Price       float64\n\
  \        InStock     bool\n        PublishedYear int\n    }\n\n    type Order struct\
  \ {\n        OrderID   string\n        Customer  string\n        Books     []Book\
  \  // Slice of Books\n        Total     float64\n        CreatedAt time.Time\n \
  \   }\n\n    // Create books\n    book1 := Book{\n        Title:     \"The Go Programming\
  \ Language\",\n        Author:    \"Alan Donovan\",\n        ISBN:      \"978-0134190440\"\
  ,\n        Price:     44.99,\n        InStock:   true,\n        PublishedYear: 2015,\n\
  \    }\n\n    book2 := Book{\n        Title:     \"Learning Go\",\n        Author:\
  \    \"Jon Bodner\",\n        ISBN:      \"978-1492077213\",\n        Price:   \
  \  49.99,\n        InStock:   true,\n        PublishedYear: 2021,\n    }\n\n   \
  \ // Create order\n    order := Order{\n        OrderID:   \"ORD-001\",\n      \
  \  Customer:  \"Alice\",\n        Books:     []Book{book1, book2},\n        Total:\
  \     book1.Price + book2.Price,\n        CreatedAt: time.Now(),\n    }\n\n    fmt.Printf(\"\
  Order %s for %s: $%.2f\\\\n\",\n        order.OrderID, order.Customer, order.Total)\n\
  \    ```\n\n    ### Empty Struct\n\n    **The struct with no fields:**\n    ```go\n\
  \    type Empty struct{}\n    ```\n\n    **Why use it?**\n    - Takes **0 bytes**\
  \ of memory!\n    - Useful for signaling (like in channels)\n    - Used in sets\
  \ (map[string]struct{})\n\n    **Example: Set implementation**\n    ```go\n    //\
  \ Set of strings using empty struct\n    seen := make(map[string]struct{})\n\n \
  \   // Add to set\n    seen[\"apple\"] = struct{}{}\n    seen[\"banana\"] = struct{}{}\n\
  \n    // Check if in set\n    if _, exists := seen[\"apple\"]; exists {\n      \
  \  fmt.Println(\"apple is in the set\")\n    }\n    ```\n\n    ### Best Practices\n\
  \n    **1. Use meaningful field names:**\n    ```go\n    // ❌ Bad\n    type P struct\
  \ {\n        n string\n        a int\n    }\n\n    // ✅ Good\n    type Person struct\
  \ {\n        Name string\n        Age  int\n    }\n    ```\n\n    **2. Export only\
  \ what's necessary:**\n    ```go\n    type User struct {\n        Name     string\
  \  // Exported (public)\n        email    string  // Unexported (private)\n    \
  \    password string  // Unexported (private)\n    }\n    ```\n\n    **3. Use named\
  \ fields in literals:**\n    ```go\n    // ✅ Good - clear and maintainable\n   \
  \ person := Person{\n        Name: \"Alice\",\n        Age:  25,\n    }\n\n    //\
  \ ❌ Bad - hard to read, brittle\n    person := Person{\"Alice\", 25}\n    ```\n\n\
  \    **4. Consider using pointers for large structs:**\n    ```go\n    // Copying\
  \ a large struct is expensive\n    type LargeStruct struct {\n        Data [1000000]int\n\
  \    }\n\n    // ✅ Pass pointer instead\n    func process(s *LargeStruct) {\n  \
  \      // Work with pointer, no copying\n    }\n    ```\n\n    **5. Use composition\
  \ over complex nesting:**\n    ```go\n    // ✅ Good - flat and composable\n    type\
  \ Address struct {\n        Street, City, ZipCode string\n    }\n\n    type Person\
  \ struct {\n        Name string\n        Address Address\n    }\n\n    // ❌ Bad\
  \ - deeply nested\n    type Person struct {\n        Name string\n        Address\
  \ struct {\n            Street struct {\n                Number int\n          \
  \      Name string\n            }\n            City string\n        }\n    }\n \
  \   ```\n\n    ### When to Use Structs\n\n    **Use structs when:**\n    - ✅ Modeling\
  \ entities (User, Product, Order)\n    - ✅ Grouping related data\n    - ✅ Creating\
  \ custom types with methods\n    - ✅ Working with JSON/databases\n    - ✅ Need value\
  \ semantics (copy behavior)\n\n    **Don't use structs when:**\n    - ❌ Simple key-value\
  \ pairs (use map)\n    - ❌ Ordered collection (use slice)\n    - ❌ Only need one\
  \ field (use basic type)\n\n    ### Key Takeaways\n\n    1. Structs group related\
  \ fields into custom types\n    2. Use named field initialization for clarity\n\
  \    3. Struct embedding provides composition (not inheritance)\n    4. Structs\
  \ are passed by value (copied) by default\n    5. Zero values make structs safe\
  \ to use without initialization\n    6. Struct tags provide metadata for encoding/validation\n\
  \    7. Empty struct (struct{}) uses zero memory\n    8. Export fields (capital\
  \ letter) only when needed\n\n    **Next:** Learn about **Methods** to add behavior\
  \ to your structs!"
exercises:
  - type: mcq
    sequence_order: 1
    question: "What is the recommended way to create a struct instance with field names?"
    options:
      - "Person{\"Alice\", 25, \"alice@example.com\"}"
      - "Person{Name: \"Alice\", Age: 25, Email: \"alice@example.com\"}"
      - "new Person(\"Alice\", 25, \"alice@example.com\")"
      - "Person.Create(\"Alice\", 25, \"alice@example.com\")"
    correct_answer: "Person{Name: \"Alice\", Age: 25, Email: \"alice@example.com\"}"
    explanation: "Using named fields (field: value syntax) is the recommended way to create struct instances in Go. This approach has several advantages: (1) The order of fields doesn't matter, (2) You can omit optional fields (they'll get zero values), (3) It's self-documenting and clear what each value represents, (4) It's resistant to changes in struct definition. Example:\n\n```go\n// ✅ GOOD - explicit and maintainable\nperson := Person{\n    Name:  \"Alice\",\n    Age:   25,\n    Email: \"alice@example.com\",\n}\n\n// ❌ BAD - positional, brittle, unclear\nperson := Person{\"Alice\", 25, \"alice@example.com\"}\n```\n\nThe positional syntax (without field names) requires all fields in the exact order defined in the struct and breaks if the struct changes. Named syntax is more verbose but much safer and clearer, especially in production code and when working with larger structs."
    require_pass: true
  - type: mcq
    sequence_order: 2
    question: "What is struct embedding in Go and what does it provide?"
    options:
      - "A way to inherit methods from a parent class"
      - "A composition mechanism where embedded struct fields are promoted to the parent"
      - "A way to create private struct fields"
      - "A method to validate struct data"
    correct_answer: "A composition mechanism where embedded struct fields are promoted to the parent"
    explanation: "Struct embedding is Go's composition mechanism, not inheritance. When you embed a struct, its fields and methods are 'promoted' to the containing struct, allowing direct access. Example:\n\n```go\ntype Person struct {\n    Name string\n    Age  int\n}\n\ntype Employee struct {\n    Person        // Embedded (no field name)\n    EmployeeID string\n    Department string\n}\n\nemp := Employee{\n    Person: Person{Name: \"Bob\", Age: 30},\n    EmployeeID: \"E12345\",\n}\n\n// Can access directly (promoted)\nfmt.Println(emp.Name)  // \"Bob\"\n\n// Or through embedded struct\nfmt.Println(emp.Person.Name)  // \"Bob\"\n```\n\nThis is composition, not inheritance. Go doesn't have classes or inheritance. Embedding allows code reuse through composition, which is more flexible. If both structs have the same field name, you must use the full path (emp.Person.Name) to disambiguate. This design encourages 'composition over inheritance' principles."
    require_pass: true
  - type: mcq
    sequence_order: 3
    question: "Why can't you compare two structs if they contain a slice field?"
    options:
      - "Slices are always empty so comparison is meaningless"
      - "Slices are reference types that cannot be compared with =="
      - "This is a compiler bug in Go"
      - "You can compare them but it's slow"
    correct_answer: "Slices are reference types that cannot be compared with =="
    explanation: "Structs are only comparable if all their fields are comparable types. Slices, maps, and functions are not comparable with `==`, so structs containing them cannot be compared directly. Example:\n\n```go\ntype Point struct {\n    X, Y int\n}\n\np1 := Point{X: 1, Y: 2}\np2 := Point{X: 1, Y: 2}\nfmt.Println(p1 == p2)  // ✅ OK: true\n\ntype Container struct {\n    Items []int  // Slice makes it non-comparable\n}\n\nc1 := Container{Items: []int{1, 2, 3}}\nc2 := Container{Items: []int{1, 2, 3}}\n// c1 == c2  // ❌ ERROR: invalid operation\n\n// Instead, compare manually or use reflect.DeepEqual\nif reflect.DeepEqual(c1, c2) {\n    fmt.Println(\"Equal\")\n}\n```\n\nThis is because slices are reference types containing pointers to underlying arrays. Comparing pointers would check if they point to the same array, not if contents are equal. For deep comparison, use `reflect.DeepEqual()` or write custom comparison logic."
    require_pass: true
