slug: lesson-1
title: Lesson 1
difficulty: easy
sequence_order: 1
estimated_minutes: 2
key_concepts: []
prerequisites: []
content_md: "# Microlesson \U0001F680\n\n# Dynamic Programming Fundamentals\n\n  \
  \  **DP = Recursion + Memoization (or Tabulation)**\n\n    ## When to Use DP\n\n\
  \    1. **Optimal Substructure**: Solution can be built from subproblems\n    2.\
  \ **Overlapping Subproblems**: Same subproblems solved multiple times\n\n    ##\
  \ Fibonacci Example\n\n    ### Naive Recursion: O(2ⁿ)\n\n    ```python\n    def\
  \ fib(n):\n        if n <= 1:\n            return n\n        return fib(n-1) + fib(n-2)\n\
  \n    # fib(5) calls fib(3) twice, fib(2) three times!\n    # Exponential time!\n\
  \    ```\n\n    ### Memoization (Top-Down): O(n)\n\n    ```python\n    def fib_memo(n,\
  \ memo=None):\n        if memo is None:\n            memo = {}\n\n        if n in\
  \ memo:\n            return memo[n]\n\n        if n <= 1:\n            return n\n\
  \n        memo[n] = fib_memo(n-1, memo) + fib_memo(n-2, memo)\n        return memo[n]\n\
  \n    # Time: O(n), Space: O(n)\n    ```\n\n    ### Tabulation (Bottom-Up): O(n)\n\
  \n    ```python\n    def fib_tab(n):\n        if n <= 1:\n            return n\n\
  \n        dp = [0] * (n + 1)\n        dp[1] = 1\n\n        for i in range(2, n +\
  \ 1):\n            dp[i] = dp[i-1] + dp[i-2]\n\n        return dp[n]\n\n    # Time:\
  \ O(n), Space: O(n)\n    ```\n\n    ### Space-Optimized: O(1)\n\n    ```python\n\
  \    def fib_optimized(n):\n        if n <= 1:\n            return n\n\n       \
  \ prev, curr = 0, 1\n        for _ in range(2, n + 1):\n            prev, curr =\
  \ curr, prev + curr\n\n        return curr\n\n    # Time: O(n), Space: O(1)\n  \
  \  ```\n\n    ## Classic DP Problems\n\n    ### Climbing Stairs\n\n    ```python\n\
  \    def climb_stairs(n):\n        if n <= 2:\n            return n\n\n        dp\
  \ = [0] * (n + 1)\n        dp[1], dp[2] = 1, 2\n\n        for i in range(3, n +\
  \ 1):\n            dp[i] = dp[i-1] + dp[i-2]\n\n        return dp[n]\n\n    # Can\
  \ take 1 or 2 steps at a time\n    # How many ways to reach step n?\n    # Time:\
  \ O(n), Space: O(n)\n    ```\n\n    ### Coin Change\n\n    ```python\n    def coin_change(coins,\
  \ amount):\n        dp = [float('inf')] * (amount + 1)\n        dp[0] = 0\n\n  \
  \      for i in range(1, amount + 1):\n            for coin in coins:\n        \
  \        if i >= coin:\n                    dp[i] = min(dp[i], dp[i - coin] + 1)\n\
  \n        return dp[amount] if dp[amount] != float('inf') else -1\n\n    # Example:\
  \ coins = [1,2,5], amount = 11\n    # Output: 3 (5+5+1)\n    # Time: O(amount ×\
  \ coins), Space: O(amount)\n    ```\n\n    ### Longest Common Subsequence\n\n  \
  \  ```python\n    def longest_common_subsequence(text1, text2):\n        m, n =\
  \ len(text1), len(text2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n\
  \        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n    \
  \            if text1[i-1] == text2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\
  \ + 1\n                else:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n\
  \n        return dp[m][n]\n\n    # Example: \"abcde\", \"ace\" → 3\n    # Time:\
  \ O(m×n), Space: O(m×n)\n    ```\n\n    ### 0/1 Knapsack\n\n    ```python\n    def\
  \ knapsack(weights, values, capacity):\n        n = len(weights)\n        dp = [[0]\
  \ * (capacity + 1) for _ in range(n + 1)]\n\n        for i in range(1, n + 1):\n\
  \            for w in range(1, capacity + 1):\n                if weights[i-1] <=\
  \ w:\n                    # Max of: take item or don't take item\n             \
  \       dp[i][w] = max(\n                        values[i-1] + dp[i-1][w - weights[i-1]],\n\
  \                        dp[i-1][w]\n                    )\n                else:\n\
  \                    dp[i][w] = dp[i-1][w]\n\n        return dp[n][capacity]\n\n\
  \    # Time: O(n×capacity), Space: O(n×capacity)\n    ```\n\n    ### House Robber\n\
  \n    ```python\n    def rob(nums):\n        if not nums:\n            return 0\n\
  \        if len(nums) == 1:\n            return nums[0]\n\n        dp = [0] * len(nums)\n\
  \        dp[0] = nums[0]\n        dp[1] = max(nums[0], nums[1])\n\n        for i\
  \ in range(2, len(nums)):\n            # Max of: rob current + skip adjacent, or\
  \ skip current\n            dp[i] = max(nums[i] + dp[i-2], dp[i-1])\n\n        return\
  \ dp[-1]\n\n    # Can't rob adjacent houses\n    # Time: O(n), Space: O(n)\n   \
  \ ```\n\n    ## DP Pattern Recognition\n\n    ### 1D DP\n    - Fibonacci, Climbing\
  \ Stairs, House Robber\n    - Usually involves making decision at each step\n\n\
  \    ### 2D DP\n    - Longest Common Subsequence, Edit Distance, Knapsack\n    -\
  \ Usually involves two sequences or constraints\n\n    ### DP on Strings\n    -\
  \ LCS, Edit Distance, Palindrome Partitioning\n    - Build solution character by\
  \ character\n\n    ### DP on Trees\n    - Maximum Path Sum, Diameter of Binary Tree\n\
  \    - Solve for subtrees first\n\n    ## DP Approach\n\n    1. **Define dp state**:\
  \ What does dp[i] represent?\n    2. **Find recurrence relation**: dp[i] = function(dp[i-1],\
  \ dp[i-2], ...)\n    3. **Initialize base cases**: dp[0], dp[1]\n    4. **Determine\
  \ iteration order**: Usually bottom-up\n    5. **Return final answer**: Usually\
  \ dp[n]\n\n    ## Interview Tips\n\n    1. Start with brute force recursion\n  \
  \  2. Identify overlapping subproblems\n    3. Add memoization (top-down)\n    4.\
  \ Convert to tabulation if needed (bottom-up)\n    5. Optimize space if possible\n\
  \n    **Practice makes perfect with DP!**"
exercises:
  - type: mcq
    sequence_order: 1
    question: "What is the time complexity improvement when converting naive recursive Fibonacci to memoized version?"
    options:
      - "From O(n) to O(1)"
      - "From O(2^n) to O(n)"
      - "From O(n²) to O(n log n)"
      - "From O(n log n) to O(n)"
    correct_answer: "From O(2^n) to O(n)"
    explanation: "Naive recursive Fibonacci has exponential O(2^n) time complexity because it recalculates the same subproblems multiple times. For fib(5), it calls fib(3) twice and fib(2) three times, creating an exponential tree of redundant computations. Memoization caches each result, so fib(i) is calculated only once for each i from 0 to n, reducing complexity to O(n). This dramatic improvement—from exponential to linear—demonstrates DP's power. The space complexity becomes O(n) for the memo cache. For fib(40), naive recursion might take seconds, while memoized version completes instantly. This pattern applies to many DP problems: identify overlapping subproblems, cache results, achieve polynomial time instead of exponential. The improvement isn't from O(n) to O(1) (Fibonacci inherently requires at least O(n) time to compute n values) or the other options. Understanding this exponential-to-linear transformation is fundamental to recognizing when DP is beneficial."
    require_pass: true
  - type: mcq
    sequence_order: 2
    question: "In the 0/1 Knapsack problem, what does dp[i][w] represent?"
    options:
      - "The weight of item i"
      - "Whether item i fits in capacity w"
      - "The maximum value achievable using first i items with capacity w"
      - "The number of items with weight w"
    correct_answer: "The maximum value achievable using first i items with capacity w"
    explanation: "In 0/1 Knapsack DP, dp[i][w] represents the maximum total value that can be obtained by considering the first i items with a knapsack capacity of w. This state definition allows building the solution incrementally. For each item i and capacity w, we decide: (1) Include item i if it fits (weight[i] ≤ w), giving value[i] + dp[i-1][w-weight[i]], or (2) Exclude item i, giving dp[i-1][w]. We take the maximum. For example, with items of weights [2,3,4] and values [3,4,5], dp[2][5] represents max value using first 2 items (weights 2,3; values 3,4) with capacity 5, which is 7 (take both items). This builds up to dp[n][capacity] containing the final answer. The DP state must capture both which items we've considered (i) and our remaining capacity (w). It doesn't represent the weight of one item, a boolean fit check, or a count—it's the cumulative optimal value for a subproblem."
    require_pass: true
