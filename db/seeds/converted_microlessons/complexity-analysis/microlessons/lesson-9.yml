slug: lesson-9
title: Lesson 9
difficulty: easy
sequence_order: 9
estimated_minutes: 2
key_concepts: []
prerequisites: []
content_md: "# Microlesson \U0001F680\n\n# Stacks and Queues\n\n    ## Stack (LIFO\
  \ - Last In, First Out)\n\n    **Like a stack of plates - add/remove from top**\n\
  \n    ```python\n    class Stack:\n        def __init__(self):\n            self.items\
  \ = []\n\n        def push(self, item):\n            self.items.append(item)  #\
  \ O(1)\n\n        def pop(self):\n            if not self.is_empty():\n        \
  \        return self.items.pop()  # O(1)\n            return None\n\n        def\
  \ peek(self):\n            if not self.is_empty():\n                return self.items[-1]\
  \  # O(1)\n            return None\n\n        def is_empty(self):\n            return\
  \ len(self.items) == 0\n\n        def size(self):\n            return len(self.items)\n\
  \n    # All operations: O(1)\n    ```\n\n    ### Common Stack Problems\n\n    **Valid\
  \ Parentheses**\n\n    ```python\n    def is_valid(s):\n        stack = []\n   \
  \     mapping = {')': '(', '}': '{', ']': '['}\n\n        for char in s:\n     \
  \       if char in mapping:\n                top = stack.pop() if stack else '#'\n\
  \                if mapping[char] != top:\n                    return False\n  \
  \          else:\n                stack.append(char)\n\n        return len(stack)\
  \ == 0\n\n    # Time: O(n), Space: O(n)\n    # Example: \"({[]})\" → True\n    #\
  \          \"({[})\" → False\n    ```\n\n    **Evaluate Reverse Polish Notation**\n\
  \n    ```python\n    def eval_rpn(tokens):\n        stack = []\n        operators\
  \ = {'+', '-', '*', '/'}\n\n        for token in tokens:\n            if token in\
  \ operators:\n                b = stack.pop()\n                a = stack.pop()\n\
  \n                if token == '+': result = a + b\n                elif token ==\
  \ '-': result = a - b\n                elif token == '*': result = a * b\n     \
  \           else: result = int(a / b)\n\n                stack.append(result)\n\
  \            else:\n                stack.append(int(token))\n\n        return stack[0]\n\
  \n    # Example: [\"2\", \"1\", \"+\", \"3\", \"*\"] → ((2 + 1) * 3) = 9\n    ```\n\
  \n    ## Queue (FIFO - First In, First Out)\n\n    **Like a line of people - add\
  \ to back, remove from front**\n\n    ```python\n    from collections import deque\n\
  \n    class Queue:\n        def __init__(self):\n            self.items = deque()\n\
  \n        def enqueue(self, item):\n            self.items.append(item)  # O(1)\n\
  \n        def dequeue(self):\n            if not self.is_empty():\n            \
  \    return self.items.popleft()  # O(1)\n            return None\n\n        def\
  \ front(self):\n            if not self.is_empty():\n                return self.items[0]\
  \  # O(1)\n            return None\n\n        def is_empty(self):\n            return\
  \ len(self.items) == 0\n\n        def size(self):\n            return len(self.items)\n\
  \n    # All operations: O(1)\n    ```\n\n    ### Common Queue Problems\n\n    **Implement\
  \ Stack using Queues**\n\n    ```python\n    from collections import deque\n\n \
  \   class MyStack:\n        def __init__(self):\n            self.q = deque()\n\n\
  \        def push(self, x):\n            self.q.append(x)\n            # Rotate\
  \ to make last element first\n            for _ in range(len(self.q) - 1):\n   \
  \             self.q.append(self.q.popleft())\n\n        def pop(self):\n      \
  \      return self.q.popleft()\n\n        def top(self):\n            return self.q[0]\n\
  \    ```\n\n    **Sliding Window Maximum**\n\n    ```python\n    from collections\
  \ import deque\n\n    def max_sliding_window(nums, k):\n        result = []\n  \
  \      dq = deque()  # stores indices\n\n        for i, num in enumerate(nums):\n\
  \            # Remove indices outside window\n            while dq and dq[0] < i\
  \ - k + 1:\n                dq.popleft()\n\n            # Remove smaller elements\n\
  \            while dq and nums[dq[-1]] < num:\n                dq.pop()\n\n    \
  \        dq.append(i)\n\n            # Add to result after first window\n      \
  \      if i >= k - 1:\n                result.append(nums[dq[0]])\n\n        return\
  \ result\n\n    # Time: O(n), Space: O(k)\n    # Example: nums = [1,3,-1,-3,5,3,6,7],\
  \ k = 3\n    # Output: [3,3,5,5,6,7]\n    ```\n\n    ## Real-World Applications\n\
  \n    ### Stack\n    - **Browser history** (back button)\n    - **Undo/Redo** functionality\n\
  \    - **Function call stack**\n    - **Expression evaluation**\n    - **Backtracking\
  \ algorithms**\n\n    ### Queue\n    - **Task scheduling**\n    - **Breadth-First\
  \ Search (BFS)**\n    - **Print spooler**\n    - **Request handling** in web servers\n\
  \    - **Message queues** (RabbitMQ, Kafka)\n\n    **Next**: Trees and Graphs!"
exercises:
  - type: mcq
    sequence_order: 1
    question: "In the Valid Parentheses problem, why is a stack the ideal data structure to check if brackets are properly matched?"
    options:
      - "Stacks are faster than other data structures"
      - "LIFO property ensures the most recent opening bracket matches with the current closing bracket"
      - "Stacks use less memory than arrays"
      - "Stacks automatically sort the brackets"
    correct_answer: "LIFO property ensures the most recent opening bracket matches with the current closing bracket"
    explanation: "The Valid Parentheses problem requires checking if brackets like '(', '{', '[' are properly opened and closed in correct order. A stack's LIFO (Last In, First Out) property perfectly matches this requirement. When we encounter an opening bracket, we push it onto the stack. When we encounter a closing bracket, we need to check if it matches the most recently opened bracket, which is exactly what stack.pop() gives us. For example, in the string '({[]})', when we reach ']', the stack has '[' on top (most recent), which correctly matches. The implementation: for char in s: if char in opening: stack.append(char); else: if not stack or stack.pop() != mapping[char]: return False. This works because nested structures naturally follow LIFO ordering - the last opened must be first closed. Time complexity is O(n) with O(n) space. This pattern extends to many problems involving nested or hierarchical structures."
    require_pass: true

  - type: mcq
    sequence_order: 2
    question: "What is the time complexity of the Sliding Window Maximum algorithm using a deque, and why is it more efficient than a naive approach?"
    options:
      - "O(n log n) because we sort the window each time"
      - "O(nk) where k is window size, checking all elements in each window"
      - "O(n) because each element is added and removed from deque at most once"
      - "O(n²) because of nested iterations"
    correct_answer: "O(n) because each element is added and removed from deque at most once"
    explanation: "The Sliding Window Maximum problem asks for the maximum element in each window of size k as it slides through an array. A naive approach would check all k elements in each window, giving O(nk) complexity. The optimized deque solution achieves O(n) by maintaining indices in decreasing order of their values. The key insight is that each element is added to the deque once and removed at most once (either when it falls outside the window or when a larger element arrives). The implementation removes smaller elements from the back: while dq and nums[dq[-1]] < num: dq.pop(), and removes elements outside the window from the front: while dq and dq[0] < i - k + 1: dq.popleft(). The front always contains the index of the maximum in the current window. For an array of n elements, we perform at most 2n operations (n additions, n removals), giving O(n) time complexity with O(k) space. This demonstrates how the right data structure can dramatically improve performance."
    require_pass: true

  - type: mcq
    sequence_order: 3
    question: "Which real-world application is best suited for a queue (FIFO) rather than a stack (LIFO)?"
    options:
      - "Browser back button navigation"
      - "Function call management during recursion"
      - "Task scheduling system where jobs are processed in order of arrival"
      - "Undo/Redo functionality in text editors"
    correct_answer: "Task scheduling system where jobs are processed in order of arrival"
    explanation: "Queues follow FIFO (First In, First Out) ordering, making them ideal for scenarios where items should be processed in the order they arrive. A task scheduling system is a perfect example: jobs submitted first should be processed first to ensure fairness. The implementation would use enqueue() to add new jobs and dequeue() to get the next job to process. In contrast, stacks (LIFO) are suited for scenarios with reversal or backtracking: browser back buttons use a stack because you navigate back to the most recently visited page first; function calls use a call stack because the most recently called function must complete first; undo operations use a stack to reverse the most recent action first. The distinction is crucial: queues maintain arrival order (task scheduling, BFS traversal, message queues in RabbitMQ/Kafka), while stacks reverse order (recursion, backtracking, expression evaluation). Understanding when to use each data structure is fundamental to system design and algorithm implementation."
    require_pass: true
