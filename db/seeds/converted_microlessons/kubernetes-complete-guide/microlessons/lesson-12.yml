slug: lesson-12
title: Lesson 12
difficulty: easy
sequence_order: 12
estimated_minutes: 2
key_concepts: []
prerequisites: []
content_md: "# Microlesson \U0001F680\n\n# Services & Networking\n\n    Learn how\
  \ to expose your applications and enable communication between pods and external\
  \ clients.\n\n    ## Services\n\n    Services provide stable networking endpoints\
  \ for accessing pods. Types:\n\n    **ClusterIP (Default)**\n    - Internal-only\
  \ access\n    - Pods within cluster can communicate\n    - Use for internal microservices\n\
  \n    **NodePort**\n    - Exposes service on each node's IP\n    - External access\
  \ via <NodeIP>:<NodePort>\n    - Useful for development/testing\n\n    **LoadBalancer**\n\
  \    - Creates external load balancer\n    - Cloud provider integration required\n\
  \    - Production external access\n\n    **ExternalName**\n    - Maps service to\
  \ external DNS name\n    - No proxy or forwarding\n\n    ## DNS in Kubernetes\n\n\
  \    Every service gets a DNS name:\n    - Format: `<service-name>.<namespace>.svc.cluster.local`\n\
  \    - Pods can access services by name\n    - Automatic service discovery\n\n \
  \   ## Network Policies\n\n    Control traffic flow between pods:\n    - Ingress\
  \ rules: Incoming traffic\n    - Egress rules: Outgoing traffic\n    - Label-based\
  \ selection\n    - Namespace isolation\n\n    ## Essential Commands\n\n    ```bash\n\
  \    # Create service\n    kubectl expose deployment nginx --port=80 --type=LoadBalancer\n\
  \n    # List services\n    kubectl get services\n    kubectl get svc\n\n    # Describe\
  \ service\n    kubectl describe service nginx\n\n    # Test service connectivity\n\
  \    kubectl run curl --image=curlimages/curl -it --rm -- curl http://nginx\n  \
  \  ```\n\n    Practice service configuration in the labs!"
exercises:
- type: multiple_choice_question
  sequence_order: 2
  question: In Kubernetes RBAC, what is the primary purpose of a ServiceAccount?
  options:
  - To store application configuration
  - To provide an identity for processes running in pods to interact with the Kubernetes
    API
  - To manage network policies
  - To create persistent volumes
  correct_answer: To provide an identity for processes running in pods to interact
    with the Kubernetes API
  explanation: ServiceAccounts provide identities for processes running in pods, enabling
    them to authenticate with the Kubernetes API server and perform authorized operations.
    Every namespace has a 'default' ServiceAccount automatically assigned to pods
    that don't specify one. Applications running in pods can use the ServiceAccount's
    token (automatically mounted at /var/run/secrets/kubernetes.io/serviceaccount/token)
    to make API calls. Combined with RBAC (Roles and RoleBindings), ServiceAccounts
    control what API operations pods can perform. For example, a CI/CD tool running
    in a pod might need a ServiceAccount with permissions to create and update Deployments.
    ServiceAccounts are different from user accounts (for humans) - they're namespace-scoped
    and managed declaratively as Kubernetes resources. They don't store configuration
    (that's ConfigMaps/Secrets), manage network policies (that's NetworkPolicy resources),
    or create volumes (that's PersistentVolumeClaims). Understanding ServiceAccounts
    is crucial for implementing the principle of least privilege in Kubernetes applications.
  require_pass: true
- type: terminal
  sequence_order: 1
  command: kubectl expose deployment nginx --port=80 --type=LoadBalancer
  description: 'Practice the command: kubectl expose deployment nginx --port=80 --type=LoadBalancer'
  hints:
  - 'Try: kubectl expose deployment nginx --port=80 --type=LoadBalancer'
  - Use kubectl --help if you need help
  timeout_sec: 60
  require_pass: true
- type: terminal
  sequence_order: 2
  command: kubectl get services
  description: 'Practice the command: kubectl get services'
  hints:
  - 'Try: kubectl get services'
  - Use kubectl --help if you need help
  timeout_sec: 60
  require_pass: true
- type: mcq
  sequence_order: 3
  question: Which command creates a deployment with 3 replicas?
  options:
  - kubectl create deployment nginx --image=nginx --replicas=3
  - kubectl make deployment nginx replicas=3
  - kubectl deploy nginx --count=3
  - kubectl new deployment nginx x3
  correct_answer_index: 0
  explanation: kubectl create deployment creates a deployment. The --replicas flag
    specifies the number of pod replicas.
  require_pass: true
- type: code
  sequence_order: 4
  language: yaml
  question: Create a deployment with 3 replicas of nginx
  starter_code: '# Write your deployment YAML here

    apiVersion: apps/v1

    kind: Deployment

    '
  solution_code: "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\n\
    spec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n\
    \    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n\
    \      - name: nginx\n        image: nginx:1.25\n        ports:\n        - containerPort:\
    \ 80"
  hints:
  - 'Use apiVersion: apps/v1 for Deployments'
  - Set spec.replicas to 3
  - Define selector.matchLabels to match template.metadata.labels
  require_pass: true
