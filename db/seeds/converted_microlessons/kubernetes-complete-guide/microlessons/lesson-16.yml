slug: lesson-16
title: Lesson 16
difficulty: easy
sequence_order: 16
estimated_minutes: 2
key_concepts: []
prerequisites: []
content_md: "# Microlesson \U0001F680\n\n# Networking Deep Dive\n\n    Master advanced\
  \ networking concepts including Ingress, Network Policies, and troubleshooting techniques.\n\
  \n    ## Ingress\n\n    HTTP/HTTPS routing to services:\n    - Single external endpoint\n\
  \    - Path-based routing\n    - Virtual hosting\n    - TLS/SSL termination\n\n\
  \    **Ingress Controllers:**\n    - NGINX Ingress Controller\n    - Traefik\n \
  \   - HAProxy\n    - Cloud-specific (ALB, GCE)\n\n    **Example Ingress:**\n   \
  \ ```yaml\n    apiVersion: networking.k8s.io/v1\n    kind: Ingress\n    metadata:\n\
  \      name: my-ingress\n    spec:\n      rules:\n      - host: app.example.com\n\
  \        http:\n          paths:\n          - path: /api\n            pathType:\
  \ Prefix\n            backend:\n              service:\n                name: api-service\n\
  \                port:\n                  number: 80\n    ```\n\n    ## Network\
  \ Policies\n\n    Control traffic between pods:\n\n    **Default Behavior:** All\
  \ pods can communicate\n\n    **With NetworkPolicy:**\n    - Deny all, allow specific\n\
  \    - Label-based selection\n    - Namespace isolation\n    - Ingress and egress\
  \ rules\n\n    **Example Policy:**\n    ```yaml\n    apiVersion: networking.k8s.io/v1\n\
  \    kind: NetworkPolicy\n    metadata:\n      name: allow-frontend\n    spec:\n\
  \      podSelector:\n        matchLabels:\n          role: backend\n      ingress:\n\
  \      - from:\n        - podSelector:\n            matchLabels:\n             \
  \ role: frontend\n        ports:\n        - protocol: TCP\n          port: 8080\n\
  \    ```\n\n    ## Network Troubleshooting\n\n    **Common Issues:**\n    - Service\
  \ not accessible\n    - DNS resolution failures\n    - Network policy blocking traffic\n\
  \    - Ingress misconfiguration\n\n    **Debugging Tools:**\n    ```bash\n    #\
  \ Test service connectivity\n    kubectl run debug --image=nicolaka/netshoot -it\
  \ --rm -- bash\n\n    # DNS lookup\n    nslookup my-service\n\n    # Check endpoints\n\
  \    kubectl get endpoints\n\n    # Test port connectivity\n    nc -zv my-service\
  \ 80\n    ```\n\n    ## Service Mesh (Introduction)\n\n    Advanced traffic management:\n\
  \    - Istio, Linkerd, Consul\n    - Traffic splitting\n    - Circuit breaking\n\
  \    - Observability\n\n    Practice networking in the hands-on labs!"
exercises:
- type: multiple_choice_question
  sequence_order: 2
  question: In Kubernetes RBAC, what is the primary purpose of a ServiceAccount?
  options:
  - To store application configuration
  - To provide an identity for processes running in pods to interact with the Kubernetes
    API
  - To manage network policies
  - To create persistent volumes
  correct_answer: To provide an identity for processes running in pods to interact
    with the Kubernetes API
  explanation: ServiceAccounts provide identities for processes running in pods, enabling
    them to authenticate with the Kubernetes API server and perform authorized operations.
    Every namespace has a 'default' ServiceAccount automatically assigned to pods
    that don't specify one. Applications running in pods can use the ServiceAccount's
    token (automatically mounted at /var/run/secrets/kubernetes.io/serviceaccount/token)
    to make API calls. Combined with RBAC (Roles and RoleBindings), ServiceAccounts
    control what API operations pods can perform. For example, a CI/CD tool running
    in a pod might need a ServiceAccount with permissions to create and update Deployments.
    ServiceAccounts are different from user accounts (for humans) - they're namespace-scoped
    and managed declaratively as Kubernetes resources. They don't store configuration
    (that's ConfigMaps/Secrets), manage network policies (that's NetworkPolicy resources),
    or create volumes (that's PersistentVolumeClaims). Understanding ServiceAccounts
    is crucial for implementing the principle of least privilege in Kubernetes applications.
  require_pass: true
- type: terminal
  sequence_order: 1
  command: kubectl run debug --image=nicolaka/netshoot -it --rm -- bash
  description: 'Practice the command: kubectl run debug --image=nicolaka/netshoot
    -it --rm -- bash'
  hints:
  - 'Try: kubectl run debug --image=nicolaka/netshoot -it --rm -- bash'
  - Use kubectl --help if you need help
  timeout_sec: 60
  require_pass: true
- type: terminal
  sequence_order: 2
  command: kubectl get endpoints
  description: 'Practice the command: kubectl get endpoints'
  hints:
  - 'Try: kubectl get endpoints'
  - Use kubectl --help if you need help
  timeout_sec: 60
  require_pass: true
- type: mcq
  sequence_order: 3
  question: What command lists all pods in all namespaces?
  options:
  - kubectl get pods -A
  - kubectl list pods --all
  - kubectl get pods --everywhere
  - kubectl pods list -A
  correct_answer_index: 0
  explanation: kubectl get pods -A (or --all-namespaces) lists pods across all namespaces.
    The -A flag is shorthand for --all-namespaces.
  require_pass: true
