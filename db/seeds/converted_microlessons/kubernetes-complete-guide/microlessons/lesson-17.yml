slug: lesson-17
title: Lesson 17
difficulty: easy
sequence_order: 17
estimated_minutes: 2
key_concepts: []
prerequisites: []
content_md: "# Microlesson \U0001F680\n\n# Observability\n\n    Learn to monitor,\
  \ log, and debug applications running in Kubernetes clusters.\n\n    ## Health Checks\n\
  \n    **Liveness Probes**\n    - Is container alive?\n    - Kubelet restarts failed\
  \ containers\n    - Use for detecting deadlocks\n\n    **Readiness Probes**\n  \
  \  - Is container ready to serve traffic?\n    - Removes pod from service endpoints\
  \ if fails\n    - Use during startup or temporary unavailability\n\n    **Startup\
  \ Probes**\n    - Has application started?\n    - Useful for slow-starting applications\n\
  \    - Prevents liveness probe from interfering\n\n    **Probe Types:**\n    - **HTTP\
  \ GET**: Check HTTP endpoint\n    - **TCP Socket**: Check TCP connection\n    -\
  \ **Exec**: Execute command in container\n\n    ## Logging\n\n    **Container Logs:**\n\
  \    ```bash\n    # View logs\n    kubectl logs pod-name\n\n    # Follow logs\n\
  \    kubectl logs -f pod-name\n\n    # Previous container logs\n    kubectl logs\
  \ pod-name --previous\n\n    # Specific container in pod\n    kubectl logs pod-name\
  \ -c container-name\n\n    # All pods with label\n    kubectl logs -l app=nginx\n\
  \    ```\n\n    **Logging Architecture:**\n    - **Node-level**: Log files on nodes\n\
  \    - **Cluster-level**: Centralized logging (ELK, Splunk, Loki)\n    - **Application-level**:\
  \ Direct to logging service\n\n    ## Monitoring\n\n    **Metrics Server:**\n  \
  \  - Resource usage metrics\n    - `kubectl top nodes/pods`\n    - Horizontal Pod\
  \ Autoscaler input\n\n    **Prometheus Stack:**\n    - Metrics collection\n    -\
  \ Alerting rules\n    - Grafana dashboards\n    - Custom metrics\n\n    ## Debugging\n\
  \n    **Describe Resources:**\n    ```bash\n    # Pod details and events\n    kubectl\
  \ describe pod pod-name\n\n    # Node details\n    kubectl describe node node-name\n\
  \    ```\n\n    **Execute Commands:**\n    ```bash\n    # Interactive shell\n  \
  \  kubectl exec -it pod-name -- /bin/bash\n\n    # Run command\n    kubectl exec\
  \ pod-name -- ls /app\n    ```\n\n    **Port Forwarding:**\n    ```bash\n    # Forward\
  \ local port to pod\n    kubectl port-forward pod-name 8080:80\n\n    # Forward\
  \ to service\n    kubectl port-forward service/my-service 8080:80\n    ```\n\n \
  \   **Copy Files:**\n    ```bash\n    # From pod to local\n    kubectl cp pod-name:/path/to/file\
  \ ./local-file\n\n    # From local to pod\n    kubectl cp ./local-file pod-name:/path/to/file\n\
  \    ```\n\n    ## Common Issues\n\n    **CrashLoopBackOff:**\n    - Application\
  \ exits immediately\n    - Check logs: `kubectl logs pod-name --previous`\n    -\
  \ Review resource limits\n    - Verify liveness probe configuration\n\n    **ImagePullBackOff:**\n\
  \    - Cannot pull container image\n    - Check image name and tag\n    - Verify\
  \ registry credentials\n    - Check imagePullSecrets\n\n    **Pending Pods:**\n\
  \    - Insufficient resources\n    - Node selector not matching\n    - PVC not bound\n\
  \    - Check events: `kubectl describe pod`\n\n    Master debugging in the practical\
  \ labs!"
exercises:
- type: multiple_choice_question
  sequence_order: 2
  question: In Kubernetes RBAC, what is the primary purpose of a ServiceAccount?
  options:
  - To store application configuration
  - To provide an identity for processes running in pods to interact with the Kubernetes
    API
  - To manage network policies
  - To create persistent volumes
  correct_answer: To provide an identity for processes running in pods to interact
    with the Kubernetes API
  explanation: ServiceAccounts provide identities for processes running in pods, enabling
    them to authenticate with the Kubernetes API server and perform authorized operations.
    Every namespace has a 'default' ServiceAccount automatically assigned to pods
    that don't specify one. Applications running in pods can use the ServiceAccount's
    token (automatically mounted at /var/run/secrets/kubernetes.io/serviceaccount/token)
    to make API calls. Combined with RBAC (Roles and RoleBindings), ServiceAccounts
    control what API operations pods can perform. For example, a CI/CD tool running
    in a pod might need a ServiceAccount with permissions to create and update Deployments.
    ServiceAccounts are different from user accounts (for humans) - they're namespace-scoped
    and managed declaratively as Kubernetes resources. They don't store configuration
    (that's ConfigMaps/Secrets), manage network policies (that's NetworkPolicy resources),
    or create volumes (that's PersistentVolumeClaims). Understanding ServiceAccounts
    is crucial for implementing the principle of least privilege in Kubernetes applications.
  require_pass: true
- type: terminal
  sequence_order: 1
  command: kubectl logs pod-name
  description: 'Practice the command: kubectl logs pod-name'
  hints:
  - 'Try: kubectl logs pod-name'
  - Use kubectl --help if you need help
  timeout_sec: 60
  require_pass: true
- type: terminal
  sequence_order: 2
  command: kubectl logs -f pod-name
  description: 'Practice the command: kubectl logs -f pod-name'
  hints:
  - 'Try: kubectl logs -f pod-name'
  - Use kubectl --help if you need help
  timeout_sec: 60
  require_pass: true
- type: mcq
  sequence_order: 3
  question: What command lists all pods in all namespaces?
  options:
  - kubectl get pods -A
  - kubectl list pods --all
  - kubectl get pods --everywhere
  - kubectl pods list -A
  correct_answer_index: 0
  explanation: kubectl get pods -A (or --all-namespaces) lists pods across all namespaces.
    The -A flag is shorthand for --all-namespaces.
  require_pass: true
