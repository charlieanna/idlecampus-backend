slug: k8s-07-networking-deep-dive
title: K8s 07 Networking Deep Dive
difficulty: easy
sequence_order: 7
estimated_minutes: 2
key_concepts: []
prerequisites: []
content_md: "# Microlesson \U0001F680\n\n# Networking Deep Dive\n\n    Master advanced\
  \ networking concepts including Ingress, Network Policies, and troubleshooting techniques.\n\
  \n    ## Ingress\n\n    HTTP/HTTPS routing to services:\n    - Single external endpoint\n\
  \    - Path-based routing\n    - Virtual hosting\n    - TLS/SSL termination\n\n\
  \    **Ingress Controllers:**\n    - NGINX Ingress Controller\n    - Traefik\n \
  \   - HAProxy\n    - Cloud-specific (ALB, GCE)\n\n    **Example Ingress:**\n   \
  \ ```yaml\n    apiVersion: networking.k8s.io/v1\n    kind: Ingress\n    metadata:\n\
  \      name: my-ingress\n    spec:\n      rules:\n      - host: app.example.com\n\
  \        http:\n          paths:\n          - path: /api\n            pathType:\
  \ Prefix\n            backend:\n              service:\n                name: api-service\n\
  \                port:\n                  number: 80\n    ```\n\n    ## Network\
  \ Policies\n\n    Control traffic between pods:\n\n    **Default Behavior:** All\
  \ pods can communicate\n\n    **With NetworkPolicy:**\n    - Deny all, allow specific\n\
  \    - Label-based selection\n    - Namespace isolation\n    - Ingress and egress\
  \ rules\n\n    **Example Policy:**\n    ```yaml\n    apiVersion: networking.k8s.io/v1\n\
  \    kind: NetworkPolicy\n    metadata:\n      name: allow-frontend\n    spec:\n\
  \      podSelector:\n        matchLabels:\n          role: backend\n      ingress:\n\
  \      - from:\n        - podSelector:\n            matchLabels:\n             \
  \ role: frontend\n        ports:\n        - protocol: TCP\n          port: 8080\n\
  \    ```\n\n    ## Network Troubleshooting\n\n    **Common Issues:**\n    - Service\
  \ not accessible\n    - DNS resolution failures\n    - Network policy blocking traffic\n\
  \    - Ingress misconfiguration\n\n    **Debugging Tools:**\n    ```bash\n    #\
  \ Test service connectivity\n    kubectl run debug --image=nicolaka/netshoot -it\
  \ --rm -- bash\n\n    # DNS lookup\n    nslookup my-service\n\n    # Check endpoints\n\
  \    kubectl get endpoints\n\n    # Test port connectivity\n    nc -zv my-service\
  \ 80\n    ```\n\n    ## Service Mesh (Introduction)\n\n    Advanced traffic management:\n\
  \    - Istio, Linkerd, Consul\n    - Traffic splitting\n    - Circuit breaking\n\
  \    - Observability\n\n    Practice networking in the hands-on labs!"
exercises:
- type: multiple_choice_question
  sequence_order: 1
  question: What is the primary purpose of an Ingress resource in Kubernetes?
  options:
  - To provide persistent storage for applications
  - To expose HTTP/HTTPS routes from outside the cluster to services within the cluster
  - To monitor application health
  - To manage pod replicas
  correct_answer: To expose HTTP/HTTPS routes from outside the cluster to services
    within the cluster
  explanation: Ingress provides HTTP and HTTPS routing from outside the cluster to
    services within the cluster, acting as a layer 7 (application layer) load balancer
    with advanced routing capabilities. Unlike LoadBalancer services which require
    a separate external load balancer for each service, a single Ingress can route
    traffic to multiple services based on hostnames and URL paths, providing features
    like virtual hosting, path-based routing, and TLS/SSL termination. For example,
    one Ingress can route app.example.com/api to an API service and app.example.com/web
    to a web service, all through a single external IP. Ingress requires an Ingress
    Controller (like NGINX, Traefik, or cloud-specific controllers) to be installed
    in the cluster to actually implement the routing rules. This makes Ingress more
    efficient and cost-effective than using multiple LoadBalancer services. Ingress
    doesn't handle storage (that's PersistentVolumes), health monitoring (that's probes),
    or replica management (that's Deployments/ReplicaSets). Understanding Ingress
    is crucial for exposing web applications efficiently in production Kubernetes
    environments.
  require_pass: true
- type: multiple_choice_question
  sequence_order: 2
  question: What is the default network policy behavior in Kubernetes if no NetworkPolicy
    is applied?
  options:
  - All traffic is denied by default
  - All pods can communicate with each other freely
  - Only pods in the same namespace can communicate
  - Only pods with matching labels can communicate
  correct_answer: All pods can communicate with each other freely
  explanation: By default, Kubernetes operates with no network restrictions - all
    pods can communicate with all other pods across all namespaces, and all pods can
    reach external networks. This open communication model simplifies initial development
    but isn't secure for production multi-tenant environments. Network Policies allow
    you to implement a 'deny by default, allow explicitly' security model by defining
    ingress (incoming) and egress (outgoing) traffic rules based on pod labels, namespaces,
    and IP blocks. Once you apply a NetworkPolicy to pods (via label selectors), those
    pods are isolated and can only communicate according to the policy rules. For
    example, you could create a policy allowing only frontend pods to communicate
    with backend pods on specific ports, blocking all other traffic. Network Policies
    require a CNI (Container Network Interface) plugin that supports them, like Calico,
    Cilium, or Weave. Not all CNI plugins support NetworkPolicies - the basic kubenet
    doesn't. Implementing proper Network Policies is essential for microsegmentation
    and zero-trust security in production Kubernetes clusters.
  require_pass: true
- type: terminal
  sequence_order: 1
  command: kubectl run debug --image=nicolaka/netshoot -it --rm -- bash
  description: 'Practice the command: kubectl run debug --image=nicolaka/netshoot
    -it --rm -- bash'
  hints:
  - 'Try: kubectl run debug --image=nicolaka/netshoot -it --rm -- bash'
  - Use kubectl --help if you need help
  timeout_sec: 60
  require_pass: true
- type: terminal
  sequence_order: 2
  command: kubectl get endpoints
  description: 'Practice the command: kubectl get endpoints'
  hints:
  - 'Try: kubectl get endpoints'
  - Use kubectl --help if you need help
  timeout_sec: 60
  require_pass: true
- type: mcq
  sequence_order: 3
  question: What command lists all pods in all namespaces?
  options:
  - kubectl get pods -A
  - kubectl list pods --all
  - kubectl get pods --everywhere
  - kubectl pods list -A
  correct_answer_index: 0
  explanation: kubectl get pods -A (or --all-namespaces) lists pods across all namespaces.
    The -A flag is shorthand for --all-namespaces.
  require_pass: true
