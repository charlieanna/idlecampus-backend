[
  {
    "family_id": "array-basics-001",
    "title": "Array Basics",
    "content": "# Array Basics\n\nFundamental operations on arrays including traversal, access, and manipulation\n\n---\n\n## What are Arrays?\n\nArrays are contiguous memory blocks that store elements of the same type. They provide O(1) random access but O(n) insertion/deletion.\n\n**Key Properties:**\n- Fixed or dynamic size\n- Zero-indexed access\n- Contiguous memory allocation\n- Cache-friendly due to locality\n\n**Time Complexities:**\n- Access: O(1)\n- Search (unsorted): O(n)\n- Insert at end: O(1) amortized\n- Insert at position: O(n)\n- Delete: O(n)\n\n\n---\n\n## Common Patterns\n\n### 1. Iteration\n```python\nfor i in range(len(arr)):\n    process(arr[i])\n```\n\n### 2. Reverse Iteration\n```python\nfor i in range(len(arr) - 1, -1, -1):\n    process(arr[i])\n```\n\n### 3. In-place Modification\n```python\nfor i in range(len(arr)):\n    arr[i] = transform(arr[i])\n```\n\n\n---\n\n## When to Use This Technique\n\nUse arrays when you need fast random access, know the size in advance, or need cache-efficient sequential access.\n\n---\n\n## Common Pitfalls to Avoid\n\n- Index out of bounds errors\n- Not considering edge cases (empty array, single element)\n- Forgetting that arrays are zero-indexed\n- Modifying array while iterating\n\n---\n\n## Practice Problems\n\nStart with these problems to master this concept:\n\n### 1. Two Sum [Easy]\n\nGiven an array of integers nums and an integer target, return indices of the two numbers that add up to target.\n\n**Complexity:** Time O(O(n)), Space O(O(n))\n\n**Hint:** Use a hash map to store numbers you've seen\n\n\n### 2. Two Sum II - Input Array Is Sorted [Easy]\n\nGiven a sorted array, find two numbers that add up to a specific target.\n\n**Complexity:** Time O(O(n)), Space O(O(1))\n\n**Hint:** Use two pointers from both ends\n\n\n### 3. Two Sum - Data Structure Design [Easy]\n\nDesign a data structure that supports add and find operations for two sum.\n\n**Complexity:** Time O(O(1) add, O(n) find), Space O(O(n))\n\n\n### 4. Two Sum Less Than K [Easy]\n\nFind the maximum sum of two numbers less than K.\n\n**Complexity:** Time O(O(n log n)), Space O(O(1))\n\n\n### 5. Two Sum BST [Easy]\n\nFind if there exist two elements in a BST that sum to target.\n\n**Complexity:** Time O(O(n)), Space O(O(n))\n\n\n\n---\n\n## Key Takeaways\n\n- Array Basics is essential for fundamental operations on arrays including traversal, access, and manipulation\n- Time complexity improvements can be significant with this technique\n- Practice problems in order of difficulty to build intuition\n- Focus on recognizing patterns in problem statements\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Array Basics"
    ],
    "problem_count": 15
  },
  {
    "family_id": "array-sliding-window-002",
    "title": "Sliding Window",
    "content": "# Sliding Window\n\nEfficient technique for processing subarrays or substrings by maintaining a window\n\n---\n\n## Sliding Window Technique\n\nThe sliding window pattern is used to solve problems involving subarrays, substrings, or sequential data where you need to find optimal subarrays.\n\n**Types of Sliding Windows:**\n\n### 1. Fixed-Size Window\nWindow size is predetermined and constant throughout.\n\n### 2. Dynamic-Size Window\nWindow expands and contracts based on conditions.\n\n**Key Characteristics:**\n- Reduces time complexity from O(n²) or O(n³) to O(n)\n- Maintains state as window moves\n- Uses two pointers (left and right)\n\n**When Window is Valid:**\n- Fixed size: when right - left + 1 == k\n- Dynamic: when condition is satisfied\n\n\n---\n\n## Common Patterns\n\n### Pattern 1: Fixed Window\n```python\ndef fixed_window(arr, k):\n    window_sum = sum(arr[:k])  # Initial window\n    max_sum = window_sum\n\n    for i in range(k, len(arr)):\n        # Slide window: remove left, add right\n        window_sum = window_sum - arr[i-k] + arr[i]\n        max_sum = max(max_sum, window_sum)\n\n    return max_sum\n```\n\n### Pattern 2: Dynamic Window (Expand/Contract)\n```python\ndef dynamic_window(s):\n    left = 0\n    char_set = set()\n    max_length = 0\n\n    for right in range(len(s)):\n        # Expand window\n        while s[right] in char_set:\n            # Contract window if invalid\n            char_set.remove(s[left])\n            left += 1\n\n        char_set.add(s[right])\n        max_length = max(max_length, right - left + 1)\n\n    return max_length\n```\n\n### Pattern 3: Window with HashMap\n```python\ndef window_with_map(s, k):\n    char_count = {}\n    left = 0\n\n    for right in range(len(s)):\n        char_count[s[right]] = char_count.get(s[right], 0) + 1\n\n        # Maintain window constraint\n        if len(char_count) > k:\n            char_count[s[left]] -= 1\n            if char_count[s[left]] == 0:\n                del char_count[s[left]]\n            left += 1\n```\n\n\n---\n\n## When to Use This Technique\n\nUse sliding window for problems involving contiguous subarrays/substrings, finding min/max/optimal subarray, or problems with \"longest/shortest/maximum/minimum substring/subarray\" keywords.\n\n---\n\n## Common Pitfalls to Avoid\n\n- Not handling window shrinking correctly\n- Off-by-one errors in window size calculation\n- Forgetting to update window state when sliding\n- Not initializing the first window properly\n- Confusing when to expand vs contract\n\n---\n\n## Practice Problems\n\nStart with these problems to master this concept:\n\n### 1. Maximum Sum Subarray of Size K [Easy]\n\nFind maximum sum of any contiguous subarray of size k.\n\n**Complexity:** Time O(O(n)), Space O(O(1))\n\n\n### 2. Minimum Window Substring [Hard]\n\nFind minimum window in S that contains all characters of T.\n\n**Complexity:** Time O(O(m+n)), Space O(O(m+n))\n\n\n### 3. Substring with Concatenation of All Words [Hard]\n\nFind substrings that are concatenation of all words.\n\n**Complexity:** Time O(O(n*m*len)), Space O(O(m))\n\n\n### 4. Longest Substring Without Repeating Characters [Medium]\n\nFind length of longest substring without repeating characters.\n\n**Complexity:** Time O(O(n)), Space O(O(min(m,n)))\n\n\n### 5. Longest Substring with At Most K Distinct Characters [Medium]\n\nFind longest substring with at most k distinct characters.\n\n**Complexity:** Time O(O(n)), Space O(O(k))\n\n\n\n---\n\n## Key Takeaways\n\n- Sliding Window is essential for efficient technique for processing subarrays or substrings by maintaining a window\n- Time complexity improvements can be significant with this technique\n- Practice problems in order of difficulty to build intuition\n- Focus on recognizing patterns in problem statements\n",
    "reading_time_minutes": 15,
    "key_concepts": [
      "Sliding Window",
      "Fixed Window"
    ],
    "problem_count": 10
  },
  {
    "family_id": "array-prefix-sum-003",
    "title": "Prefix Sum",
    "content": "# Prefix Sum\n\nPrecomputing cumulative sums for efficient range sum queries\n\n---\n\n## Prefix Sum Technique\n\nPrefix sum (or cumulative sum) is a preprocessing technique where we compute the sum of elements from the start up to each index.\n\n**Definition:**\n```\nprefix[i] = arr[0] + arr[1] + ... + arr[i]\n```\n\n**Key Insight:**\nRange sum from index i to j can be computed in O(1):\n```\nsum(i, j) = prefix[j] - prefix[i-1]\n```\n\n**Applications:**\n- Range sum queries\n- Subarray sum problems\n- Count subarrays with given sum\n- 2D matrix sum queries\n\n**Complexity:**\n- Preprocessing: O(n)\n- Query: O(1)\n- Space: O(n)\n\n\n---\n\n## Common Patterns\n\n### Pattern 1: Basic Prefix Sum\n```python\ndef build_prefix_sum(arr):\n    prefix = [0] * (len(arr) + 1)  # Extra space for easier range query\n\n    for i in range(len(arr)):\n        prefix[i + 1] = prefix[i] + arr[i]\n\n    return prefix\n\ndef range_sum(prefix, i, j):\n    \"\"\"Sum from index i to j (inclusive)\"\"\"\n    return prefix[j + 1] - prefix[i]\n```\n\n### Pattern 2: Prefix Sum with HashMap (Subarray Sum = K)\n```python\ndef subarray_sum_equals_k(arr, k):\n    prefix_sum = 0\n    sum_count = {0: 1}  # Handle subarrays starting from index 0\n    count = 0\n\n    for num in arr:\n        prefix_sum += num\n\n        # If (prefix_sum - k) exists, we found subarrays\n        if prefix_sum - k in sum_count:\n            count += sum_count[prefix_sum - k]\n\n        sum_count[prefix_sum] = sum_count.get(prefix_sum, 0) + 1\n\n    return count\n```\n\n### Pattern 3: 2D Prefix Sum\n```python\ndef build_2d_prefix(matrix):\n    rows, cols = len(matrix), len(matrix[0])\n    prefix = [[0] * (cols + 1) for _ in range(rows + 1)]\n\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            prefix[i][j] = (matrix[i-1][j-1] +\n                           prefix[i-1][j] +\n                           prefix[i][j-1] -\n                           prefix[i-1][j-1])\n    return prefix\n\ndef query_2d(prefix, r1, c1, r2, c2):\n    \"\"\"Sum of submatrix from (r1,c1) to (r2,c2)\"\"\"\n    return (prefix[r2+1][c2+1] -\n           prefix[r1][c2+1] -\n           prefix[r2+1][c1] +\n           prefix[r1][c1])\n```\n\n\n---\n\n## When to Use This Technique\n\nUse prefix sum when you have multiple range sum queries, need to find subarrays with specific sum properties, or optimize subarray sum calculations from O(n) to O(1) per query.\n\n---\n\n## Common Pitfalls to Avoid\n\n- Off-by-one errors in indexing\n- Not handling empty subarrays (prefix[0] = 0)\n- Forgetting to include overlap correction in 2D prefix sum\n- Not considering negative numbers in sum\n- Overflow issues with large sums\n\n---\n\n## Practice Problems\n\nStart with these problems to master this concept:\n\n### 1. Range Sum Query - Immutable [Easy]\n\nCalculate sum of elements between indices i and j.\n\n**Complexity:** Time O(O(1) query, O(n) init), Space O(O(n))\n\n\n### 2. Range Sum Query 2D - Immutable [Medium]\n\nCalculate sum of elements in 2D matrix region.\n\n**Complexity:** Time O(O(1) query, O(mn) init), Space O(O(mn))\n\n\n### 3. Product of Array Except Self [Medium]\n\nReturn array where each element is product of all others.\n\n**Complexity:** Time O(O(n)), Space O(O(1))\n\n\n### 4. Contiguous Array [Medium]\n\nFind maximum length subarray with equal number of 0s and 1s.\n\n**Complexity:** Time O(O(n)), Space O(O(n))\n\n\n### 5. Maximum Size Subarray Sum Equals k [Medium]\n\nFind maximum length of subarray that sums to k.\n\n**Complexity:** Time O(O(n)), Space O(O(n))\n\n\n\n---\n\n## Key Takeaways\n\n- Prefix Sum is essential for precomputing cumulative sums for efficient range sum queries\n- Time complexity improvements can be significant with this technique\n- Practice problems in order of difficulty to build intuition\n- Focus on recognizing patterns in problem statements\n",
    "reading_time_minutes": 15,
    "key_concepts": [
      "Prefix Sum",
      "Basic Prefix Sum"
    ],
    "problem_count": 5
  },
  {
    "family_id": "array-two-pointers-004",
    "title": "Two Pointers",
    "content": "# Two Pointers\n\nUsing two pointers moving toward each other or in same direction to solve array problems efficiently\n\n---\n\n## Two Pointers Technique\n\nTwo pointers is an algorithmic pattern where we use two indices to traverse data structures, typically arrays or linked lists.\n\n**Types:**\n\n### 1. Opposite Direction (Converging)\nPointers start at both ends and move toward each other.\n- **Use cases:** Palindrome check, pair sum problems, reversing\n\n### 2. Same Direction (Chasing)\nBoth pointers move in the same direction at different speeds.\n- **Use cases:** Removing duplicates, partitioning, fast-slow pointer\n\n### 3. Sliding Window (Special Case)\nLeft and right pointers define a window that slides/expands.\n\n**Time Complexity:** Usually O(n) - each pointer traverses once\n\n\n---\n\n## Common Patterns\n\n### Pattern 1: Opposite Direction\n```python\ndef two_sum_sorted(arr, target):\n    left, right = 0, len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1  # Need larger sum\n        else:\n            right -= 1  # Need smaller sum\n\n    return []\n```\n\n### Pattern 2: Same Direction (Remove Duplicates)\n```python\ndef remove_duplicates(arr):\n    if not arr:\n        return 0\n\n    write_ptr = 1  # Where to write next unique element\n\n    for read_ptr in range(1, len(arr)):\n        if arr[read_ptr] != arr[read_ptr - 1]:\n            arr[write_ptr] = arr[read_ptr]\n            write_ptr += 1\n\n    return write_ptr  # New length\n```\n\n### Pattern 3: Partition (Dutch National Flag)\n```python\ndef partition(arr, pivot):\n    left, right = 0, len(arr) - 1\n    i = 0\n\n    while i <= right:\n        if arr[i] < pivot:\n            arr[i], arr[left] = arr[left], arr[i]\n            left += 1\n            i += 1\n        elif arr[i] > pivot:\n            arr[i], arr[right] = arr[right], arr[i]\n            right -= 1\n        else:\n            i += 1\n```\n\n\n---\n\n## When to Use This Technique\n\nUse two pointers for sorted arrays, palindrome problems, pair/triplet sums, partitioning, or when you need to optimize from O(n²) to O(n).\n\n---\n\n## Common Pitfalls to Avoid\n\n- Not handling edge cases (empty, single element)\n- Off-by-one errors in pointer boundaries\n- Infinite loops from not moving pointers\n- Using two pointers on unsorted data (when sorting is required)\n- Forgetting to check left < right condition\n\n---\n\n## Practice Problems\n\nStart with these problems to master this concept:\n\n### 1. Remove Duplicates from Sorted Array [Easy]\n\nRemove duplicates in-place from sorted array.\n\n**Complexity:** Time O(O(n)), Space O(O(1))\n\n\n### 2. Two Pointers Problem 2 [Easy]\n\nTwo pointers problem variant 2.\n\n**Complexity:** Time O(O(n)), Space O(O(1))\n\n\n### 3. Two Pointers Problem 5 [Easy]\n\nTwo pointers problem variant 5.\n\n**Complexity:** Time O(O(n)), Space O(O(1))\n\n\n### 4. Two Pointers Problem 6 [Easy]\n\nTwo pointers problem variant 6.\n\n**Complexity:** Time O(O(n)), Space O(O(1))\n\n\n### 5. Two Pointers Problem 10 [Easy]\n\nTwo pointers problem variant 10.\n\n**Complexity:** Time O(O(n)), Space O(O(1))\n\n\n\n---\n\n## Key Takeaways\n\n- Two Pointers is essential for using two pointers moving toward each other or in same direction to solve array problems efficiently\n- Time complexity improvements can be significant with this technique\n- Practice problems in order of difficulty to build intuition\n- Focus on recognizing patterns in problem statements\n",
    "reading_time_minutes": 15,
    "key_concepts": [
      "Two Pointers",
      "Opposite Direction"
    ],
    "problem_count": 20
  },
  {
    "family_id": "array-matrix-005",
    "title": "Matrix",
    "content": "# Matrix\n\nMaster Matrix - a key concept in Arrays & Strings.\n\n---\n\n## Overview\n\n**Topic:** Arrays & Strings\n**Subtopic:** Matrix Operations\n**Problems Available:** 20\n**Difficulty Range:** medium, hard, easy\n\n---\n\n## What You'll Learn\n\nMatrix is fundamental to solving arrays & strings problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n^2)**\n\n### Space Complexity\nTypical space requirement: **O(1)**\n\n### Common Tags\n`matrix`, `array`, `simulation`\n\n---\n\n## Starter Template\n\n```python\ndef rotate(matrix: List[List[int]]) -> None:\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Matrix Problem 4 [Easy]\n\nMatrix problem variant 4.\n\n**Time:** O(O(mn)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 2. Matrix Problem 8 [Easy]\n\nMatrix problem variant 8.\n\n**Time:** O(O(mn)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 3. Matrix Problem 11 [Easy]\n\nMatrix problem variant 11.\n\n**Time:** O(O(mn)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 4. Matrix Problem 15 [Easy]\n\nMatrix problem variant 15.\n\n**Time:** O(O(mn)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 5. Matrix Problem 2 [Hard]\n\nMatrix problem variant 2.\n\n**Time:** O(O(mn)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 39%\n- **Average Time:** 32 minutes per problem\n- **Total Points:** 430 points available\n\n---\n\n## Next Steps\n\nAfter mastering Matrix:\n\n1. Complete all 20 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Matrix",
      "Matrix Operations",
      "Arrays & Strings"
    ],
    "problem_count": 20
  },
  {
    "family_id": "array-sorting-006",
    "title": "Sorting",
    "content": "# Sorting\n\nMaster Sorting - a key concept in Arrays & Strings.\n\n---\n\n## Overview\n\n**Topic:** Arrays & Strings\n**Subtopic:** Array Sorting\n**Problems Available:** 25\n**Difficulty Range:** medium, hard, easy\n\n---\n\n## What You'll Learn\n\nSorting is fundamental to solving arrays & strings problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n log n)**\n\n### Space Complexity\nTypical space requirement: **O(1)**\n\n### Common Tags\n`sorting`, `array`\n\n---\n\n## Starter Template\n\n```python\ndef solve(nums):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Sorting Problem 3 [Easy]\n\nArray sorting problem 3.\n\n**Time:** O(O(n log n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 2. Sorting Problem 5 [Easy]\n\nArray sorting problem 5.\n\n**Time:** O(O(n log n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 3. Sorting Problem 8 [Easy]\n\nArray sorting problem 8.\n\n**Time:** O(O(n log n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 4. Sorting Problem 11 [Easy]\n\nArray sorting problem 11.\n\n**Time:** O(O(n log n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 5. Sorting Problem 16 [Easy]\n\nArray sorting problem 16.\n\n**Time:** O(O(n log n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 44%\n- **Average Time:** 29 minutes per problem\n- **Total Points:** 490 points available\n\n---\n\n## Next Steps\n\nAfter mastering Sorting:\n\n1. Complete all 25 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Sorting",
      "Array Sorting",
      "Arrays & Strings"
    ],
    "problem_count": 25
  },
  {
    "family_id": "string-manipulation-007",
    "title": "Manipulation",
    "content": "# Manipulation\n\nMaster Manipulation - a key concept in Arrays & Strings.\n\n---\n\n## Overview\n\n**Topic:** Arrays & Strings\n**Subtopic:** String Manipulation\n**Problems Available:** 17\n**Difficulty Range:** medium, hard, easy\n\n---\n\n## What You'll Learn\n\nManipulation is fundamental to solving arrays & strings problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`string`\n\n---\n\n## Starter Template\n\n```python\ndef solve(s):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. String Manipulation 1-3 [Easy]\n\nString manipulation problem.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. String Manipulation 1-5 [Easy]\n\nString manipulation problem.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. String Manipulation 1-7 [Easy]\n\nString manipulation problem.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. String Manipulation 1-9 [Easy]\n\nString manipulation problem.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. String Manipulation 1-11 [Easy]\n\nString manipulation problem.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 51%\n- **Average Time:** 25 minutes per problem\n- **Total Points:** 290 points available\n\n---\n\n## Next Steps\n\nAfter mastering Manipulation:\n\n1. Complete all 17 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Manipulation",
      "String Manipulation",
      "Arrays & Strings"
    ],
    "problem_count": 17
  },
  {
    "family_id": "string-manipulation-008",
    "title": "Manipulation",
    "content": "# Manipulation\n\nMaster Manipulation - a key concept in Arrays & Strings.\n\n---\n\n## Overview\n\n**Topic:** Arrays & Strings\n**Subtopic:** String Manipulation\n**Problems Available:** 17\n**Difficulty Range:** hard, medium, easy\n\n---\n\n## What You'll Learn\n\nManipulation is fundamental to solving arrays & strings problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`string`\n\n---\n\n## Starter Template\n\n```python\ndef solve(s):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. String Manipulation 2-9 [Easy]\n\nString manipulation problem.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. String Manipulation 2-16 [Easy]\n\nString manipulation problem.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. String Manipulation 2-17 [Easy]\n\nString manipulation problem.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. String Manipulation 2-1 [Hard]\n\nString manipulation problem.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. String Manipulation 2-2 [Hard]\n\nString manipulation problem.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 37%\n- **Average Time:** 33 minutes per problem\n- **Total Points:** 380 points available\n\n---\n\n## Next Steps\n\nAfter mastering Manipulation:\n\n1. Complete all 17 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Manipulation",
      "String Manipulation",
      "Arrays & Strings"
    ],
    "problem_count": 17
  },
  {
    "family_id": "string-manipulation-009",
    "title": "Manipulation",
    "content": "# Manipulation\n\nMaster Manipulation - a key concept in Arrays & Strings.\n\n---\n\n## Overview\n\n**Topic:** Arrays & Strings\n**Subtopic:** String Manipulation\n**Problems Available:** 17\n**Difficulty Range:** hard, medium, easy\n\n---\n\n## What You'll Learn\n\nManipulation is fundamental to solving arrays & strings problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`string`\n\n---\n\n## Starter Template\n\n```python\ndef solve(s):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. String Manipulation 3-3 [Easy]\n\nString manipulation problem.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. String Manipulation 3-8 [Easy]\n\nString manipulation problem.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. String Manipulation 3-9 [Easy]\n\nString manipulation problem.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. String Manipulation 3-11 [Easy]\n\nString manipulation problem.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. String Manipulation 3-12 [Easy]\n\nString manipulation problem.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 44%\n- **Average Time:** 30 minutes per problem\n- **Total Points:** 340 points available\n\n---\n\n## Next Steps\n\nAfter mastering Manipulation:\n\n1. Complete all 17 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Manipulation",
      "String Manipulation",
      "Arrays & Strings"
    ],
    "problem_count": 17
  },
  {
    "family_id": "palindrome-0010",
    "title": "",
    "content": "# \n\nMaster  - a key concept in Arrays & Strings.\n\n---\n\n## Overview\n\n**Topic:** Arrays & Strings\n**Subtopic:** Palindromes\n**Problems Available:** 15\n**Difficulty Range:** medium, easy, hard\n\n---\n\n## What You'll Learn\n\n is fundamental to solving arrays & strings problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(1)**\n\n### Common Tags\n`palindrome`, `two-pointers`\n\n---\n\n## Starter Template\n\n```python\ndef solve(s):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Palindrome Problem 1-3 [Easy]\n\nPalindrome problem.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 2. Palindrome Problem 1-4 [Easy]\n\nPalindrome problem.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 3. Palindrome Problem 1-7 [Easy]\n\nPalindrome problem.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 4. Palindrome Problem 1-8 [Easy]\n\nPalindrome problem.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 5. Palindrome Problem 1-9 [Easy]\n\nPalindrome problem.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 55%\n- **Average Time:** 23 minutes per problem\n- **Total Points:** 230 points available\n\n---\n\n## Next Steps\n\nAfter mastering :\n\n1. Complete all 15 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "",
      "Palindromes",
      "Arrays & Strings"
    ],
    "problem_count": 15
  },
  {
    "family_id": "palindrome-0011",
    "title": "",
    "content": "# \n\nMaster  - a key concept in Arrays & Strings.\n\n---\n\n## Overview\n\n**Topic:** Arrays & Strings\n**Subtopic:** Palindromes\n**Problems Available:** 15\n**Difficulty Range:** hard, medium, easy\n\n---\n\n## What You'll Learn\n\n is fundamental to solving arrays & strings problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(1)**\n\n### Common Tags\n`palindrome`, `two-pointers`\n\n---\n\n## Starter Template\n\n```python\ndef solve(s):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Palindrome Problem 2-4 [Easy]\n\nPalindrome problem.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 2. Palindrome Problem 2-9 [Easy]\n\nPalindrome problem.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 3. Palindrome Problem 2-13 [Easy]\n\nPalindrome problem.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 4. Palindrome Problem 2-15 [Easy]\n\nPalindrome problem.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 5. Palindrome Problem 2-1 [Hard]\n\nPalindrome problem.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 44%\n- **Average Time:** 29 minutes per problem\n- **Total Points:** 290 points available\n\n---\n\n## Next Steps\n\nAfter mastering :\n\n1. Complete all 15 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "",
      "Palindromes",
      "Arrays & Strings"
    ],
    "problem_count": 15
  },
  {
    "family_id": "linked-list-basics-011",
    "title": "Linked List Basics",
    "content": "# Linked List Basics\n\nFundamental operations on singly linked lists\n\n---\n\n## Linked Lists\n\nA linked list is a linear data structure where elements are stored in nodes. Each node contains data and a pointer to the next node.\n\n**Types:**\n- Singly Linked List: One pointer (next)\n- Doubly Linked List: Two pointers (next, prev)\n- Circular Linked List: Last node points to first\n\n**Advantages:**\n- Dynamic size\n- Efficient insertions/deletions at beginning: O(1)\n- No memory waste\n\n**Disadvantages:**\n- No random access: O(n) to access element\n- Extra memory for pointers\n- Not cache-friendly\n\n**Complexity:**\n- Access: O(n)\n- Search: O(n)\n- Insert at head: O(1)\n- Insert at position: O(n)\n- Delete: O(n)\n\n\n---\n\n## Common Patterns\n\n### Pattern 1: Node Definition\n```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n```\n\n### Pattern 2: Traversal\n```python\ndef traverse(head):\n    current = head\n    while current:\n        process(current.val)\n        current = current.next\n```\n\n### Pattern 3: Insert at Beginning\n```python\ndef insert_at_head(head, val):\n    new_node = ListNode(val)\n    new_node.next = head\n    return new_node  # New head\n```\n\n### Pattern 4: Delete Node\n```python\ndef delete_node(head, val):\n    # Handle deletion at head\n    if head and head.val == val:\n        return head.next\n\n    current = head\n    while current and current.next:\n        if current.next.val == val:\n            current.next = current.next.next\n            break\n        current = current.next\n\n    return head\n```\n\n### Pattern 5: Reverse Linked List\n```python\ndef reverse_list(head):\n    prev = None\n    current = head\n\n    while current:\n        next_temp = current.next  # Save next\n        current.next = prev        # Reverse pointer\n        prev = current             # Move prev forward\n        current = next_temp        # Move current forward\n\n    return prev  # New head\n```\n\n### Pattern 6: Find Middle (Fast & Slow Pointers)\n```python\ndef find_middle(head):\n    slow = fast = head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n    return slow  # Middle node\n```\n\n\n---\n\n## When to Use This Technique\n\nUse linked lists when: frequent insertions/deletions at beginning, size varies frequently, no random access needed, or implementing stacks/queues.\n\n---\n\n## Common Pitfalls to Avoid\n\n- Losing reference to head\n- Not handling null/empty list\n- Not updating pointers correctly during insertion/deletion\n- Memory leaks from not cleaning up nodes\n- Infinite loops from incorrect pointer updates\n- Not considering edge cases (single node, two nodes)\n\n---\n\n## Practice Problems\n\nStart with these problems to master this concept:\n\n### 1. Reverse Linked List [Easy]\n\nReverse a singly linked list.\n\n**Complexity:** Time O(O(n)), Space O(O(1))\n\n\n### 2. Merge Two Sorted Lists [Easy]\n\nMerge two sorted linked lists.\n\n**Complexity:** Time O(O(n+m)), Space O(O(1))\n\n\n### 3. Linked List Problem 3 [Easy]\n\nLinked list problem 3.\n\n**Complexity:** Time O(O(n)), Space O(O(1))\n\n\n### 4. Linked List Problem 5 [Easy]\n\nLinked list problem 5.\n\n**Complexity:** Time O(O(n)), Space O(O(1))\n\n\n### 5. Linked List Problem 15 [Easy]\n\nLinked list problem 15.\n\n**Complexity:** Time O(O(n)), Space O(O(1))\n\n\n\n---\n\n## Key Takeaways\n\n- Linked List Basics is essential for fundamental operations on singly linked lists\n- Time complexity improvements can be significant with this technique\n- Practice problems in order of difficulty to build intuition\n- Focus on recognizing patterns in problem statements\n",
    "reading_time_minutes": 15,
    "key_concepts": [
      "Linked List Basics",
      "Node Definition"
    ],
    "problem_count": 20
  },
  {
    "family_id": "linked-list-cycle-detection-012",
    "title": "List Cycle Detection",
    "content": "# List Cycle Detection\n\nMaster List Cycle Detection - a key concept in Linked Lists.\n\n---\n\n## Overview\n\n**Topic:** Linked Lists\n**Subtopic:** Cycle Detection\n**Problems Available:** 57\n**Difficulty Range:** medium, easy, hard\n\n---\n\n## What You'll Learn\n\nList Cycle Detection is fundamental to solving linked lists problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(1)**\n\n### Common Tags\n`linked-list`, `cycle-detection`\n\n---\n\n## Starter Template\n\n```python\ndef solve(head):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Cycle Detection 2 [Easy]\n\nProblem related to cycle-detection.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 2. Cycle Detection 4 [Easy]\n\nProblem related to cycle-detection.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 3. Cycle Detection 5 [Easy]\n\nProblem related to cycle-detection.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 4. Cycle Detection 7 [Easy]\n\nProblem related to cycle-detection.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 5. Cycle Detection 8 [Easy]\n\nProblem related to cycle-detection.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 47%\n- **Average Time:** 27 minutes per problem\n- **Total Points:** 1040 points available\n\n---\n\n## Next Steps\n\nAfter mastering List Cycle Detection:\n\n1. Complete all 57 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "List Cycle Detection",
      "Cycle Detection",
      "Linked Lists"
    ],
    "problem_count": 57
  },
  {
    "family_id": "linked-list-fast-slow-pointers-013",
    "title": "List Fast Slow Pointers",
    "content": "# List Fast Slow Pointers\n\nMaster List Fast Slow Pointers - a key concept in Linked Lists.\n\n---\n\n## Overview\n\n**Topic:** Linked Lists\n**Subtopic:** Fast Slow Pointers\n**Problems Available:** 57\n**Difficulty Range:** medium, easy, hard\n\n---\n\n## What You'll Learn\n\nList Fast Slow Pointers is fundamental to solving linked lists problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(1)**\n\n### Common Tags\n`linked-list`, `fast-slow-pointers`\n\n---\n\n## Starter Template\n\n```python\ndef solve(head):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Fast Slow Pointers 3 [Easy]\n\nProblem related to fast-slow-pointers.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 2. Fast Slow Pointers 6 [Easy]\n\nProblem related to fast-slow-pointers.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 3. Fast Slow Pointers 10 [Easy]\n\nProblem related to fast-slow-pointers.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 4. Fast Slow Pointers 11 [Easy]\n\nProblem related to fast-slow-pointers.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 5. Fast Slow Pointers 21 [Easy]\n\nProblem related to fast-slow-pointers.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 44%\n- **Average Time:** 29 minutes per problem\n- **Total Points:** 1110 points available\n\n---\n\n## Next Steps\n\nAfter mastering List Fast Slow Pointers:\n\n1. Complete all 57 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "List Fast Slow Pointers",
      "Fast Slow Pointers",
      "Linked Lists"
    ],
    "problem_count": 57
  },
  {
    "family_id": "linked-list-doubly-linked-list-014",
    "title": "List Doubly Linked List",
    "content": "# List Doubly Linked List\n\nMaster List Doubly Linked List - a key concept in Linked Lists.\n\n---\n\n## Overview\n\n**Topic:** Linked Lists\n**Subtopic:** Doubly Linked List\n**Problems Available:** 57\n**Difficulty Range:** easy, medium, hard\n\n---\n\n## What You'll Learn\n\nList Doubly Linked List is fundamental to solving linked lists problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(1)**\n\n### Common Tags\n`linked-list`, `doubly-linked-list`\n\n---\n\n## Starter Template\n\n```python\ndef solve(head):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Doubly Linked List 1 [Easy]\n\nProblem related to doubly-linked-list.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 2. Doubly Linked List 7 [Easy]\n\nProblem related to doubly-linked-list.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 3. Doubly Linked List 8 [Easy]\n\nProblem related to doubly-linked-list.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 4. Doubly Linked List 12 [Easy]\n\nProblem related to doubly-linked-list.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 5. Doubly Linked List 19 [Easy]\n\nProblem related to doubly-linked-list.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 41%\n- **Average Time:** 31 minutes per problem\n- **Total Points:** 1200 points available\n\n---\n\n## Next Steps\n\nAfter mastering List Doubly Linked List:\n\n1. Complete all 57 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "List Doubly Linked List",
      "Doubly Linked List",
      "Linked Lists"
    ],
    "problem_count": 57
  },
  {
    "family_id": "linked-list-circular-list-015",
    "title": "List Circular List",
    "content": "# List Circular List\n\nMaster List Circular List - a key concept in Linked Lists.\n\n---\n\n## Overview\n\n**Topic:** Linked Lists\n**Subtopic:** Circular List\n**Problems Available:** 57\n**Difficulty Range:** easy, hard, medium\n\n---\n\n## What You'll Learn\n\nList Circular List is fundamental to solving linked lists problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(1)**\n\n### Common Tags\n`linked-list`, `circular-list`\n\n---\n\n## Starter Template\n\n```python\ndef solve(head):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Circular List 1 [Easy]\n\nProblem related to circular-list.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 2. Circular List 2 [Easy]\n\nProblem related to circular-list.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 3. Circular List 5 [Easy]\n\nProblem related to circular-list.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 4. Circular List 6 [Easy]\n\nProblem related to circular-list.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 5. Circular List 8 [Easy]\n\nProblem related to circular-list.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 46%\n- **Average Time:** 28 minutes per problem\n- **Total Points:** 1080 points available\n\n---\n\n## Next Steps\n\nAfter mastering List Circular List:\n\n1. Complete all 57 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "List Circular List",
      "Circular List",
      "Linked Lists"
    ],
    "problem_count": 57
  },
  {
    "family_id": "stack-basic-stack-016",
    "title": "Stack Basics",
    "content": "# Stack Basics\n\nLIFO data structure with push, pop, and peek operations\n\n---\n\n## Stack Data Structure\n\nA stack is a LIFO (Last-In-First-Out) data structure where elements are added and removed from the same end (top).\n\n**Core Operations:**\n- **Push:** Add element to top - O(1)\n- **Pop:** Remove element from top - O(1)\n- **Peek/Top:** View top element - O(1)\n- **isEmpty:** Check if empty - O(1)\n\n**Implementations:**\n- Array-based: Fixed or dynamic size\n- Linked list-based: Dynamic size\n\n**Applications:**\n- Function call stack\n- Undo/redo operations\n- Expression evaluation\n- Backtracking\n- Browser history\n\n\n---\n\n## Common Patterns\n\n### Pattern 1: Array-based Stack\n```python\nclass Stack:\n    def __init__(self):\n        self.items = []\n\n    def push(self, item):\n        self.items.append(item)\n\n    def pop(self):\n        if not self.is_empty():\n            return self.items.pop()\n        return None\n\n    def peek(self):\n        if not self.is_empty():\n            return self.items[-1]\n        return None\n\n    def is_empty(self):\n        return len(self.items) == 0\n\n    def size(self):\n        return len(self.items)\n```\n\n### Pattern 2: Valid Parentheses\n```python\ndef is_valid_parentheses(s):\n    stack = []\n    pairs = {'(': ')', '[': ']', '{': '}'}\n\n    for char in s:\n        if char in pairs:  # Opening bracket\n            stack.append(char)\n        else:  # Closing bracket\n            if not stack or pairs[stack.pop()] != char:\n                return False\n\n    return len(stack) == 0\n```\n\n### Pattern 3: Min Stack (O(1) min operation)\n```python\nclass MinStack:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n\n    def push(self, val):\n        self.stack.append(val)\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n\n    def pop(self):\n        if self.stack:\n            val = self.stack.pop()\n            if val == self.min_stack[-1]:\n                self.min_stack.pop()\n            return val\n\n    def get_min(self):\n        return self.min_stack[-1] if self.min_stack else None\n```\n\n\n---\n\n## When to Use This Technique\n\nUse stacks for: nested structures, parsing/evaluation, undo operations, DFS traversal, backtracking, or any LIFO access pattern.\n\n---\n\n## Common Pitfalls to Avoid\n\n- Not checking if stack is empty before pop/peek\n- Stack overflow with limited memory\n- Using stack when queue is needed (FIFO vs LIFO)\n- Not handling edge cases (empty stack operations)\n\n---\n\n## Practice Problems\n\nStart with these problems to master this concept:\n\n### 1. Basic Stack 5 [Easy]\n\nStack problem: basic-stack.\n\n**Complexity:** Time O(O(n)), Space O(O(n))\n\n\n### 2. Basic Stack 6 [Easy]\n\nStack problem: basic-stack.\n\n**Complexity:** Time O(O(n)), Space O(O(n))\n\n\n### 3. Basic Stack 8 [Easy]\n\nStack problem: basic-stack.\n\n**Complexity:** Time O(O(n)), Space O(O(n))\n\n\n### 4. Basic Stack 31 [Easy]\n\nStack problem: basic-stack.\n\n**Complexity:** Time O(O(n)), Space O(O(n))\n\n\n### 5. Basic Stack 32 [Easy]\n\nStack problem: basic-stack.\n\n**Complexity:** Time O(O(n)), Space O(O(n))\n\n\n\n---\n\n## Key Takeaways\n\n- Stack Basics is essential for lifo data structure with push, pop, and peek operations\n- Time complexity improvements can be significant with this technique\n- Practice problems in order of difficulty to build intuition\n- Focus on recognizing patterns in problem statements\n",
    "reading_time_minutes": 15,
    "key_concepts": [
      "Stack Basics",
      "Array-based Stack"
    ],
    "problem_count": 36
  },
  {
    "family_id": "stack-monotonic-stack-017",
    "title": "Monotonic Stack",
    "content": "# Monotonic Stack\n\nMaster Monotonic Stack - a key concept in Stacks & Queues.\n\n---\n\n## Overview\n\n**Topic:** Stacks & Queues\n**Subtopic:** Monotonic Stack\n**Problems Available:** 37\n**Difficulty Range:** medium, hard, easy\n\n---\n\n## What You'll Learn\n\nMonotonic Stack is fundamental to solving stacks & queues problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`stack`, `monotonic-stack`\n\n---\n\n## Starter Template\n\n```python\ndef dailyTemperatures(temperatures: List[int]) -> List[int]:\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Monotonic Stack 22 [Easy]\n\nStack problem: monotonic-stack.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. Monotonic Stack 24 [Easy]\n\nStack problem: monotonic-stack.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. Monotonic Stack 29 [Easy]\n\nStack problem: monotonic-stack.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. Monotonic Stack 30 [Easy]\n\nStack problem: monotonic-stack.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. Monotonic Stack 33 [Easy]\n\nStack problem: monotonic-stack.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 34%\n- **Average Time:** 35 minutes per problem\n- **Total Points:** 870 points available\n\n---\n\n## Next Steps\n\nAfter mastering Monotonic Stack:\n\n1. Complete all 37 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Monotonic Stack",
      "Monotonic Stack",
      "Stacks & Queues"
    ],
    "problem_count": 37
  },
  {
    "family_id": "stack-expression-evaluation-018",
    "title": "Expression Evaluation",
    "content": "# Expression Evaluation\n\nMaster Expression Evaluation - a key concept in Stacks & Queues.\n\n---\n\n## Overview\n\n**Topic:** Stacks & Queues\n**Subtopic:** Expression Evaluation\n**Problems Available:** 36\n**Difficulty Range:** medium, hard, easy\n\n---\n\n## What You'll Learn\n\nExpression Evaluation is fundamental to solving stacks & queues problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`stack`\n\n---\n\n## Starter Template\n\n```python\ndef solve(data):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Expression Evaluation 10 [Easy]\n\nStack problem: expression-evaluation.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. Expression Evaluation 11 [Easy]\n\nStack problem: expression-evaluation.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. Expression Evaluation 12 [Easy]\n\nStack problem: expression-evaluation.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. Expression Evaluation 14 [Easy]\n\nStack problem: expression-evaluation.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. Expression Evaluation 23 [Easy]\n\nStack problem: expression-evaluation.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 43%\n- **Average Time:** 30 minutes per problem\n- **Total Points:** 720 points available\n\n---\n\n## Next Steps\n\nAfter mastering Expression Evaluation:\n\n1. Complete all 36 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Expression Evaluation",
      "Expression Evaluation",
      "Stacks & Queues"
    ],
    "problem_count": 36
  },
  {
    "family_id": "stack-next-greater-019",
    "title": "Next Greater",
    "content": "# Next Greater\n\nMaster Next Greater - a key concept in Stacks & Queues.\n\n---\n\n## Overview\n\n**Topic:** Stacks & Queues\n**Subtopic:** Next Greater\n**Problems Available:** 36\n**Difficulty Range:** hard, medium, easy\n\n---\n\n## What You'll Learn\n\nNext Greater is fundamental to solving stacks & queues problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`stack`\n\n---\n\n## Starter Template\n\n```python\ndef solve(data):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Next Greater 3 [Easy]\n\nStack problem: next-greater.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. Next Greater 5 [Easy]\n\nStack problem: next-greater.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. Next Greater 9 [Easy]\n\nStack problem: next-greater.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. Next Greater 10 [Easy]\n\nStack problem: next-greater.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. Next Greater 12 [Easy]\n\nStack problem: next-greater.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 39%\n- **Average Time:** 32 minutes per problem\n- **Total Points:** 790 points available\n\n---\n\n## Next Steps\n\nAfter mastering Next Greater:\n\n1. Complete all 36 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Next Greater",
      "Next Greater",
      "Stacks & Queues"
    ],
    "problem_count": 36
  },
  {
    "family_id": "queue-basic-queue-020",
    "title": "Basic Queue",
    "content": "# Basic Queue\n\nMaster Basic Queue - a key concept in Stacks & Queues.\n\n---\n\n## Overview\n\n**Topic:** Stacks & Queues\n**Subtopic:** Basic Queue\n**Problems Available:** 37\n**Difficulty Range:** hard, medium, easy\n\n---\n\n## What You'll Learn\n\nBasic Queue is fundamental to solving stacks & queues problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`queue`\n\n---\n\n## Starter Template\n\n```python\ndef solve(data):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Basic Queue 11 [Easy]\n\nQueue problem: basic-queue.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. Basic Queue 13 [Easy]\n\nQueue problem: basic-queue.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. Basic Queue 19 [Easy]\n\nQueue problem: basic-queue.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. Basic Queue 24 [Easy]\n\nQueue problem: basic-queue.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. Basic Queue 25 [Easy]\n\nQueue problem: basic-queue.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 40%\n- **Average Time:** 32 minutes per problem\n- **Total Points:** 800 points available\n\n---\n\n## Next Steps\n\nAfter mastering Basic Queue:\n\n1. Complete all 37 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Basic Queue",
      "Basic Queue",
      "Stacks & Queues"
    ],
    "problem_count": 37
  },
  {
    "family_id": "queue-priority-queue-021",
    "title": "Priority Queue",
    "content": "# Priority Queue\n\nMaster Priority Queue - a key concept in Stacks & Queues.\n\n---\n\n## Overview\n\n**Topic:** Stacks & Queues\n**Subtopic:** Priority Queue\n**Problems Available:** 37\n**Difficulty Range:** easy, hard, medium\n\n---\n\n## What You'll Learn\n\nPriority Queue is fundamental to solving stacks & queues problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`queue`\n\n---\n\n## Starter Template\n\n```python\ndef solve(data):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Priority Queue 1 [Easy]\n\nQueue problem: priority-queue.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. Priority Queue 5 [Easy]\n\nQueue problem: priority-queue.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. Priority Queue 9 [Easy]\n\nQueue problem: priority-queue.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. Priority Queue 16 [Easy]\n\nQueue problem: priority-queue.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. Priority Queue 24 [Easy]\n\nQueue problem: priority-queue.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 42%\n- **Average Time:** 30 minutes per problem\n- **Total Points:** 750 points available\n\n---\n\n## Next Steps\n\nAfter mastering Priority Queue:\n\n1. Complete all 37 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Priority Queue",
      "Priority Queue",
      "Stacks & Queues"
    ],
    "problem_count": 37
  },
  {
    "family_id": "queue-deque-022",
    "title": "Deque",
    "content": "# Deque\n\nMaster Deque - a key concept in Stacks & Queues.\n\n---\n\n## Overview\n\n**Topic:** Stacks & Queues\n**Subtopic:** Deque\n**Problems Available:** 37\n**Difficulty Range:** easy, hard, medium\n\n---\n\n## What You'll Learn\n\nDeque is fundamental to solving stacks & queues problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`queue`\n\n---\n\n## Starter Template\n\n```python\ndef solve(data):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Deque 1 [Easy]\n\nQueue problem: deque.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. Deque 3 [Easy]\n\nQueue problem: deque.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. Deque 6 [Easy]\n\nQueue problem: deque.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. Deque 8 [Easy]\n\nQueue problem: deque.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. Deque 10 [Easy]\n\nQueue problem: deque.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 44%\n- **Average Time:** 30 minutes per problem\n- **Total Points:** 740 points available\n\n---\n\n## Next Steps\n\nAfter mastering Deque:\n\n1. Complete all 37 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Deque",
      "Deque",
      "Stacks & Queues"
    ],
    "problem_count": 37
  },
  {
    "family_id": "queue-circular-queue-023",
    "title": "Circular Queue",
    "content": "# Circular Queue\n\nMaster Circular Queue - a key concept in Stacks & Queues.\n\n---\n\n## Overview\n\n**Topic:** Stacks & Queues\n**Subtopic:** Circular Queue\n**Problems Available:** 37\n**Difficulty Range:** easy, hard, medium\n\n---\n\n## What You'll Learn\n\nCircular Queue is fundamental to solving stacks & queues problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`queue`\n\n---\n\n## Starter Template\n\n```python\ndef solve(data):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Circular Queue 1 [Easy]\n\nQueue problem: circular-queue.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. Circular Queue 10 [Easy]\n\nQueue problem: circular-queue.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. Circular Queue 11 [Easy]\n\nQueue problem: circular-queue.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. Circular Queue 15 [Easy]\n\nQueue problem: circular-queue.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. Circular Queue 21 [Easy]\n\nQueue problem: circular-queue.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 39%\n- **Average Time:** 32 minutes per problem\n- **Total Points:** 790 points available\n\n---\n\n## Next Steps\n\nAfter mastering Circular Queue:\n\n1. Complete all 37 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Circular Queue",
      "Circular Queue",
      "Stacks & Queues"
    ],
    "problem_count": 37
  },
  {
    "family_id": "tree-binary-tree-traversal-024",
    "title": "Binary Tree Traversal",
    "content": "# Binary Tree Traversal\n\nSystematic ways to visit all nodes in a binary tree\n\n---\n\n## Binary Tree Traversal Methods\n\nTraversal is the process of visiting all nodes in a tree in a specific order.\n\n**Four Main Traversals:**\n\n### 1. Inorder (Left-Root-Right)\n- Visits left subtree, then root, then right subtree\n- For BST: visits nodes in sorted order\n- Use: Expression tree evaluation, sorted output\n\n### 2. Preorder (Root-Left-Right)\n- Visits root first, then left, then right\n- Use: Copying tree, prefix notation\n\n### 3. Postorder (Left-Right-Root)\n- Visits children before root\n- Use: Deleting tree, postfix notation, calculating tree size\n\n### 4. Level Order (BFS)\n- Visits nodes level by level\n- Use: Finding level, shortest path, serialization\n\n**Complexity:** O(n) time, O(h) space for recursive (h = height)\n\n\n---\n\n## Common Patterns\n\n### Pattern 1: Recursive Inorder\n```python\ndef inorder(root, result=[]):\n    if root:\n        inorder(root.left, result)\n        result.append(root.val)\n        inorder(root.right, result)\n    return result\n```\n\n### Pattern 2: Iterative Inorder (Stack)\n```python\ndef inorder_iterative(root):\n    result, stack = [], []\n    curr = root\n\n    while curr or stack:\n        # Go to leftmost node\n        while curr:\n            stack.append(curr)\n            curr = curr.left\n\n        # Process node\n        curr = stack.pop()\n        result.append(curr.val)\n\n        # Move to right subtree\n        curr = curr.right\n\n    return result\n```\n\n### Pattern 3: Level Order (BFS with Queue)\n```python\nfrom collections import deque\n\ndef level_order(root):\n    if not root:\n        return []\n\n    result = []\n    queue = deque([root])\n\n    while queue:\n        level_size = len(queue)\n        current_level = []\n\n        for _ in range(level_size):\n            node = queue.popleft()\n            current_level.append(node.val)\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n        result.append(current_level)\n\n    return result\n```\n\n### Pattern 4: Morris Traversal (O(1) Space)\n```python\ndef morris_inorder(root):\n    result = []\n    curr = root\n\n    while curr:\n        if not curr.left:\n            result.append(curr.val)\n            curr = curr.right\n        else:\n            # Find inorder predecessor\n            pred = curr.left\n            while pred.right and pred.right != curr:\n                pred = pred.right\n\n            if not pred.right:\n                pred.right = curr  # Create thread\n                curr = curr.left\n            else:\n                pred.right = None  # Remove thread\n                result.append(curr.val)\n                curr = curr.right\n\n    return result\n```\n\n\n---\n\n## When to Use This Technique\n\nUse tree traversal for: visiting all nodes, searching, copying trees, converting to arrays, finding paths, or any operation requiring systematic node visiting.\n\n---\n\n## Common Pitfalls to Avoid\n\n- Stack overflow with deep recursive trees\n- Not handling null/empty trees\n- Confusing traversal orders\n- Forgetting to track level in level-order traversal\n- Modifying tree structure during traversal\n\n---\n\n## Practice Problems\n\nStart with these problems to master this concept:\n\n### 1. Binary Tree Inorder Traversal [Easy]\n\nReturn inorder traversal of binary tree.\n\n**Complexity:** Time O(O(n)), Space O(O(n))\n\n\n### 2. Binary Tree Traversal 6 [Easy]\n\nTree problem: binary-tree-traversal.\n\n**Complexity:** Time O(O(n)), Space O(O(h))\n\n\n### 3. Binary Tree Traversal 9 [Easy]\n\nTree problem: binary-tree-traversal.\n\n**Complexity:** Time O(O(n)), Space O(O(h))\n\n\n### 4. Binary Tree Traversal 13 [Easy]\n\nTree problem: binary-tree-traversal.\n\n**Complexity:** Time O(O(n)), Space O(O(h))\n\n\n### 5. Binary Tree Traversal 16 [Easy]\n\nTree problem: binary-tree-traversal.\n\n**Complexity:** Time O(O(n)), Space O(O(h))\n\n\n\n---\n\n## Key Takeaways\n\n- Binary Tree Traversal is essential for systematic ways to visit all nodes in a binary tree\n- Time complexity improvements can be significant with this technique\n- Practice problems in order of difficulty to build intuition\n- Focus on recognizing patterns in problem statements\n",
    "reading_time_minutes": 15,
    "key_concepts": [
      "Binary Tree Traversal",
      "Recursive Inorder"
    ],
    "problem_count": 80
  },
  {
    "family_id": "tree-bst-operations-025",
    "title": "Binary Search Tree Operations",
    "content": "# Binary Search Tree Operations\n\nEfficient operations on BST including search, insert, delete\n\n---\n\n## Binary Search Tree (BST)\n\nA BST is a binary tree where for each node:\n- All values in left subtree < node value\n- All values in right subtree > node value\n\n**Key Properties:**\n- Inorder traversal gives sorted sequence\n- Average case: O(log n) for search, insert, delete\n- Worst case: O(n) if tree becomes skewed\n\n**Operations:**\n- Search: Follow BST property to find value\n- Insert: Find correct position and add node\n- Delete: Three cases - leaf, one child, two children\n- Find Min/Max: Go leftmost/rightmost\n\n\n---\n\n## Common Patterns\n\n### Pattern 1: BST Search\n```python\ndef search_bst(root, target):\n    if not root or root.val == target:\n        return root\n\n    if target < root.val:\n        return search_bst(root.left, target)\n    return search_bst(root.right, target)\n```\n\n### Pattern 2: BST Insert\n```python\ndef insert_bst(root, val):\n    if not root:\n        return TreeNode(val)\n\n    if val < root.val:\n        root.left = insert_bst(root.left, val)\n    else:\n        root.right = insert_bst(root.right, val)\n\n    return root\n```\n\n### Pattern 3: BST Delete\n```python\ndef delete_bst(root, key):\n    if not root:\n        return None\n\n    if key < root.val:\n        root.left = delete_bst(root.left, key)\n    elif key > root.val:\n        root.right = delete_bst(root.right, key)\n    else:\n        # Node to delete found\n        # Case 1: Leaf or one child\n        if not root.left:\n            return root.right\n        if not root.right:\n            return root.left\n\n        # Case 2: Two children\n        # Find inorder successor (min in right subtree)\n        successor = find_min(root.right)\n        root.val = successor.val\n        root.right = delete_bst(root.right, successor.val)\n\n    return root\n\ndef find_min(node):\n    while node.left:\n        node = node.left\n    return node\n```\n\n### Pattern 4: Validate BST\n```python\ndef is_valid_bst(root, min_val=float('-inf'), max_val=float('inf')):\n    if not root:\n        return True\n\n    if not (min_val < root.val < max_val):\n        return False\n\n    return (is_valid_bst(root.left, min_val, root.val) and\n           is_valid_bst(root.right, root.val, max_val))\n```\n\n\n---\n\n## When to Use This Technique\n\nUse BST for: maintaining sorted data with fast operations, range queries, finding closest elements, or when you need logarithmic search in dynamic data.\n\n---\n\n## Common Pitfalls to Avoid\n\n- Not handling duplicate values consistently\n- Forgetting to check BST validity\n- Not handling edge cases in delete (leaf, one child, two children)\n- Creating unbalanced BST (use AVL/Red-Black for balance)\n- Not updating parent pointers if maintaining them\n\n---\n\n## Practice Problems\n\nStart with these problems to master this concept:\n\n### 1. Bst Operations 2 [Easy]\n\nTree problem: bst-operations.\n\n**Complexity:** Time O(O(n)), Space O(O(h))\n\n\n### 2. Bst Operations 4 [Easy]\n\nTree problem: bst-operations.\n\n**Complexity:** Time O(O(n)), Space O(O(h))\n\n\n### 3. Bst Operations 10 [Easy]\n\nTree problem: bst-operations.\n\n**Complexity:** Time O(O(n)), Space O(O(h))\n\n\n### 4. Bst Operations 13 [Easy]\n\nTree problem: bst-operations.\n\n**Complexity:** Time O(O(n)), Space O(O(h))\n\n\n### 5. Bst Operations 16 [Easy]\n\nTree problem: bst-operations.\n\n**Complexity:** Time O(O(n)), Space O(O(h))\n\n\n\n---\n\n## Key Takeaways\n\n- Binary Search Tree Operations is essential for efficient operations on bst including search, insert, delete\n- Time complexity improvements can be significant with this technique\n- Practice problems in order of difficulty to build intuition\n- Focus on recognizing patterns in problem statements\n",
    "reading_time_minutes": 15,
    "key_concepts": [
      "Binary Search Tree Operations",
      "BST Search"
    ],
    "problem_count": 48
  },
  {
    "family_id": "tree-tree-construction-026",
    "title": "Tree Construction",
    "content": "# Tree Construction\n\nMaster Tree Construction - a key concept in Trees.\n\n---\n\n## Overview\n\n**Topic:** Trees\n**Subtopic:** Tree Construction\n**Problems Available:** 48\n**Difficulty Range:** easy, hard, medium\n\n---\n\n## What You'll Learn\n\nTree Construction is fundamental to solving trees problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(h)**\n\n### Common Tags\n`tree`\n\n---\n\n## Starter Template\n\n```python\ndef solve(root):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Tree Construction 1 [Easy]\n\nTree problem: tree-construction.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n### 2. Tree Construction 3 [Easy]\n\nTree problem: tree-construction.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n### 3. Tree Construction 5 [Easy]\n\nTree problem: tree-construction.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n### 4. Tree Construction 9 [Easy]\n\nTree problem: tree-construction.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n### 5. Tree Construction 11 [Easy]\n\nTree problem: tree-construction.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 38%\n- **Average Time:** 33 minutes per problem\n- **Total Points:** 1070 points available\n\n---\n\n## Next Steps\n\nAfter mastering Tree Construction:\n\n1. Complete all 48 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Tree Construction",
      "Tree Construction",
      "Trees"
    ],
    "problem_count": 48
  },
  {
    "family_id": "tree-tree-properties-027",
    "title": "Tree Properties",
    "content": "# Tree Properties\n\nMaster Tree Properties - a key concept in Trees.\n\n---\n\n## Overview\n\n**Topic:** Trees\n**Subtopic:** Tree Properties\n**Problems Available:** 48\n**Difficulty Range:** hard, medium, easy\n\n---\n\n## What You'll Learn\n\nTree Properties is fundamental to solving trees problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(h)**\n\n### Common Tags\n`tree`\n\n---\n\n## Starter Template\n\n```python\ndef solve(root):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Tree Properties 8 [Easy]\n\nTree problem: tree-properties.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n### 2. Tree Properties 9 [Easy]\n\nTree problem: tree-properties.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n### 3. Tree Properties 10 [Easy]\n\nTree problem: tree-properties.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n### 4. Tree Properties 11 [Easy]\n\nTree problem: tree-properties.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n### 5. Tree Properties 12 [Easy]\n\nTree problem: tree-properties.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 45%\n- **Average Time:** 28 minutes per problem\n- **Total Points:** 920 points available\n\n---\n\n## Next Steps\n\nAfter mastering Tree Properties:\n\n1. Complete all 48 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Tree Properties",
      "Tree Properties",
      "Trees"
    ],
    "problem_count": 48
  },
  {
    "family_id": "tree-lca-028",
    "title": "Lca",
    "content": "# Lca\n\nMaster Lca - a key concept in Trees.\n\n---\n\n## Overview\n\n**Topic:** Trees\n**Subtopic:** Lca\n**Problems Available:** 48\n**Difficulty Range:** easy, medium, hard\n\n---\n\n## What You'll Learn\n\nLca is fundamental to solving trees problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(h)**\n\n### Common Tags\n`tree`\n\n---\n\n## Starter Template\n\n```python\ndef solve(root):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Lca 1 [Easy]\n\nTree problem: lca.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n### 2. Lca 4 [Easy]\n\nTree problem: lca.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n### 3. Lca 9 [Easy]\n\nTree problem: lca.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n### 4. Lca 12 [Easy]\n\nTree problem: lca.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n### 5. Lca 15 [Easy]\n\nTree problem: lca.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 40%\n- **Average Time:** 31 minutes per problem\n- **Total Points:** 1010 points available\n\n---\n\n## Next Steps\n\nAfter mastering Lca:\n\n1. Complete all 48 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Lca",
      "Lca",
      "Trees"
    ],
    "problem_count": 48
  },
  {
    "family_id": "tree-tree-paths-029",
    "title": "Tree Paths",
    "content": "# Tree Paths\n\nMaster Tree Paths - a key concept in Trees.\n\n---\n\n## Overview\n\n**Topic:** Trees\n**Subtopic:** Tree Paths\n**Problems Available:** 48\n**Difficulty Range:** hard, medium, easy\n\n---\n\n## What You'll Learn\n\nTree Paths is fundamental to solving trees problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(h)**\n\n### Common Tags\n`tree`\n\n---\n\n## Starter Template\n\n```python\ndef solve(root):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Tree Paths 5 [Easy]\n\nTree problem: tree-paths.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n### 2. Tree Paths 6 [Easy]\n\nTree problem: tree-paths.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n### 3. Tree Paths 15 [Easy]\n\nTree problem: tree-paths.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n### 4. Tree Paths 18 [Easy]\n\nTree problem: tree-paths.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n### 5. Tree Paths 19 [Easy]\n\nTree problem: tree-paths.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 39%\n- **Average Time:** 32 minutes per problem\n- **Total Points:** 1040 points available\n\n---\n\n## Next Steps\n\nAfter mastering Tree Paths:\n\n1. Complete all 48 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Tree Paths",
      "Tree Paths",
      "Trees"
    ],
    "problem_count": 48
  },
  {
    "family_id": "tree-n-ary-trees-030",
    "title": "N Ary Trees",
    "content": "# N Ary Trees\n\nMaster N Ary Trees - a key concept in Trees.\n\n---\n\n## Overview\n\n**Topic:** Trees\n**Subtopic:** N Ary Trees\n**Problems Available:** 48\n**Difficulty Range:** easy, medium, hard\n\n---\n\n## What You'll Learn\n\nN Ary Trees is fundamental to solving trees problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(h)**\n\n### Common Tags\n`tree`\n\n---\n\n## Starter Template\n\n```python\ndef solve(root):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. N Ary Trees 1 [Easy]\n\nTree problem: n-ary-trees.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n### 2. N Ary Trees 2 [Easy]\n\nTree problem: n-ary-trees.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n### 3. N Ary Trees 8 [Easy]\n\nTree problem: n-ary-trees.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n### 4. N Ary Trees 12 [Easy]\n\nTree problem: n-ary-trees.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n### 5. N Ary Trees 13 [Easy]\n\nTree problem: n-ary-trees.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 41%\n- **Average Time:** 31 minutes per problem\n- **Total Points:** 1000 points available\n\n---\n\n## Next Steps\n\nAfter mastering N Ary Trees:\n\n1. Complete all 48 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "N Ary Trees",
      "N Ary Trees",
      "Trees"
    ],
    "problem_count": 48
  },
  {
    "family_id": "tree-trie-031",
    "title": "Trie (Prefix Tree)",
    "content": "# Trie (Prefix Tree)\n\nTree-based data structure for efficient string operations and prefix searches\n\n---\n\n## Trie Data Structure\n\nA Trie (prefix tree) is a tree where each node represents a character, and paths represent strings.\n\n**Properties:**\n- Root represents empty string\n- Each path from root represents a prefix\n- Nodes can mark end of word\n\n**Operations:**\n- Insert: O(m) where m = string length\n- Search: O(m)\n- Prefix Search: O(p) where p = prefix length\n- Space: O(ALPHABET_SIZE * N * M) worst case\n\n**Use Cases:**\n- Autocomplete\n- Spell checker\n- IP routing\n- Dictionary implementation\n\n\n---\n\n## Common Patterns\n\n### Pattern 1: Basic Trie Implementation\n```python\nclass TrieNode:\n    def __init__(self):\n        self.children = {}  # char -> TrieNode\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def starts_with(self, prefix):\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True\n```\n\n### Pattern 2: Word Search with Trie\n```python\ndef find_words(board, words):\n    # Build trie from words\n    trie = Trie()\n    for word in words:\n        trie.insert(word)\n\n    result = set()\n\n    def dfs(i, j, node, path):\n        if node.is_end_of_word:\n            result.add(path)\n\n        if (i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or\n            board[i][j] == '#'):\n            return\n\n        char = board[i][j]\n        if char not in node.children:\n            return\n\n        board[i][j] = '#'  # Mark visited\n\n        for di, dj in [(0,1), (1,0), (0,-1), (-1,0)]:\n            dfs(i+di, j+dj, node.children[char], path+char)\n\n        board[i][j] = char  # Restore\n\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            dfs(i, j, trie.root, \"\")\n\n    return list(result)\n```\n\n### Pattern 3: Autocomplete with Trie\n```python\nclass TrieWithSuggestions(Trie):\n    def get_suggestions(self, prefix):\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return []\n            node = node.children[char]\n\n        # DFS to collect all words with this prefix\n        suggestions = []\n        self._collect_words(node, prefix, suggestions)\n        return suggestions\n\n    def _collect_words(self, node, current, suggestions):\n        if node.is_end_of_word:\n            suggestions.append(current)\n\n        for char, child_node in node.children.items():\n            self._collect_words(child_node, current + char, suggestions)\n```\n\n\n---\n\n## When to Use This Technique\n\nUse Trie for: prefix matching, autocomplete, spell checking, storing dictionary, IP routing, or when you need fast prefix-based operations.\n\n---\n\n## Common Pitfalls to Avoid\n\n- High memory usage with large alphabets\n- Not handling case sensitivity correctly\n- Forgetting to mark end of words\n- Not cleaning up unused nodes (memory leaks)\n- Confusing search() with startsWith()\n\n---\n\n## Practice Problems\n\nStart with these problems to master this concept:\n\n### 1. Trie 4 [Easy]\n\nTree problem: trie.\n\n**Complexity:** Time O(O(n)), Space O(O(h))\n\n\n### 2. Trie 6 [Easy]\n\nTree problem: trie.\n\n**Complexity:** Time O(O(n)), Space O(O(h))\n\n\n### 3. Trie 7 [Easy]\n\nTree problem: trie.\n\n**Complexity:** Time O(O(n)), Space O(O(h))\n\n\n### 4. Trie 8 [Easy]\n\nTree problem: trie.\n\n**Complexity:** Time O(O(n)), Space O(O(h))\n\n\n### 5. Trie 17 [Easy]\n\nTree problem: trie.\n\n**Complexity:** Time O(O(n)), Space O(O(h))\n\n\n\n---\n\n## Key Takeaways\n\n- Trie (Prefix Tree) is essential for tree-based data structure for efficient string operations and prefix searches\n- Time complexity improvements can be significant with this technique\n- Practice problems in order of difficulty to build intuition\n- Focus on recognizing patterns in problem statements\n",
    "reading_time_minutes": 15,
    "key_concepts": [
      "Trie (Prefix Tree)",
      "Basic Trie Implementation"
    ],
    "problem_count": 48
  },
  {
    "family_id": "tree-segment-tree-032",
    "title": "Segment Tree",
    "content": "# Segment Tree\n\nMaster Segment Tree - a key concept in Trees.\n\n---\n\n## Overview\n\n**Topic:** Trees\n**Subtopic:** Segment Tree\n**Problems Available:** 48\n**Difficulty Range:** easy, hard, medium\n\n---\n\n## What You'll Learn\n\nSegment Tree is fundamental to solving trees problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(h)**\n\n### Common Tags\n`tree`\n\n---\n\n## Starter Template\n\n```python\ndef solve(root):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Segment Tree 1 [Easy]\n\nTree problem: segment-tree.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n### 2. Segment Tree 3 [Easy]\n\nTree problem: segment-tree.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n### 3. Segment Tree 5 [Easy]\n\nTree problem: segment-tree.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n### 4. Segment Tree 8 [Easy]\n\nTree problem: segment-tree.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n### 5. Segment Tree 10 [Easy]\n\nTree problem: segment-tree.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 40%\n- **Average Time:** 31 minutes per problem\n- **Total Points:** 1020 points available\n\n---\n\n## Next Steps\n\nAfter mastering Segment Tree:\n\n1. Complete all 48 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Segment Tree",
      "Segment Tree",
      "Trees"
    ],
    "problem_count": 48
  },
  {
    "family_id": "tree-fenwick-tree-033",
    "title": "Fenwick Tree",
    "content": "# Fenwick Tree\n\nMaster Fenwick Tree - a key concept in Trees.\n\n---\n\n## Overview\n\n**Topic:** Trees\n**Subtopic:** Fenwick Tree\n**Problems Available:** 48\n**Difficulty Range:** easy, hard, medium\n\n---\n\n## What You'll Learn\n\nFenwick Tree is fundamental to solving trees problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(h)**\n\n### Common Tags\n`tree`\n\n---\n\n## Starter Template\n\n```python\ndef solve(root):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Fenwick Tree 1 [Easy]\n\nTree problem: fenwick-tree.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n### 2. Fenwick Tree 2 [Easy]\n\nTree problem: fenwick-tree.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n### 3. Fenwick Tree 3 [Easy]\n\nTree problem: fenwick-tree.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n### 4. Fenwick Tree 10 [Easy]\n\nTree problem: fenwick-tree.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n### 5. Fenwick Tree 16 [Easy]\n\nTree problem: fenwick-tree.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 44%\n- **Average Time:** 29 minutes per problem\n- **Total Points:** 940 points available\n\n---\n\n## Next Steps\n\nAfter mastering Fenwick Tree:\n\n1. Complete all 48 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Fenwick Tree",
      "Fenwick Tree",
      "Trees"
    ],
    "problem_count": 48
  },
  {
    "family_id": "tree-avl-tree-034",
    "title": "Avl Tree",
    "content": "# Avl Tree\n\nMaster Avl Tree - a key concept in Trees.\n\n---\n\n## Overview\n\n**Topic:** Trees\n**Subtopic:** Avl Tree\n**Problems Available:** 48\n**Difficulty Range:** medium, easy, hard\n\n---\n\n## What You'll Learn\n\nAvl Tree is fundamental to solving trees problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(h)**\n\n### Common Tags\n`tree`\n\n---\n\n## Starter Template\n\n```python\ndef solve(root):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Avl Tree 2 [Easy]\n\nTree problem: avl-tree.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n### 2. Avl Tree 3 [Easy]\n\nTree problem: avl-tree.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n### 3. Avl Tree 6 [Easy]\n\nTree problem: avl-tree.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n### 4. Avl Tree 12 [Easy]\n\nTree problem: avl-tree.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n### 5. Avl Tree 13 [Easy]\n\nTree problem: avl-tree.\n\n**Time:** O(O(n)), **Space:** O(O(h))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 46%\n- **Average Time:** 28 minutes per problem\n- **Total Points:** 900 points available\n\n---\n\n## Next Steps\n\nAfter mastering Avl Tree:\n\n1. Complete all 48 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Avl Tree",
      "Avl Tree",
      "Trees"
    ],
    "problem_count": 48
  },
  {
    "family_id": "graph-graph-representation-035",
    "title": "Graph Representation",
    "content": "# Graph Representation\n\nMaster Graph Representation - a key concept in Graphs.\n\n---\n\n## Overview\n\n**Topic:** Graphs\n**Subtopic:** Graph Representation\n**Problems Available:** 43\n**Difficulty Range:** easy, medium, hard\n\n---\n\n## What You'll Learn\n\nGraph Representation is fundamental to solving graphs problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(V+E)**\n\n### Space Complexity\nTypical space requirement: **O(V)**\n\n### Common Tags\n`graph`\n\n---\n\n## Starter Template\n\n```python\ndef solve(graph):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Graph Representation 1 [Easy]\n\nGraph problem: graph-representation.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n### 2. Graph Representation 2 [Easy]\n\nGraph problem: graph-representation.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n### 3. Graph Representation 4 [Easy]\n\nGraph problem: graph-representation.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n### 4. Graph Representation 8 [Easy]\n\nGraph problem: graph-representation.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n### 5. Graph Representation 10 [Easy]\n\nGraph problem: graph-representation.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 44%\n- **Average Time:** 29 minutes per problem\n- **Total Points:** 840 points available\n\n---\n\n## Next Steps\n\nAfter mastering Graph Representation:\n\n1. Complete all 43 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Graph Representation",
      "Graph Representation",
      "Graphs"
    ],
    "problem_count": 43
  },
  {
    "family_id": "graph-dfs-036",
    "title": "Depth First Search (DFS)",
    "content": "# Depth First Search (DFS)\n\nGraph traversal algorithm that explores as far as possible along each branch\n\n---\n\n## DFS Algorithm\n\nDFS explores a graph by going as deep as possible along each branch before backtracking.\n\n**Characteristics:**\n- Uses stack (implicit via recursion or explicit)\n- Explores deeply before broadly\n- Memory efficient for deep graphs\n\n**Applications:**\n- Path finding\n- Cycle detection\n- Topological sorting\n- Connected components\n- Maze solving\n\n**Complexity:**\n- Time: O(V + E)\n- Space: O(V) for recursion stack\n\n\n---\n\n## Common Patterns\n\n### Pattern 1: Recursive DFS\n```python\ndef dfs_recursive(graph, node, visited):\n    visited.add(node)\n    process(node)\n\n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            dfs_recursive(graph, neighbor, visited)\n```\n\n### Pattern 2: Iterative DFS with Stack\n```python\ndef dfs_iterative(graph, start):\n    visited = set()\n    stack = [start]\n\n    while stack:\n        node = stack.pop()\n\n        if node in visited:\n            continue\n\n        visited.add(node)\n        process(node)\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n```\n\n### Pattern 3: Detect Cycle in Directed Graph\n```python\ndef has_cycle(graph):\n    WHITE, GRAY, BLACK = 0, 1, 2\n    color = {node: WHITE for node in graph}\n\n    def dfs(node):\n        color[node] = GRAY\n\n        for neighbor in graph[node]:\n            if color[neighbor] == GRAY:\n                return True  # Back edge = cycle\n            if color[neighbor] == WHITE and dfs(neighbor):\n                return True\n\n        color[node] = BLACK\n        return False\n\n    return any(dfs(node) for node in graph if color[node] == WHITE)\n```\n\n\n---\n\n## When to Use This Technique\n\nUse DFS for path finding, topological sort, detecting cycles, finding strongly connected components, or exploring all paths.\n\n---\n\n## Common Pitfalls to Avoid\n\n- Stack overflow with deep recursion\n- Not marking nodes as visited (infinite loops)\n- Confusing DFS with BFS applications\n- Not handling disconnected components\n\n---\n\n## Practice Problems\n\nStart with these problems to master this concept:\n\n### 1. Dfs 1 [Easy]\n\nGraph problem: dfs.\n\n**Complexity:** Time O(O(V+E)), Space O(O(V))\n\n\n### 2. Dfs 2 [Easy]\n\nGraph problem: dfs.\n\n**Complexity:** Time O(O(V+E)), Space O(O(V))\n\n\n### 3. Dfs 3 [Easy]\n\nGraph problem: dfs.\n\n**Complexity:** Time O(O(V+E)), Space O(O(V))\n\n\n### 4. Dfs 5 [Easy]\n\nGraph problem: dfs.\n\n**Complexity:** Time O(O(V+E)), Space O(O(V))\n\n\n### 5. Dfs 7 [Easy]\n\nGraph problem: dfs.\n\n**Complexity:** Time O(O(V+E)), Space O(O(V))\n\n\n\n---\n\n## Key Takeaways\n\n- Depth First Search (DFS) is essential for graph traversal algorithm that explores as far as possible along each branch\n- Time complexity improvements can be significant with this technique\n- Practice problems in order of difficulty to build intuition\n- Focus on recognizing patterns in problem statements\n",
    "reading_time_minutes": 15,
    "key_concepts": [
      "Depth First Search (DFS)",
      "Recursive DFS"
    ],
    "problem_count": 45
  },
  {
    "family_id": "graph-bfs-037",
    "title": "Breadth First Search (BFS)",
    "content": "# Breadth First Search (BFS)\n\nGraph traversal that explores all neighbors before going deeper\n\n---\n\n## BFS Algorithm\n\nBFS explores graph level by level, visiting all neighbors before moving to next level.\n\n**Characteristics:**\n- Uses queue\n- Finds shortest path in unweighted graphs\n- Explores breadth before depth\n\n**Applications:**\n- Shortest path (unweighted)\n- Level-order traversal\n- Finding nearest nodes\n- Web crawling\n\n**Complexity:**\n- Time: O(V + E)\n- Space: O(V) for queue\n\n\n---\n\n## Common Patterns\n\n### Pattern 1: Basic BFS\n```python\nfrom collections import deque\n\ndef bfs(graph, start):\n    visited = {start}\n    queue = deque([start])\n\n    while queue:\n        node = queue.popleft()\n        process(node)\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n```\n\n### Pattern 2: BFS with Distance Tracking\n```python\ndef bfs_shortest_path(graph, start, target):\n    visited = {start}\n    queue = deque([(start, 0)])  # (node, distance)\n\n    while queue:\n        node, dist = queue.popleft()\n\n        if node == target:\n            return dist\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, dist + 1))\n\n    return -1  # Target not reachable\n```\n\n\n---\n\n## When to Use This Technique\n\nUse BFS for shortest path in unweighted graphs, level-order traversal, finding connected components at same distance, or minimum steps problems.\n\n---\n\n## Common Pitfalls to Avoid\n\n- Using BFS for weighted graphs (use Dijkstra)\n- Not using queue (using stack makes it DFS)\n- Marking visited too late (duplicates in queue)\n- Not handling disconnected graphs\n\n---\n\n## Practice Problems\n\nStart with these problems to master this concept:\n\n### 1. Bfs 1 [Easy]\n\nGraph problem: bfs.\n\n**Complexity:** Time O(O(V+E)), Space O(O(V))\n\n\n### 2. Bfs 2 [Easy]\n\nGraph problem: bfs.\n\n**Complexity:** Time O(O(V+E)), Space O(O(V))\n\n\n### 3. Bfs 7 [Easy]\n\nGraph problem: bfs.\n\n**Complexity:** Time O(O(V+E)), Space O(O(V))\n\n\n### 4. Bfs 12 [Easy]\n\nGraph problem: bfs.\n\n**Complexity:** Time O(O(V+E)), Space O(O(V))\n\n\n### 5. Bfs 18 [Easy]\n\nGraph problem: bfs.\n\n**Complexity:** Time O(O(V+E)), Space O(O(V))\n\n\n\n---\n\n## Key Takeaways\n\n- Breadth First Search (BFS) is essential for graph traversal that explores all neighbors before going deeper\n- Time complexity improvements can be significant with this technique\n- Practice problems in order of difficulty to build intuition\n- Focus on recognizing patterns in problem statements\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Breadth First Search (BFS)",
      "Basic BFS"
    ],
    "problem_count": 43
  },
  {
    "family_id": "graph-shortest-path-038",
    "title": "Shortest Path",
    "content": "# Shortest Path\n\nMaster Shortest Path - a key concept in Graphs.\n\n---\n\n## Overview\n\n**Topic:** Graphs\n**Subtopic:** Shortest Path\n**Problems Available:** 43\n**Difficulty Range:** hard, easy, medium\n\n---\n\n## What You'll Learn\n\nShortest Path is fundamental to solving graphs problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(V+E)**\n\n### Space Complexity\nTypical space requirement: **O(V)**\n\n### Common Tags\n`graph`\n\n---\n\n## Starter Template\n\n```python\ndef solve(graph):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Shortest Path 3 [Easy]\n\nGraph problem: shortest-path.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n### 2. Shortest Path 9 [Easy]\n\nGraph problem: shortest-path.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n### 3. Shortest Path 11 [Easy]\n\nGraph problem: shortest-path.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n### 4. Shortest Path 12 [Easy]\n\nGraph problem: shortest-path.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n### 5. Shortest Path 13 [Easy]\n\nGraph problem: shortest-path.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 41%\n- **Average Time:** 31 minutes per problem\n- **Total Points:** 900 points available\n\n---\n\n## Next Steps\n\nAfter mastering Shortest Path:\n\n1. Complete all 43 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Shortest Path",
      "Shortest Path",
      "Graphs"
    ],
    "problem_count": 43
  },
  {
    "family_id": "graph-mst-039",
    "title": "Mst",
    "content": "# Mst\n\nMaster Mst - a key concept in Graphs.\n\n---\n\n## Overview\n\n**Topic:** Graphs\n**Subtopic:** Mst\n**Problems Available:** 43\n**Difficulty Range:** medium, easy, hard\n\n---\n\n## What You'll Learn\n\nMst is fundamental to solving graphs problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(V+E)**\n\n### Space Complexity\nTypical space requirement: **O(V)**\n\n### Common Tags\n`graph`\n\n---\n\n## Starter Template\n\n```python\ndef solve(graph):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Mst 2 [Easy]\n\nGraph problem: mst.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n### 2. Mst 5 [Easy]\n\nGraph problem: mst.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n### 3. Mst 8 [Easy]\n\nGraph problem: mst.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n### 4. Mst 10 [Easy]\n\nGraph problem: mst.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n### 5. Mst 15 [Easy]\n\nGraph problem: mst.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 40%\n- **Average Time:** 32 minutes per problem\n- **Total Points:** 930 points available\n\n---\n\n## Next Steps\n\nAfter mastering Mst:\n\n1. Complete all 43 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Mst",
      "Mst",
      "Graphs"
    ],
    "problem_count": 43
  },
  {
    "family_id": "graph-topological-sort-040",
    "title": "Topological Sort",
    "content": "# Topological Sort\n\nMaster Topological Sort - a key concept in Graphs.\n\n---\n\n## Overview\n\n**Topic:** Graphs\n**Subtopic:** Topological Sort\n**Problems Available:** 43\n**Difficulty Range:** medium, easy, hard\n\n---\n\n## What You'll Learn\n\nTopological Sort is fundamental to solving graphs problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(V+E)**\n\n### Space Complexity\nTypical space requirement: **O(V)**\n\n### Common Tags\n`graph`\n\n---\n\n## Starter Template\n\n```python\ndef solve(graph):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Topological Sort 2 [Easy]\n\nGraph problem: topological-sort.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n### 2. Topological Sort 3 [Easy]\n\nGraph problem: topological-sort.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n### 3. Topological Sort 10 [Easy]\n\nGraph problem: topological-sort.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n### 4. Topological Sort 11 [Easy]\n\nGraph problem: topological-sort.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n### 5. Topological Sort 14 [Easy]\n\nGraph problem: topological-sort.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 44%\n- **Average Time:** 29 minutes per problem\n- **Total Points:** 850 points available\n\n---\n\n## Next Steps\n\nAfter mastering Topological Sort:\n\n1. Complete all 43 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Topological Sort",
      "Topological Sort",
      "Graphs"
    ],
    "problem_count": 43
  },
  {
    "family_id": "graph-union-find-041",
    "title": "Union Find (Disjoint Set Union)",
    "content": "# Union Find (Disjoint Set Union)\n\nEfficient data structure for tracking disjoint sets and performing union/find operations\n\n---\n\n## Union Find Data Structure\n\nUnion Find (also called Disjoint Set Union or DSU) is a data structure that tracks elements partitioned into disjoint sets and supports two operations efficiently:\n\n**Operations:**\n1. **Find:** Determine which set an element belongs to\n2. **Union:** Merge two sets into one\n\n**Key Concepts:**\n\n### Parent Array Representation\nEach element points to its parent. Root of tree represents the set.\n\n### Path Compression\nDuring find operation, make nodes point directly to root.\n- Flattens tree structure\n- Speeds up future operations\n\n### Union by Rank/Size\nWhen merging, attach smaller tree under root of larger tree.\n- Keeps trees balanced\n- Prevents degeneration to linked list\n\n**Time Complexity:**\n- Without optimization: O(n) per operation\n- With path compression + union by rank: O(α(n)) ≈ O(1)\n- α(n) is inverse Ackermann function (grows extremely slowly)\n\n**Space Complexity:** O(n)\n\n\n---\n\n## Common Patterns\n\n### Pattern 1: Basic Union Find\n```python\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))  # Each node is its own parent\n        self.rank = [0] * n          # Track tree height\n        self.components = n           # Number of disjoint sets\n\n    def find(self, x):\n        \"\"\"Find root with path compression\"\"\"\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])  # Path compression\n        return self.parent[x]\n\n    def union(self, x, y):\n        \"\"\"Union by rank\"\"\"\n        root_x, root_y = self.find(x), self.find(y)\n\n        if root_x == root_y:\n            return False  # Already in same set\n\n        # Union by rank: attach smaller tree under larger\n        if self.rank[root_x] < self.rank[root_y]:\n            self.parent[root_x] = root_y\n        elif self.rank[root_x] > self.rank[root_y]:\n            self.parent[root_y] = root_x\n        else:\n            self.parent[root_y] = root_x\n            self.rank[root_x] += 1\n\n        self.components -= 1\n        return True\n\n    def connected(self, x, y):\n        \"\"\"Check if two elements are in same set\"\"\"\n        return self.find(x) == self.find(y)\n\n    def count_components(self):\n        \"\"\"Get number of disjoint sets\"\"\"\n        return self.components\n```\n\n### Pattern 2: Union by Size (Alternative)\n```python\nclass UnionFindBySize:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n  # Track component size instead of rank\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        root_x, root_y = self.find(x), self.find(y)\n\n        if root_x == root_y:\n            return False\n\n        # Attach smaller component to larger\n        if self.size[root_x] < self.size[root_y]:\n            self.parent[root_x] = root_y\n            self.size[root_y] += self.size[root_x]\n        else:\n            self.parent[root_y] = root_x\n            self.size[root_x] += self.size[root_y]\n\n        return True\n\n    def get_size(self, x):\n        \"\"\"Get size of component containing x\"\"\"\n        return self.size[self.find(x)]\n```\n\n### Pattern 3: Detect Cycle in Graph\n```python\ndef has_cycle(n, edges):\n    \"\"\"Detect cycle in undirected graph using Union Find\"\"\"\n    uf = UnionFind(n)\n\n    for u, v in edges:\n        if uf.connected(u, v):\n            return True  # Cycle detected\n        uf.union(u, v)\n\n    return False\n```\n\n### Pattern 4: Count Connected Components\n```python\ndef count_components(n, edges):\n    \"\"\"Count connected components in graph\"\"\"\n    uf = UnionFind(n)\n\n    for u, v in edges:\n        uf.union(u, v)\n\n    return uf.count_components()\n```\n\n### Pattern 5: Kruskal's MST Algorithm\n```python\ndef kruskal_mst(n, edges):\n    \"\"\"Find Minimum Spanning Tree using Union Find\"\"\"\n    # Sort edges by weight\n    edges.sort(key=lambda x: x[2])\n\n    uf = UnionFind(n)\n    mst_edges = []\n    mst_weight = 0\n\n    for u, v, weight in edges:\n        if uf.union(u, v):  # If not in same component\n            mst_edges.append((u, v, weight))\n            mst_weight += weight\n\n            if len(mst_edges) == n - 1:\n                break  # MST complete\n\n    return mst_edges, mst_weight\n```\n\n\n---\n\n## When to Use This Technique\n\nUse Union Find for: dynamic connectivity problems, detecting cycles in undirected graphs, finding connected components, Kruskal's MST algorithm, or any problem involving merging/grouping elements.\n\n---\n\n## Common Pitfalls to Avoid\n\n- Forgetting path compression (makes operations slow)\n- Not using union by rank/size (creates unbalanced trees)\n- Using Union Find for directed graphs (use SCC algorithms instead)\n- Not initializing parent array correctly\n- Forgetting to check if elements are already connected before union\n- Trying to use for shortest path (use Dijkstra/BFS instead)\n\n---\n\n## Practice Problems\n\nStart with these problems to master this concept:\n\n### 1. Union Find 6 [Easy]\n\nGraph problem: union-find.\n\n**Complexity:** Time O(O(V+E)), Space O(O(V))\n\n\n### 2. Union Find 8 [Easy]\n\nGraph problem: union-find.\n\n**Complexity:** Time O(O(V+E)), Space O(O(V))\n\n\n### 3. Union Find 12 [Easy]\n\nGraph problem: union-find.\n\n**Complexity:** Time O(O(V+E)), Space O(O(V))\n\n\n### 4. Union Find 20 [Easy]\n\nGraph problem: union-find.\n\n**Complexity:** Time O(O(V+E)), Space O(O(V))\n\n\n### 5. Union Find 21 [Easy]\n\nGraph problem: union-find.\n\n**Complexity:** Time O(O(V+E)), Space O(O(V))\n\n\n\n---\n\n## Key Takeaways\n\n- Union Find (Disjoint Set Union) is essential for efficient data structure for tracking disjoint sets and performing union/find operations\n- Time complexity improvements can be significant with this technique\n- Practice problems in order of difficulty to build intuition\n- Focus on recognizing patterns in problem statements\n",
    "reading_time_minutes": 20,
    "key_concepts": [
      "Union Find (Disjoint Set Union)",
      "Basic Union Find"
    ],
    "problem_count": 43
  },
  {
    "family_id": "graph-scc-042",
    "title": "Scc",
    "content": "# Scc\n\nMaster Scc - a key concept in Graphs.\n\n---\n\n## Overview\n\n**Topic:** Graphs\n**Subtopic:** Scc\n**Problems Available:** 43\n**Difficulty Range:** medium, easy, hard\n\n---\n\n## What You'll Learn\n\nScc is fundamental to solving graphs problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(V+E)**\n\n### Space Complexity\nTypical space requirement: **O(V)**\n\n### Common Tags\n`graph`\n\n---\n\n## Starter Template\n\n```python\ndef solve(graph):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Scc 3 [Easy]\n\nGraph problem: scc.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n### 2. Scc 4 [Easy]\n\nGraph problem: scc.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n### 3. Scc 9 [Easy]\n\nGraph problem: scc.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n### 4. Scc 11 [Easy]\n\nGraph problem: scc.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n### 5. Scc 12 [Easy]\n\nGraph problem: scc.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 44%\n- **Average Time:** 29 minutes per problem\n- **Total Points:** 850 points available\n\n---\n\n## Next Steps\n\nAfter mastering Scc:\n\n1. Complete all 43 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Scc",
      "Scc",
      "Graphs"
    ],
    "problem_count": 43
  },
  {
    "family_id": "graph-bipartite-043",
    "title": "Bipartite",
    "content": "# Bipartite\n\nMaster Bipartite - a key concept in Graphs.\n\n---\n\n## Overview\n\n**Topic:** Graphs\n**Subtopic:** Bipartite\n**Problems Available:** 43\n**Difficulty Range:** hard, medium, easy\n\n---\n\n## What You'll Learn\n\nBipartite is fundamental to solving graphs problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(V+E)**\n\n### Space Complexity\nTypical space requirement: **O(V)**\n\n### Common Tags\n`graph`\n\n---\n\n## Starter Template\n\n```python\ndef solve(graph):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Bipartite 5 [Easy]\n\nGraph problem: bipartite.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n### 2. Bipartite 6 [Easy]\n\nGraph problem: bipartite.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n### 3. Bipartite 7 [Easy]\n\nGraph problem: bipartite.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n### 4. Bipartite 8 [Easy]\n\nGraph problem: bipartite.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n### 5. Bipartite 9 [Easy]\n\nGraph problem: bipartite.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 45%\n- **Average Time:** 28 minutes per problem\n- **Total Points:** 830 points available\n\n---\n\n## Next Steps\n\nAfter mastering Bipartite:\n\n1. Complete all 43 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Bipartite",
      "Bipartite",
      "Graphs"
    ],
    "problem_count": 43
  },
  {
    "family_id": "graph-graph-coloring-044",
    "title": "Graph Coloring",
    "content": "# Graph Coloring\n\nMaster Graph Coloring - a key concept in Graphs.\n\n---\n\n## Overview\n\n**Topic:** Graphs\n**Subtopic:** Graph Coloring\n**Problems Available:** 43\n**Difficulty Range:** medium, hard, easy\n\n---\n\n## What You'll Learn\n\nGraph Coloring is fundamental to solving graphs problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(V+E)**\n\n### Space Complexity\nTypical space requirement: **O(V)**\n\n### Common Tags\n`graph`\n\n---\n\n## Starter Template\n\n```python\ndef solve(graph):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Graph Coloring 5 [Easy]\n\nGraph problem: graph-coloring.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n### 2. Graph Coloring 6 [Easy]\n\nGraph problem: graph-coloring.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n### 3. Graph Coloring 7 [Easy]\n\nGraph problem: graph-coloring.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n### 4. Graph Coloring 16 [Easy]\n\nGraph problem: graph-coloring.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n### 5. Graph Coloring 17 [Easy]\n\nGraph problem: graph-coloring.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 43%\n- **Average Time:** 30 minutes per problem\n- **Total Points:** 860 points available\n\n---\n\n## Next Steps\n\nAfter mastering Graph Coloring:\n\n1. Complete all 43 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Graph Coloring",
      "Graph Coloring",
      "Graphs"
    ],
    "problem_count": 43
  },
  {
    "family_id": "graph-network-flow-045",
    "title": "Network Flow",
    "content": "# Network Flow\n\nMaster Network Flow - a key concept in Graphs.\n\n---\n\n## Overview\n\n**Topic:** Graphs\n**Subtopic:** Network Flow\n**Problems Available:** 43\n**Difficulty Range:** easy, hard, medium\n\n---\n\n## What You'll Learn\n\nNetwork Flow is fundamental to solving graphs problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(V+E)**\n\n### Space Complexity\nTypical space requirement: **O(V)**\n\n### Common Tags\n`graph`\n\n---\n\n## Starter Template\n\n```python\ndef solve(graph):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Network Flow 1 [Easy]\n\nGraph problem: network-flow.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n### 2. Network Flow 3 [Easy]\n\nGraph problem: network-flow.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n### 3. Network Flow 11 [Easy]\n\nGraph problem: network-flow.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n### 4. Network Flow 14 [Easy]\n\nGraph problem: network-flow.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n### 5. Network Flow 20 [Easy]\n\nGraph problem: network-flow.\n\n**Time:** O(O(V+E)), **Space:** O(O(V))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 43%\n- **Average Time:** 30 minutes per problem\n- **Total Points:** 860 points available\n\n---\n\n## Next Steps\n\nAfter mastering Network Flow:\n\n1. Complete all 43 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Network Flow",
      "Network Flow",
      "Graphs"
    ],
    "problem_count": 43
  },
  {
    "family_id": "hash-hash-map-basics-046",
    "title": "Hash Map Basics",
    "content": "# Hash Map Basics\n\nMaster Hash Map Basics - a key concept in Hash Tables & Sets.\n\n---\n\n## Overview\n\n**Topic:** Hash Tables & Sets\n**Subtopic:** Hash Map Basics\n**Problems Available:** 50\n**Difficulty Range:** medium, hard, easy\n\n---\n\n## What You'll Learn\n\nHash Map Basics is fundamental to solving hash tables & sets problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`hash-map`\n\n---\n\n## Starter Template\n\n```python\ndef solve(data):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Hash Map Basics 4 [Easy]\n\nHash table problem: hash-map-basics.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. Hash Map Basics 5 [Easy]\n\nHash table problem: hash-map-basics.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. Hash Map Basics 9 [Easy]\n\nHash table problem: hash-map-basics.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. Hash Map Basics 15 [Easy]\n\nHash table problem: hash-map-basics.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. Hash Map Basics 16 [Easy]\n\nHash table problem: hash-map-basics.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 45%\n- **Average Time:** 29 minutes per problem\n- **Total Points:** 970 points available\n\n---\n\n## Next Steps\n\nAfter mastering Hash Map Basics:\n\n1. Complete all 50 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Hash Map Basics",
      "Hash Map Basics",
      "Hash Tables & Sets"
    ],
    "problem_count": 50
  },
  {
    "family_id": "hash-counting-047",
    "title": "Counting",
    "content": "# Counting\n\nMaster Counting - a key concept in Hash Tables & Sets.\n\n---\n\n## Overview\n\n**Topic:** Hash Tables & Sets\n**Subtopic:** Counting\n**Problems Available:** 50\n**Difficulty Range:** easy, hard, medium\n\n---\n\n## What You'll Learn\n\nCounting is fundamental to solving hash tables & sets problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`hash-map`\n\n---\n\n## Starter Template\n\n```python\ndef solve(data):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Counting 1 [Easy]\n\nHash table problem: counting.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. Counting 7 [Easy]\n\nHash table problem: counting.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. Counting 10 [Easy]\n\nHash table problem: counting.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. Counting 12 [Easy]\n\nHash table problem: counting.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. Counting 13 [Easy]\n\nHash table problem: counting.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 45%\n- **Average Time:** 29 minutes per problem\n- **Total Points:** 970 points available\n\n---\n\n## Next Steps\n\nAfter mastering Counting:\n\n1. Complete all 50 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Counting",
      "Counting",
      "Hash Tables & Sets"
    ],
    "problem_count": 50
  },
  {
    "family_id": "hash-anagrams-048",
    "title": "Anagrams",
    "content": "# Anagrams\n\nMaster Anagrams - a key concept in Hash Tables & Sets.\n\n---\n\n## Overview\n\n**Topic:** Hash Tables & Sets\n**Subtopic:** Anagrams\n**Problems Available:** 50\n**Difficulty Range:** hard, easy, medium\n\n---\n\n## What You'll Learn\n\nAnagrams is fundamental to solving hash tables & sets problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`hash-map`\n\n---\n\n## Starter Template\n\n```python\ndef solve(data):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Anagrams 2 [Easy]\n\nHash table problem: anagrams.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. Anagrams 5 [Easy]\n\nHash table problem: anagrams.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. Anagrams 10 [Easy]\n\nHash table problem: anagrams.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. Anagrams 13 [Easy]\n\nHash table problem: anagrams.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. Anagrams 17 [Easy]\n\nHash table problem: anagrams.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 41%\n- **Average Time:** 31 minutes per problem\n- **Total Points:** 1050 points available\n\n---\n\n## Next Steps\n\nAfter mastering Anagrams:\n\n1. Complete all 50 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Anagrams",
      "Anagrams",
      "Hash Tables & Sets"
    ],
    "problem_count": 50
  },
  {
    "family_id": "hash-two-sum-variants-049",
    "title": "Two Sum Variants",
    "content": "# Two Sum Variants\n\nMaster Two Sum Variants - a key concept in Hash Tables & Sets.\n\n---\n\n## Overview\n\n**Topic:** Hash Tables & Sets\n**Subtopic:** Two Sum Variants\n**Problems Available:** 50\n**Difficulty Range:** medium, hard, easy\n\n---\n\n## What You'll Learn\n\nTwo Sum Variants is fundamental to solving hash tables & sets problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`hash-map`\n\n---\n\n## Starter Template\n\n```python\ndef solve(data):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Two Sum Variants 5 [Easy]\n\nHash table problem: two-sum-variants.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. Two Sum Variants 6 [Easy]\n\nHash table problem: two-sum-variants.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. Two Sum Variants 10 [Easy]\n\nHash table problem: two-sum-variants.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. Two Sum Variants 11 [Easy]\n\nHash table problem: two-sum-variants.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. Two Sum Variants 12 [Easy]\n\nHash table problem: two-sum-variants.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 48%\n- **Average Time:** 27 minutes per problem\n- **Total Points:** 900 points available\n\n---\n\n## Next Steps\n\nAfter mastering Two Sum Variants:\n\n1. Complete all 50 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Two Sum Variants",
      "Two Sum Variants",
      "Hash Tables & Sets"
    ],
    "problem_count": 50
  },
  {
    "family_id": "hash-lru-cache-050",
    "title": "Lru Cache",
    "content": "# Lru Cache\n\nMaster Lru Cache - a key concept in Hash Tables & Sets.\n\n---\n\n## Overview\n\n**Topic:** Hash Tables & Sets\n**Subtopic:** Lru Cache\n**Problems Available:** 50\n**Difficulty Range:** easy, hard, medium\n\n---\n\n## What You'll Learn\n\nLru Cache is fundamental to solving hash tables & sets problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`hash-map`\n\n---\n\n## Starter Template\n\n```python\ndef solve(data):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Lru Cache 1 [Easy]\n\nHash table problem: lru-cache.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. Lru Cache 3 [Easy]\n\nHash table problem: lru-cache.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. Lru Cache 7 [Easy]\n\nHash table problem: lru-cache.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. Lru Cache 13 [Easy]\n\nHash table problem: lru-cache.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. Lru Cache 14 [Easy]\n\nHash table problem: lru-cache.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 41%\n- **Average Time:** 31 minutes per problem\n- **Total Points:** 1050 points available\n\n---\n\n## Next Steps\n\nAfter mastering Lru Cache:\n\n1. Complete all 50 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Lru Cache",
      "Lru Cache",
      "Hash Tables & Sets"
    ],
    "problem_count": 50
  },
  {
    "family_id": "hash-design-problems-051",
    "title": "Design Problems",
    "content": "# Design Problems\n\nMaster Design Problems - a key concept in Hash Tables & Sets.\n\n---\n\n## Overview\n\n**Topic:** Hash Tables & Sets\n**Subtopic:** Design Problems\n**Problems Available:** 50\n**Difficulty Range:** easy, medium, hard\n\n---\n\n## What You'll Learn\n\nDesign Problems is fundamental to solving hash tables & sets problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`hash-map`\n\n---\n\n## Starter Template\n\n```python\ndef solve(data):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Design Problems 1 [Easy]\n\nHash table problem: design-problems.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. Design Problems 4 [Easy]\n\nHash table problem: design-problems.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. Design Problems 5 [Easy]\n\nHash table problem: design-problems.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. Design Problems 7 [Easy]\n\nHash table problem: design-problems.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. Design Problems 10 [Easy]\n\nHash table problem: design-problems.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 47%\n- **Average Time:** 27 minutes per problem\n- **Total Points:** 930 points available\n\n---\n\n## Next Steps\n\nAfter mastering Design Problems:\n\n1. Complete all 50 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Design Problems",
      "Design Problems",
      "Hash Tables & Sets"
    ],
    "problem_count": 50
  },
  {
    "family_id": "heap-min-heap-052",
    "title": "Min Heap & Priority Queue",
    "content": "# Min Heap & Priority Queue\n\nBinary heap maintaining minimum element at root for efficient priority-based operations\n\n---\n\n## Min Heap Data Structure\n\nA min heap is a complete binary tree where each parent node is smaller than or equal to its children. The minimum element is always at the root.\n\n**Properties:**\n- Complete binary tree\n- Parent ≤ Children (min heap property)\n- Root contains minimum element\n- Height: O(log n)\n\n**Array Representation:**\n- Parent of i: (i-1)//2\n- Left child of i: 2*i + 1\n- Right child of i: 2*i + 2\n\n**Operations:**\n- Insert: O(log n) - Add at end, bubble up\n- Extract Min: O(log n) - Remove root, bubble down\n- Get Min: O(1) - Return root\n- Heapify: O(n) - Build heap from array\n\n**Applications:**\n- Priority queues\n- Dijkstra's algorithm\n- Huffman coding\n- K-way merge\n- Finding median in stream\n\n\n---\n\n## Common Patterns\n\n### Pattern 1: Using Python's heapq (Min Heap)\n```python\nimport heapq\n\n# Create heap\nheap = []\n\n# Insert elements\nheapq.heappush(heap, 5)\nheapq.heappush(heap, 3)\nheapq.heappush(heap, 7)\n\n# Get minimum (peek)\nmin_val = heap[0]  # O(1)\n\n# Extract minimum\nmin_val = heapq.heappop(heap)  # O(log n)\n\n# Heapify existing list\narr = [5, 3, 7, 1]\nheapq.heapify(arr)  # O(n)\n```\n\n### Pattern 2: K Smallest Elements\n```python\ndef k_smallest(arr, k):\n    # Use max heap to keep k smallest\n    # Negate values for max heap behavior\n    heap = []\n\n    for num in arr:\n        heapq.heappush(heap, -num)\n        if len(heap) > k:\n            heapq.heappop(heap)\n\n    return [-x for x in heap]\n```\n\n### Pattern 3: Merge K Sorted Lists\n```python\ndef merge_k_sorted(lists):\n    heap = []\n    result = []\n\n    # Push first element of each list\n    for i, lst in enumerate(lists):\n        if lst:\n            heapq.heappush(heap, (lst[0], i, 0))  # (value, list_idx, elem_idx)\n\n    while heap:\n        val, list_idx, elem_idx = heapq.heappop(heap)\n        result.append(val)\n\n        # Add next element from same list\n        if elem_idx + 1 < len(lists[list_idx]):\n            next_val = lists[list_idx][elem_idx + 1]\n            heapq.heappush(heap, (next_val, list_idx, elem_idx + 1))\n\n    return result\n```\n\n### Pattern 4: Custom Priority Queue with Objects\n```python\nimport heapq\n\nclass Task:\n    def __init__(self, priority, name):\n        self.priority = priority\n        self.name = name\n\n    def __lt__(self, other):\n        return self.priority < other.priority\n\npq = []\nheapq.heappush(pq, Task(3, \"Low priority\"))\nheapq.heappush(pq, Task(1, \"High priority\"))\n\nhighest_priority = heapq.heappop(pq)\n```\n\n\n---\n\n## When to Use This Technique\n\nUse min heap for: finding minimum element repeatedly, priority queue implementation, k smallest elements, merging sorted arrays, or scheduling tasks by priority.\n\n---\n\n## Common Pitfalls to Avoid\n\n- Confusing min heap and max heap (Python heapq is min heap)\n- Forgetting to negate values for max heap simulation\n- Not maintaining heap property after modifications\n- Trying to find k largest with min heap directly\n- Not handling empty heap operations\n- Comparing uncomparable objects without __lt__\n\n---\n\n## Practice Problems\n\nStart with these problems to master this concept:\n\n### 1. Min Heap 4 [Easy]\n\nHeap problem: min-heap.\n\n**Complexity:** Time O(O(n log k)), Space O(O(k))\n\n\n### 2. Min Heap 6 [Easy]\n\nHeap problem: min-heap.\n\n**Complexity:** Time O(O(n log k)), Space O(O(k))\n\n\n### 3. Min Heap 7 [Easy]\n\nHeap problem: min-heap.\n\n**Complexity:** Time O(O(n log k)), Space O(O(k))\n\n\n### 4. Min Heap 9 [Easy]\n\nHeap problem: min-heap.\n\n**Complexity:** Time O(O(n log k)), Space O(O(k))\n\n\n### 5. Min Heap 10 [Easy]\n\nHeap problem: min-heap.\n\n**Complexity:** Time O(O(n log k)), Space O(O(k))\n\n\n\n---\n\n## Key Takeaways\n\n- Min Heap & Priority Queue is essential for binary heap maintaining minimum element at root for efficient priority-based operations\n- Time complexity improvements can be significant with this technique\n- Practice problems in order of difficulty to build intuition\n- Focus on recognizing patterns in problem statements\n",
    "reading_time_minutes": 20,
    "key_concepts": [
      "Min Heap & Priority Queue",
      "Using Python's heapq (Min Heap)"
    ],
    "problem_count": 49
  },
  {
    "family_id": "heap-max-heap-053",
    "title": "Max Heap",
    "content": "# Max Heap\n\nMaster Max Heap - a key concept in Heaps & Priority Queues.\n\n---\n\n## Overview\n\n**Topic:** Heaps & Priority Queues\n**Subtopic:** Max Heap\n**Problems Available:** 49\n**Difficulty Range:** medium, easy, hard\n\n---\n\n## What You'll Learn\n\nMax Heap is fundamental to solving heaps & priority queues problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n log k)**\n\n### Space Complexity\nTypical space requirement: **O(k)**\n\n### Common Tags\n`heap`\n\n---\n\n## Starter Template\n\n```python\ndef solve(data, k):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Max Heap 5 [Easy]\n\nHeap problem: max-heap.\n\n**Time:** O(O(n log k)), **Space:** O(O(k))\n\n**Companies:** Various\n\n\n### 2. Max Heap 8 [Easy]\n\nHeap problem: max-heap.\n\n**Time:** O(O(n log k)), **Space:** O(O(k))\n\n**Companies:** Various\n\n\n### 3. Max Heap 13 [Easy]\n\nHeap problem: max-heap.\n\n**Time:** O(O(n log k)), **Space:** O(O(k))\n\n**Companies:** Various\n\n\n### 4. Max Heap 19 [Easy]\n\nHeap problem: max-heap.\n\n**Time:** O(O(n log k)), **Space:** O(O(k))\n\n**Companies:** Various\n\n\n### 5. Max Heap 21 [Easy]\n\nHeap problem: max-heap.\n\n**Time:** O(O(n log k)), **Space:** O(O(k))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 42%\n- **Average Time:** 30 minutes per problem\n- **Total Points:** 1010 points available\n\n---\n\n## Next Steps\n\nAfter mastering Max Heap:\n\n1. Complete all 49 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Max Heap",
      "Max Heap",
      "Heaps & Priority Queues"
    ],
    "problem_count": 49
  },
  {
    "family_id": "heap-k-way-merge-054",
    "title": "K Way Merge",
    "content": "# K Way Merge\n\nMaster K Way Merge - a key concept in Heaps & Priority Queues.\n\n---\n\n## Overview\n\n**Topic:** Heaps & Priority Queues\n**Subtopic:** K Way Merge\n**Problems Available:** 49\n**Difficulty Range:** easy, medium, hard\n\n---\n\n## What You'll Learn\n\nK Way Merge is fundamental to solving heaps & priority queues problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n log k)**\n\n### Space Complexity\nTypical space requirement: **O(k)**\n\n### Common Tags\n`heap`\n\n---\n\n## Starter Template\n\n```python\ndef solve(data, k):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. K Way Merge 1 [Easy]\n\nHeap problem: k-way-merge.\n\n**Time:** O(O(n log k)), **Space:** O(O(k))\n\n**Companies:** Various\n\n\n### 2. K Way Merge 3 [Easy]\n\nHeap problem: k-way-merge.\n\n**Time:** O(O(n log k)), **Space:** O(O(k))\n\n**Companies:** Various\n\n\n### 3. K Way Merge 11 [Easy]\n\nHeap problem: k-way-merge.\n\n**Time:** O(O(n log k)), **Space:** O(O(k))\n\n**Companies:** Various\n\n\n### 4. K Way Merge 12 [Easy]\n\nHeap problem: k-way-merge.\n\n**Time:** O(O(n log k)), **Space:** O(O(k))\n\n**Companies:** Various\n\n\n### 5. K Way Merge 20 [Easy]\n\nHeap problem: k-way-merge.\n\n**Time:** O(O(n log k)), **Space:** O(O(k))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 39%\n- **Average Time:** 32 minutes per problem\n- **Total Points:** 1060 points available\n\n---\n\n## Next Steps\n\nAfter mastering K Way Merge:\n\n1. Complete all 49 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "K Way Merge",
      "K Way Merge",
      "Heaps & Priority Queues"
    ],
    "problem_count": 49
  },
  {
    "family_id": "heap-top-k-055",
    "title": "Top K",
    "content": "# Top K\n\nMaster Top K - a key concept in Heaps & Priority Queues.\n\n---\n\n## Overview\n\n**Topic:** Heaps & Priority Queues\n**Subtopic:** Top K Elements\n**Problems Available:** 50\n**Difficulty Range:** medium, easy, hard\n\n---\n\n## What You'll Learn\n\nTop K is fundamental to solving heaps & priority queues problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n log k)**\n\n### Space Complexity\nTypical space requirement: **O(k)**\n\n### Common Tags\n`heap`, `quickselect`\n\n---\n\n## Starter Template\n\n```python\ndef findKthLargest(nums: List[int], k: int) -> int:\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Top K 1 [Easy]\n\nHeap problem: top-k.\n\n**Time:** O(O(n log k)), **Space:** O(O(k))\n\n**Companies:** Various\n\n\n### 2. Top K 3 [Easy]\n\nHeap problem: top-k.\n\n**Time:** O(O(n log k)), **Space:** O(O(k))\n\n**Companies:** Various\n\n\n### 3. Top K 5 [Easy]\n\nHeap problem: top-k.\n\n**Time:** O(O(n log k)), **Space:** O(O(k))\n\n**Companies:** Various\n\n\n### 4. Top K 7 [Easy]\n\nHeap problem: top-k.\n\n**Time:** O(O(n log k)), **Space:** O(O(k))\n\n**Companies:** Various\n\n\n### 5. Top K 8 [Easy]\n\nHeap problem: top-k.\n\n**Time:** O(O(n log k)), **Space:** O(O(k))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 45%\n- **Average Time:** 29 minutes per problem\n- **Total Points:** 980 points available\n\n---\n\n## Next Steps\n\nAfter mastering Top K:\n\n1. Complete all 50 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Top K",
      "Top K Elements",
      "Heaps & Priority Queues"
    ],
    "problem_count": 50
  },
  {
    "family_id": "heap-running-median-056",
    "title": "Running Median",
    "content": "# Running Median\n\nMaster Running Median - a key concept in Heaps & Priority Queues.\n\n---\n\n## Overview\n\n**Topic:** Heaps & Priority Queues\n**Subtopic:** Running Median\n**Problems Available:** 49\n**Difficulty Range:** easy, hard, medium\n\n---\n\n## What You'll Learn\n\nRunning Median is fundamental to solving heaps & priority queues problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n log k)**\n\n### Space Complexity\nTypical space requirement: **O(k)**\n\n### Common Tags\n`heap`\n\n---\n\n## Starter Template\n\n```python\ndef solve(data, k):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Running Median 1 [Easy]\n\nHeap problem: running-median.\n\n**Time:** O(O(n log k)), **Space:** O(O(k))\n\n**Companies:** Various\n\n\n### 2. Running Median 6 [Easy]\n\nHeap problem: running-median.\n\n**Time:** O(O(n log k)), **Space:** O(O(k))\n\n**Companies:** Various\n\n\n### 3. Running Median 9 [Easy]\n\nHeap problem: running-median.\n\n**Time:** O(O(n log k)), **Space:** O(O(k))\n\n**Companies:** Various\n\n\n### 4. Running Median 11 [Easy]\n\nHeap problem: running-median.\n\n**Time:** O(O(n log k)), **Space:** O(O(k))\n\n**Companies:** Various\n\n\n### 5. Running Median 14 [Easy]\n\nHeap problem: running-median.\n\n**Time:** O(O(n log k)), **Space:** O(O(k))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 45%\n- **Average Time:** 28 minutes per problem\n- **Total Points:** 940 points available\n\n---\n\n## Next Steps\n\nAfter mastering Running Median:\n\n1. Complete all 49 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Running Median",
      "Running Median",
      "Heaps & Priority Queues"
    ],
    "problem_count": 49
  },
  {
    "family_id": "sort-search-comparison-sorts-057",
    "title": "Search Comparison Sorts",
    "content": "# Search Comparison Sorts\n\nMaster Search Comparison Sorts - a key concept in Sorting & Searching.\n\n---\n\n## Overview\n\n**Topic:** Sorting & Searching\n**Subtopic:** Comparison Sorts\n**Problems Available:** 49\n**Difficulty Range:** hard, medium, easy\n\n---\n\n## What You'll Learn\n\nSearch Comparison Sorts is fundamental to solving sorting & searching problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n log n)**\n\n### Space Complexity\nTypical space requirement: **O(1)**\n\n### Common Tags\n`sorting`, `searching`\n\n---\n\n## Starter Template\n\n```python\ndef solve(nums, target):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Comparison Sorts 4 [Easy]\n\nSorting/Searching: comparison-sorts.\n\n**Time:** O(O(log n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 2. Comparison Sorts 5 [Easy]\n\nSorting/Searching: comparison-sorts.\n\n**Time:** O(O(n log n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 3. Comparison Sorts 11 [Easy]\n\nSorting/Searching: comparison-sorts.\n\n**Time:** O(O(n log n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 4. Comparison Sorts 12 [Easy]\n\nSorting/Searching: comparison-sorts.\n\n**Time:** O(O(log n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 5. Comparison Sorts 15 [Easy]\n\nSorting/Searching: comparison-sorts.\n\n**Time:** O(O(n log n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 49%\n- **Average Time:** 26 minutes per problem\n- **Total Points:** 870 points available\n\n---\n\n## Next Steps\n\nAfter mastering Search Comparison Sorts:\n\n1. Complete all 49 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Search Comparison Sorts",
      "Comparison Sorts",
      "Sorting & Searching"
    ],
    "problem_count": 49
  },
  {
    "family_id": "sort-search-non-comparison-sorts-058",
    "title": "Search Non Comparison Sorts",
    "content": "# Search Non Comparison Sorts\n\nMaster Search Non Comparison Sorts - a key concept in Sorting & Searching.\n\n---\n\n## Overview\n\n**Topic:** Sorting & Searching\n**Subtopic:** Non Comparison Sorts\n**Problems Available:** 49\n**Difficulty Range:** easy, hard, medium\n\n---\n\n## What You'll Learn\n\nSearch Non Comparison Sorts is fundamental to solving sorting & searching problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n log n)**\n\n### Space Complexity\nTypical space requirement: **O(1)**\n\n### Common Tags\n`sorting`, `searching`\n\n---\n\n## Starter Template\n\n```python\ndef solve(nums, target):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Non Comparison Sorts 1 [Easy]\n\nSorting/Searching: non-comparison-sorts.\n\n**Time:** O(O(n log n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 2. Non Comparison Sorts 2 [Easy]\n\nSorting/Searching: non-comparison-sorts.\n\n**Time:** O(O(n log n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 3. Non Comparison Sorts 3 [Easy]\n\nSorting/Searching: non-comparison-sorts.\n\n**Time:** O(O(n log n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 4. Non Comparison Sorts 7 [Easy]\n\nSorting/Searching: non-comparison-sorts.\n\n**Time:** O(O(n log n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 5. Non Comparison Sorts 8 [Easy]\n\nSorting/Searching: non-comparison-sorts.\n\n**Time:** O(O(log n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 44%\n- **Average Time:** 29 minutes per problem\n- **Total Points:** 960 points available\n\n---\n\n## Next Steps\n\nAfter mastering Search Non Comparison Sorts:\n\n1. Complete all 49 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Search Non Comparison Sorts",
      "Non Comparison Sorts",
      "Sorting & Searching"
    ],
    "problem_count": 49
  },
  {
    "family_id": "sort-search-binary-search-059",
    "title": "Binary Search",
    "content": "# Binary Search\n\nEfficient search algorithm for sorted arrays using divide and conquer\n\n---\n\n## Binary Search Algorithm\n\nBinary search is a divide-and-conquer algorithm that finds the position of a target value in a sorted array by repeatedly dividing the search interval in half.\n\n**Requirements:**\n- Array must be sorted\n- Random access to elements\n\n**Process:**\n1. Compare target with middle element\n2. If equal, return position\n3. If target < middle, search left half\n4. If target > middle, search right half\n5. Repeat until found or search space empty\n\n**Complexity:**\n- Time: O(log n) - halves search space each iteration\n- Space: O(1) iterative, O(log n) recursive\n\n**Variations:**\n- Find exact match\n- Find first/last occurrence\n- Find insert position\n- Find in rotated array\n\n\n---\n\n## Common Patterns\n\n### Pattern 1: Basic Binary Search\n```python\ndef binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n\n    while left <= right:\n        mid = left + (right - left) // 2  # Avoid overflow\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1  # Not found\n```\n\n### Pattern 2: Find First Occurrence\n```python\ndef find_first(arr, target):\n    left, right = 0, len(arr) - 1\n    result = -1\n\n    while left <= right:\n        mid = left + (right - left) // 2\n\n        if arr[mid] == target:\n            result = mid\n            right = mid - 1  # Continue searching left\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return result\n```\n\n### Pattern 3: Find Insert Position\n```python\ndef search_insert(arr, target):\n    left, right = 0, len(arr)\n\n    while left < right:\n        mid = left + (right - left) // 2\n\n        if arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid\n\n    return left\n```\n\n### Pattern 4: Binary Search on Answer (Minimize/Maximize)\n```python\ndef minimize_max_distance(arr, k):\n    def can_place(min_dist):\n        \"\"\"Check if we can place k elements with min_dist apart\"\"\"\n        count, last_pos = 1, arr[0]\n\n        for i in range(1, len(arr)):\n            if arr[i] - last_pos >= min_dist:\n                count += 1\n                last_pos = arr[i]\n                if count == k:\n                    return True\n        return False\n\n    left, right = 1, arr[-1] - arr[0]\n    result = 0\n\n    while left <= right:\n        mid = (left + right) // 2\n        if can_place(mid):\n            result = mid\n            left = mid + 1  # Try larger distance\n        else:\n            right = mid - 1\n\n    return result\n```\n\n### Pattern 5: Search in Rotated Sorted Array\n```python\ndef search_rotated(arr, target):\n    left, right = 0, len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n\n        # Determine which half is sorted\n        if arr[left] <= arr[mid]:  # Left half sorted\n            if arr[left] <= target < arr[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:  # Right half sorted\n            if arr[mid] < target <= arr[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n    return -1\n```\n\n\n---\n\n## When to Use This Technique\n\nUse binary search for: searching in sorted arrays, finding boundaries, optimization problems (binary search on answer), minimizing/maximizing with monotonic functions.\n\n---\n\n## Common Pitfalls to Avoid\n\n- Off-by-one errors in boundary conditions\n- Integer overflow in mid calculation (use left + (right-left)//2)\n- Using on unsorted arrays\n- Wrong loop condition (left <= right vs left < right)\n- Not considering empty array\n- Infinite loops from incorrect boundary updates\n\n---\n\n## Practice Problems\n\nStart with these problems to master this concept:\n\n### 1. Binary Search [Easy]\n\nSearch target in sorted array.\n\n**Complexity:** Time O(O(log n)), Space O(O(1))\n\n\n### 2. Binary Search 1 [Easy]\n\nSorting/Searching: binary-search.\n\n**Complexity:** Time O(O(log n)), Space O(O(1))\n\n\n### 3. Binary Search 2 [Easy]\n\nSorting/Searching: binary-search.\n\n**Complexity:** Time O(O(log n)), Space O(O(1))\n\n\n### 4. Binary Search 6 [Easy]\n\nSorting/Searching: binary-search.\n\n**Complexity:** Time O(O(log n)), Space O(O(1))\n\n\n### 5. Binary Search 15 [Easy]\n\nSorting/Searching: binary-search.\n\n**Complexity:** Time O(O(n log n)), Space O(O(1))\n\n\n\n---\n\n## Key Takeaways\n\n- Binary Search is essential for efficient search algorithm for sorted arrays using divide and conquer\n- Time complexity improvements can be significant with this technique\n- Practice problems in order of difficulty to build intuition\n- Focus on recognizing patterns in problem statements\n",
    "reading_time_minutes": 20,
    "key_concepts": [
      "Binary Search",
      "Basic Binary Search"
    ],
    "problem_count": 50
  },
  {
    "family_id": "sort-search-rotated-array-060",
    "title": "Search Rotated Array",
    "content": "# Search Rotated Array\n\nMaster Search Rotated Array - a key concept in Sorting & Searching.\n\n---\n\n## Overview\n\n**Topic:** Sorting & Searching\n**Subtopic:** Rotated Array\n**Problems Available:** 49\n**Difficulty Range:** easy, medium, hard\n\n---\n\n## What You'll Learn\n\nSearch Rotated Array is fundamental to solving sorting & searching problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(log n)**\n\n### Space Complexity\nTypical space requirement: **O(1)**\n\n### Common Tags\n`sorting`, `searching`\n\n---\n\n## Starter Template\n\n```python\ndef solve(nums, target):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Rotated Array 1 [Easy]\n\nSorting/Searching: rotated-array.\n\n**Time:** O(O(log n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 2. Rotated Array 4 [Easy]\n\nSorting/Searching: rotated-array.\n\n**Time:** O(O(log n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 3. Rotated Array 5 [Easy]\n\nSorting/Searching: rotated-array.\n\n**Time:** O(O(log n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 4. Rotated Array 7 [Easy]\n\nSorting/Searching: rotated-array.\n\n**Time:** O(O(log n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 5. Rotated Array 14 [Easy]\n\nSorting/Searching: rotated-array.\n\n**Time:** O(O(log n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 36%\n- **Average Time:** 34 minutes per problem\n- **Total Points:** 1130 points available\n\n---\n\n## Next Steps\n\nAfter mastering Search Rotated Array:\n\n1. Complete all 49 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Search Rotated Array",
      "Rotated Array",
      "Sorting & Searching"
    ],
    "problem_count": 49
  },
  {
    "family_id": "sort-search-2d-matrix-search-061",
    "title": "Search 2d Matrix Search",
    "content": "# Search 2d Matrix Search\n\nMaster Search 2d Matrix Search - a key concept in Sorting & Searching.\n\n---\n\n## Overview\n\n**Topic:** Sorting & Searching\n**Subtopic:** 2d Matrix Search\n**Problems Available:** 49\n**Difficulty Range:** medium, hard, easy\n\n---\n\n## What You'll Learn\n\nSearch 2d Matrix Search is fundamental to solving sorting & searching problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(log n)**\n\n### Space Complexity\nTypical space requirement: **O(1)**\n\n### Common Tags\n`sorting`, `searching`\n\n---\n\n## Starter Template\n\n```python\ndef solve(nums, target):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. 2d Matrix Search 3 [Easy]\n\nSorting/Searching: 2d-matrix-search.\n\n**Time:** O(O(n log n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 2. 2d Matrix Search 6 [Easy]\n\nSorting/Searching: 2d-matrix-search.\n\n**Time:** O(O(log n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 3. 2d Matrix Search 13 [Easy]\n\nSorting/Searching: 2d-matrix-search.\n\n**Time:** O(O(log n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 4. 2d Matrix Search 16 [Easy]\n\nSorting/Searching: 2d-matrix-search.\n\n**Time:** O(O(log n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 5. 2d Matrix Search 20 [Easy]\n\nSorting/Searching: 2d-matrix-search.\n\n**Time:** O(O(log n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 42%\n- **Average Time:** 30 minutes per problem\n- **Total Points:** 1000 points available\n\n---\n\n## Next Steps\n\nAfter mastering Search 2d Matrix Search:\n\n1. Complete all 49 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Search 2d Matrix Search",
      "2d Matrix Search",
      "Sorting & Searching"
    ],
    "problem_count": 49
  },
  {
    "family_id": "sort-search-kth-element-062",
    "title": "Search Kth Element",
    "content": "# Search Kth Element\n\nMaster Search Kth Element - a key concept in Sorting & Searching.\n\n---\n\n## Overview\n\n**Topic:** Sorting & Searching\n**Subtopic:** Kth Element\n**Problems Available:** 49\n**Difficulty Range:** hard, medium, easy\n\n---\n\n## What You'll Learn\n\nSearch Kth Element is fundamental to solving sorting & searching problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(log n)**\n\n### Space Complexity\nTypical space requirement: **O(1)**\n\n### Common Tags\n`sorting`, `searching`\n\n---\n\n## Starter Template\n\n```python\ndef solve(nums, target):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Kth Element 19 [Easy]\n\nSorting/Searching: kth-element.\n\n**Time:** O(O(log n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 2. Kth Element 23 [Easy]\n\nSorting/Searching: kth-element.\n\n**Time:** O(O(log n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 3. Kth Element 28 [Easy]\n\nSorting/Searching: kth-element.\n\n**Time:** O(O(log n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 4. Kth Element 29 [Easy]\n\nSorting/Searching: kth-element.\n\n**Time:** O(O(n log n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 5. Kth Element 31 [Easy]\n\nSorting/Searching: kth-element.\n\n**Time:** O(O(n log n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 40%\n- **Average Time:** 31 minutes per problem\n- **Total Points:** 1040 points available\n\n---\n\n## Next Steps\n\nAfter mastering Search Kth Element:\n\n1. Complete all 49 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Search Kth Element",
      "Kth Element",
      "Sorting & Searching"
    ],
    "problem_count": 49
  },
  {
    "family_id": "sort-search-custom-sorting-063",
    "title": "Search Custom Sorting",
    "content": "# Search Custom Sorting\n\nMaster Search Custom Sorting - a key concept in Sorting & Searching.\n\n---\n\n## Overview\n\n**Topic:** Sorting & Searching\n**Subtopic:** Custom Sorting\n**Problems Available:** 49\n**Difficulty Range:** medium, hard, easy\n\n---\n\n## What You'll Learn\n\nSearch Custom Sorting is fundamental to solving sorting & searching problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(log n)**\n\n### Space Complexity\nTypical space requirement: **O(1)**\n\n### Common Tags\n`sorting`, `searching`\n\n---\n\n## Starter Template\n\n```python\ndef solve(nums, target):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Custom Sorting 6 [Easy]\n\nSorting/Searching: custom-sorting.\n\n**Time:** O(O(n log n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 2. Custom Sorting 7 [Easy]\n\nSorting/Searching: custom-sorting.\n\n**Time:** O(O(log n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 3. Custom Sorting 8 [Easy]\n\nSorting/Searching: custom-sorting.\n\n**Time:** O(O(log n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 4. Custom Sorting 13 [Easy]\n\nSorting/Searching: custom-sorting.\n\n**Time:** O(O(n log n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 5. Custom Sorting 14 [Easy]\n\nSorting/Searching: custom-sorting.\n\n**Time:** O(O(log n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 40%\n- **Average Time:** 31 minutes per problem\n- **Total Points:** 1030 points available\n\n---\n\n## Next Steps\n\nAfter mastering Search Custom Sorting:\n\n1. Complete all 49 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Search Custom Sorting",
      "Custom Sorting",
      "Sorting & Searching"
    ],
    "problem_count": 49
  },
  {
    "family_id": "dp-1d-dp-064",
    "title": "1D Dynamic Programming",
    "content": "# 1D Dynamic Programming\n\nDP problems with single-dimensional state space\n\n---\n\n## 1D Dynamic Programming\n\nProblems where optimal solution depends on solutions to subproblems with single parameter.\n\n**Approach:**\n1. Define state: dp[i] = optimal value for subproblem ending at i\n2. Find recurrence relation\n3. Identify base cases\n4. Determine computation order\n5. Return final answer\n\n**Common Problems:**\n- Fibonacci\n- Climbing stairs\n- House robber\n- Maximum subarray\n- Coin change\n\n\n---\n\n## Common Patterns\n\n### Pattern 1: Simple Recurrence\n```python\ndef climb_stairs(n):\n    if n <= 2:\n        return n\n\n    dp = [0] * (n + 1)\n    dp[1], dp[2] = 1, 2\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i-1] + dp[i-2]\n\n    return dp[n]\n```\n\n### Pattern 2: Choice at Each Step\n```python\ndef house_robber(nums):\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n\n    dp = [0] * len(nums)\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, len(nums)):\n        # Choose: rob current + skip previous, or skip current\n        dp[i] = max(nums[i] + dp[i-2], dp[i-1])\n\n    return dp[-1]\n```\n\n### Pattern 3: Space Optimization\n```python\ndef fib_optimized(n):\n    if n <= 1:\n        return n\n\n    prev2, prev1 = 0, 1\n\n    for i in range(2, n + 1):\n        curr = prev1 + prev2\n        prev2, prev1 = prev1, curr\n\n    return prev1\n```\n\n\n---\n\n## When to Use This Technique\n\nUse 1D DP when problem has optimal substructure with single parameter, overlapping subproblems, and each state depends on previous states.\n\n---\n\n## Common Pitfalls to Avoid\n\n- Not identifying base cases correctly\n- Wrong computation order\n- Not considering all transitions\n- Off-by-one errors in indexing\n\n---\n\n## Practice Problems\n\nStart with these problems to master this concept:\n\n### 1. Climbing Stairs [Easy]\n\nCount ways to climb n stairs (1 or 2 steps at a time).\n\n**Complexity:** Time O(O(n)), Space O(O(1))\n\n\n### 2. 1D DP Problem 3 [Easy]\n\nDP problem: 1d-dp.\n\n**Complexity:** Time O(O(n^2)), Space O(O(n))\n\n\n### 3. 1D DP Problem 5 [Easy]\n\nDP problem: 1d-dp.\n\n**Complexity:** Time O(O(n^2)), Space O(O(n))\n\n\n### 4. 1D DP Problem 20 [Easy]\n\nDP problem: 1d-dp.\n\n**Complexity:** Time O(O(n^2)), Space O(O(n))\n\n\n### 5. 1D DP Problem 23 [Easy]\n\nDP problem: 1d-dp.\n\n**Complexity:** Time O(O(n^2)), Space O(O(n))\n\n\n\n---\n\n## Key Takeaways\n\n- 1D Dynamic Programming is essential for dp problems with single-dimensional state space\n- Time complexity improvements can be significant with this technique\n- Practice problems in order of difficulty to build intuition\n- Focus on recognizing patterns in problem statements\n",
    "reading_time_minutes": 15,
    "key_concepts": [
      "1D Dynamic Programming",
      "Simple Recurrence"
    ],
    "problem_count": 50
  },
  {
    "family_id": "dp-2d-dp-065",
    "title": "2d Dp",
    "content": "# 2d Dp\n\nMaster 2d Dp - a key concept in Dynamic Programming.\n\n---\n\n## Overview\n\n**Topic:** Dynamic Programming\n**Subtopic:** 2d Dp\n**Problems Available:** 47\n**Difficulty Range:** medium, easy, hard, expert\n\n---\n\n## What You'll Learn\n\n2d Dp is fundamental to solving dynamic programming problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n^2)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`dp`\n\n---\n\n## Starter Template\n\n```python\ndef solve(data):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. 2D DP Problem 3 [Easy]\n\nDP problem: 2d-dp.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. 2D DP Problem 10 [Easy]\n\nDP problem: 2d-dp.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. 2D DP Problem 11 [Easy]\n\nDP problem: 2d-dp.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. 2D DP Problem 25 [Easy]\n\nDP problem: 2d-dp.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. 2D DP Problem 29 [Easy]\n\nDP problem: 2d-dp.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 35%\n- **Average Time:** 37 minutes per problem\n- **Total Points:** 1330 points available\n\n---\n\n## Next Steps\n\nAfter mastering 2d Dp:\n\n1. Complete all 47 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "2d Dp",
      "2d Dp",
      "Dynamic Programming"
    ],
    "problem_count": 47
  },
  {
    "family_id": "dp-knapsack-066",
    "title": "Knapsack",
    "content": "# Knapsack\n\nMaster Knapsack - a key concept in Dynamic Programming.\n\n---\n\n## Overview\n\n**Topic:** Dynamic Programming\n**Subtopic:** Knapsack\n**Problems Available:** 47\n**Difficulty Range:** hard, easy, expert, medium\n\n---\n\n## What You'll Learn\n\nKnapsack is fundamental to solving dynamic programming problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n^2)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`dp`\n\n---\n\n## Starter Template\n\n```python\ndef solve(data):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. KNAPSACK Problem 2 [Easy]\n\nDP problem: knapsack.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. KNAPSACK Problem 11 [Easy]\n\nDP problem: knapsack.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. KNAPSACK Problem 15 [Easy]\n\nDP problem: knapsack.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. KNAPSACK Problem 16 [Easy]\n\nDP problem: knapsack.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. KNAPSACK Problem 22 [Easy]\n\nDP problem: knapsack.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 37%\n- **Average Time:** 35 minutes per problem\n- **Total Points:** 1220 points available\n\n---\n\n## Next Steps\n\nAfter mastering Knapsack:\n\n1. Complete all 47 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Knapsack",
      "Knapsack",
      "Dynamic Programming"
    ],
    "problem_count": 47
  },
  {
    "family_id": "dp-lcs-067",
    "title": "Lcs",
    "content": "# Lcs\n\nMaster Lcs - a key concept in Dynamic Programming.\n\n---\n\n## Overview\n\n**Topic:** Dynamic Programming\n**Subtopic:** Longest Common Subsequence\n**Problems Available:** 48\n**Difficulty Range:** medium, hard, easy, expert\n\n---\n\n## What You'll Learn\n\nLcs is fundamental to solving dynamic programming problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(mn)**\n\n### Space Complexity\nTypical space requirement: **O(mn)**\n\n### Common Tags\n`dp`, `string`\n\n---\n\n## Starter Template\n\n```python\ndef longestCommonSubsequence(text1: str, text2: str) -> int:\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. LCS Problem 5 [Easy]\n\nDP problem: lcs.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. LCS Problem 6 [Easy]\n\nDP problem: lcs.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. LCS Problem 15 [Easy]\n\nDP problem: lcs.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. LCS Problem 17 [Easy]\n\nDP problem: lcs.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. LCS Problem 18 [Easy]\n\nDP problem: lcs.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 35%\n- **Average Time:** 37 minutes per problem\n- **Total Points:** 1330 points available\n\n---\n\n## Next Steps\n\nAfter mastering Lcs:\n\n1. Complete all 48 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Lcs",
      "Longest Common Subsequence",
      "Dynamic Programming"
    ],
    "problem_count": 48
  },
  {
    "family_id": "dp-lis-068",
    "title": "Lis",
    "content": "# Lis\n\nMaster Lis - a key concept in Dynamic Programming.\n\n---\n\n## Overview\n\n**Topic:** Dynamic Programming\n**Subtopic:** Lis\n**Problems Available:** 47\n**Difficulty Range:** easy, medium, hard, expert\n\n---\n\n## What You'll Learn\n\nLis is fundamental to solving dynamic programming problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n^2)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`dp`\n\n---\n\n## Starter Template\n\n```python\ndef solve(data):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. LIS Problem 1 [Easy]\n\nDP problem: lis.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. LIS Problem 3 [Easy]\n\nDP problem: lis.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. LIS Problem 5 [Easy]\n\nDP problem: lis.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. LIS Problem 8 [Easy]\n\nDP problem: lis.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. LIS Problem 10 [Easy]\n\nDP problem: lis.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 35%\n- **Average Time:** 37 minutes per problem\n- **Total Points:** 1300 points available\n\n---\n\n## Next Steps\n\nAfter mastering Lis:\n\n1. Complete all 47 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Lis",
      "Lis",
      "Dynamic Programming"
    ],
    "problem_count": 47
  },
  {
    "family_id": "dp-string-dp-069",
    "title": "String Dp",
    "content": "# String Dp\n\nMaster String Dp - a key concept in Dynamic Programming.\n\n---\n\n## Overview\n\n**Topic:** Dynamic Programming\n**Subtopic:** String Dp\n**Problems Available:** 47\n**Difficulty Range:** expert, easy, hard, medium\n\n---\n\n## What You'll Learn\n\nString Dp is fundamental to solving dynamic programming problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n^2)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`dp`\n\n---\n\n## Starter Template\n\n```python\ndef solve(data):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. STRING DP Problem 2 [Easy]\n\nDP problem: string-dp.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. STRING DP Problem 5 [Easy]\n\nDP problem: string-dp.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. STRING DP Problem 9 [Easy]\n\nDP problem: string-dp.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. STRING DP Problem 18 [Easy]\n\nDP problem: string-dp.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. STRING DP Problem 21 [Easy]\n\nDP problem: string-dp.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 31%\n- **Average Time:** 39 minutes per problem\n- **Total Points:** 1340 points available\n\n---\n\n## Next Steps\n\nAfter mastering String Dp:\n\n1. Complete all 47 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "String Dp",
      "String Dp",
      "Dynamic Programming"
    ],
    "problem_count": 47
  },
  {
    "family_id": "dp-tree-dp-070",
    "title": "Tree Dp",
    "content": "# Tree Dp\n\nMaster Tree Dp - a key concept in Dynamic Programming.\n\n---\n\n## Overview\n\n**Topic:** Dynamic Programming\n**Subtopic:** Tree Dp\n**Problems Available:** 47\n**Difficulty Range:** easy, expert, medium, hard\n\n---\n\n## What You'll Learn\n\nTree Dp is fundamental to solving dynamic programming problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n^2)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`dp`\n\n---\n\n## Starter Template\n\n```python\ndef solve(data):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. TREE DP Problem 1 [Easy]\n\nDP problem: tree-dp.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. TREE DP Problem 7 [Easy]\n\nDP problem: tree-dp.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. TREE DP Problem 9 [Easy]\n\nDP problem: tree-dp.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. TREE DP Problem 14 [Easy]\n\nDP problem: tree-dp.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. TREE DP Problem 16 [Easy]\n\nDP problem: tree-dp.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 34%\n- **Average Time:** 37 minutes per problem\n- **Total Points:** 1320 points available\n\n---\n\n## Next Steps\n\nAfter mastering Tree Dp:\n\n1. Complete all 47 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Tree Dp",
      "Tree Dp",
      "Dynamic Programming"
    ],
    "problem_count": 47
  },
  {
    "family_id": "dp-digit-dp-071",
    "title": "Digit Dp",
    "content": "# Digit Dp\n\nMaster Digit Dp - a key concept in Dynamic Programming.\n\n---\n\n## Overview\n\n**Topic:** Dynamic Programming\n**Subtopic:** Digit Dp\n**Problems Available:** 47\n**Difficulty Range:** hard, expert, easy, medium\n\n---\n\n## What You'll Learn\n\nDigit Dp is fundamental to solving dynamic programming problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n^2)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`dp`\n\n---\n\n## Starter Template\n\n```python\ndef solve(data):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. DIGIT DP Problem 5 [Easy]\n\nDP problem: digit-dp.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. DIGIT DP Problem 13 [Easy]\n\nDP problem: digit-dp.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. DIGIT DP Problem 19 [Easy]\n\nDP problem: digit-dp.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. DIGIT DP Problem 29 [Easy]\n\nDP problem: digit-dp.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. DIGIT DP Problem 42 [Easy]\n\nDP problem: digit-dp.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 28%\n- **Average Time:** 42 minutes per problem\n- **Total Points:** 1510 points available\n\n---\n\n## Next Steps\n\nAfter mastering Digit Dp:\n\n1. Complete all 47 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Digit Dp",
      "Digit Dp",
      "Dynamic Programming"
    ],
    "problem_count": 47
  },
  {
    "family_id": "dp-dp-on-graphs-072",
    "title": "Dp On Graphs",
    "content": "# Dp On Graphs\n\nMaster Dp On Graphs - a key concept in Dynamic Programming.\n\n---\n\n## Overview\n\n**Topic:** Dynamic Programming\n**Subtopic:** Dp On Graphs\n**Problems Available:** 47\n**Difficulty Range:** hard, expert, easy, medium\n\n---\n\n## What You'll Learn\n\nDp On Graphs is fundamental to solving dynamic programming problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n^2)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`dp`\n\n---\n\n## Starter Template\n\n```python\ndef solve(data):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. DP ON GRAPHS Problem 3 [Easy]\n\nDP problem: dp-on-graphs.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. DP ON GRAPHS Problem 4 [Easy]\n\nDP problem: dp-on-graphs.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. DP ON GRAPHS Problem 8 [Easy]\n\nDP problem: dp-on-graphs.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. DP ON GRAPHS Problem 10 [Easy]\n\nDP problem: dp-on-graphs.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. DP ON GRAPHS Problem 11 [Easy]\n\nDP problem: dp-on-graphs.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 43%\n- **Average Time:** 32 minutes per problem\n- **Total Points:** 1100 points available\n\n---\n\n## Next Steps\n\nAfter mastering Dp On Graphs:\n\n1. Complete all 47 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Dp On Graphs",
      "Dp On Graphs",
      "Dynamic Programming"
    ],
    "problem_count": 47
  },
  {
    "family_id": "dp-state-machine-dp-073",
    "title": "State Machine Dp",
    "content": "# State Machine Dp\n\nMaster State Machine Dp - a key concept in Dynamic Programming.\n\n---\n\n## Overview\n\n**Topic:** Dynamic Programming\n**Subtopic:** State Machine Dp\n**Problems Available:** 47\n**Difficulty Range:** easy, hard, medium, expert\n\n---\n\n## What You'll Learn\n\nState Machine Dp is fundamental to solving dynamic programming problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n^2)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`dp`\n\n---\n\n## Starter Template\n\n```python\ndef solve(data):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. STATE MACHINE DP Problem 1 [Easy]\n\nDP problem: state-machine-dp.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. STATE MACHINE DP Problem 3 [Easy]\n\nDP problem: state-machine-dp.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. STATE MACHINE DP Problem 4 [Easy]\n\nDP problem: state-machine-dp.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. STATE MACHINE DP Problem 8 [Easy]\n\nDP problem: state-machine-dp.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. STATE MACHINE DP Problem 10 [Easy]\n\nDP problem: state-machine-dp.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 36%\n- **Average Time:** 36 minutes per problem\n- **Total Points:** 1240 points available\n\n---\n\n## Next Steps\n\nAfter mastering State Machine Dp:\n\n1. Complete all 47 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "State Machine Dp",
      "State Machine Dp",
      "Dynamic Programming"
    ],
    "problem_count": 47
  },
  {
    "family_id": "dp-interval-dp-074",
    "title": "Interval Dp",
    "content": "# Interval Dp\n\nMaster Interval Dp - a key concept in Dynamic Programming.\n\n---\n\n## Overview\n\n**Topic:** Dynamic Programming\n**Subtopic:** Interval Dp\n**Problems Available:** 47\n**Difficulty Range:** hard, medium, expert, easy\n\n---\n\n## What You'll Learn\n\nInterval Dp is fundamental to solving dynamic programming problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n^2)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`dp`\n\n---\n\n## Starter Template\n\n```python\ndef solve(data):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. INTERVAL DP Problem 5 [Easy]\n\nDP problem: interval-dp.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. INTERVAL DP Problem 8 [Easy]\n\nDP problem: interval-dp.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. INTERVAL DP Problem 14 [Easy]\n\nDP problem: interval-dp.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. INTERVAL DP Problem 18 [Easy]\n\nDP problem: interval-dp.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. INTERVAL DP Problem 19 [Easy]\n\nDP problem: interval-dp.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 37%\n- **Average Time:** 36 minutes per problem\n- **Total Points:** 1260 points available\n\n---\n\n## Next Steps\n\nAfter mastering Interval Dp:\n\n1. Complete all 47 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Interval Dp",
      "Interval Dp",
      "Dynamic Programming"
    ],
    "problem_count": 47
  },
  {
    "family_id": "dp-bitmask-dp-075",
    "title": "Bitmask Dp",
    "content": "# Bitmask Dp\n\nMaster Bitmask Dp - a key concept in Dynamic Programming.\n\n---\n\n## Overview\n\n**Topic:** Dynamic Programming\n**Subtopic:** Bitmask Dp\n**Problems Available:** 47\n**Difficulty Range:** medium, hard, expert, easy\n\n---\n\n## What You'll Learn\n\nBitmask Dp is fundamental to solving dynamic programming problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n^2)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`dp`\n\n---\n\n## Starter Template\n\n```python\ndef solve(data):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. BITMASK DP Problem 9 [Easy]\n\nDP problem: bitmask-dp.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. BITMASK DP Problem 11 [Easy]\n\nDP problem: bitmask-dp.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. BITMASK DP Problem 14 [Easy]\n\nDP problem: bitmask-dp.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. BITMASK DP Problem 19 [Easy]\n\nDP problem: bitmask-dp.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. BITMASK DP Problem 20 [Easy]\n\nDP problem: bitmask-dp.\n\n**Time:** O(O(n^2)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 36%\n- **Average Time:** 37 minutes per problem\n- **Total Points:** 1270 points available\n\n---\n\n## Next Steps\n\nAfter mastering Bitmask Dp:\n\n1. Complete all 47 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Bitmask Dp",
      "Bitmask Dp",
      "Dynamic Programming"
    ],
    "problem_count": 47
  },
  {
    "family_id": "greedy-activity-selection-076",
    "title": "Activity Selection",
    "content": "# Activity Selection\n\nMaster Activity Selection - a key concept in Greedy Algorithms.\n\n---\n\n## Overview\n\n**Topic:** Greedy Algorithms\n**Subtopic:** Activity Selection\n**Problems Available:** 49\n**Difficulty Range:** medium, easy, hard\n\n---\n\n## What You'll Learn\n\nActivity Selection is fundamental to solving greedy algorithms problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(1)**\n\n### Common Tags\n`greedy`\n\n---\n\n## Starter Template\n\n```python\ndef solve(data):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Activity Selection 3 [Easy]\n\nGreedy problem: activity-selection.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 2. Activity Selection 4 [Easy]\n\nGreedy problem: activity-selection.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 3. Activity Selection 5 [Easy]\n\nGreedy problem: activity-selection.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 4. Activity Selection 12 [Easy]\n\nGreedy problem: activity-selection.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 5. Activity Selection 17 [Easy]\n\nGreedy problem: activity-selection.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 43%\n- **Average Time:** 30 minutes per problem\n- **Total Points:** 980 points available\n\n---\n\n## Next Steps\n\nAfter mastering Activity Selection:\n\n1. Complete all 49 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Activity Selection",
      "Activity Selection",
      "Greedy Algorithms"
    ],
    "problem_count": 49
  },
  {
    "family_id": "greedy-interval-problems-077",
    "title": "Interval Problems",
    "content": "# Interval Problems\n\nMaster Interval Problems - a key concept in Greedy Algorithms.\n\n---\n\n## Overview\n\n**Topic:** Greedy Algorithms\n**Subtopic:** Interval Problems\n**Problems Available:** 49\n**Difficulty Range:** medium, easy, hard\n\n---\n\n## What You'll Learn\n\nInterval Problems is fundamental to solving greedy algorithms problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(1)**\n\n### Common Tags\n`greedy`\n\n---\n\n## Starter Template\n\n```python\ndef solve(data):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Interval Problems 3 [Easy]\n\nGreedy problem: interval-problems.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 2. Interval Problems 4 [Easy]\n\nGreedy problem: interval-problems.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 3. Interval Problems 5 [Easy]\n\nGreedy problem: interval-problems.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 4. Interval Problems 10 [Easy]\n\nGreedy problem: interval-problems.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 5. Interval Problems 12 [Easy]\n\nGreedy problem: interval-problems.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 42%\n- **Average Time:** 30 minutes per problem\n- **Total Points:** 1000 points available\n\n---\n\n## Next Steps\n\nAfter mastering Interval Problems:\n\n1. Complete all 49 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Interval Problems",
      "Interval Problems",
      "Greedy Algorithms"
    ],
    "problem_count": 49
  },
  {
    "family_id": "greedy-greedy-arrays-078",
    "title": "Greedy Arrays",
    "content": "# Greedy Arrays\n\nMaster Greedy Arrays - a key concept in Greedy Algorithms.\n\n---\n\n## Overview\n\n**Topic:** Greedy Algorithms\n**Subtopic:** Greedy Arrays\n**Problems Available:** 49\n**Difficulty Range:** easy, hard, medium\n\n---\n\n## What You'll Learn\n\nGreedy Arrays is fundamental to solving greedy algorithms problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(1)**\n\n### Common Tags\n`greedy`\n\n---\n\n## Starter Template\n\n```python\ndef solve(data):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Greedy Arrays 1 [Easy]\n\nGreedy problem: greedy-arrays.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 2. Greedy Arrays 2 [Easy]\n\nGreedy problem: greedy-arrays.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 3. Greedy Arrays 3 [Easy]\n\nGreedy problem: greedy-arrays.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 4. Greedy Arrays 7 [Easy]\n\nGreedy problem: greedy-arrays.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 5. Greedy Arrays 8 [Easy]\n\nGreedy problem: greedy-arrays.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 47%\n- **Average Time:** 27 minutes per problem\n- **Total Points:** 910 points available\n\n---\n\n## Next Steps\n\nAfter mastering Greedy Arrays:\n\n1. Complete all 49 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Greedy Arrays",
      "Greedy Arrays",
      "Greedy Algorithms"
    ],
    "problem_count": 49
  },
  {
    "family_id": "greedy-jump-game-079",
    "title": "Jump Game",
    "content": "# Jump Game\n\nMaster Jump Game - a key concept in Greedy Algorithms.\n\n---\n\n## Overview\n\n**Topic:** Greedy Algorithms\n**Subtopic:** Jump Game\n**Problems Available:** 50\n**Difficulty Range:** medium, easy, hard\n\n---\n\n## What You'll Learn\n\nJump Game is fundamental to solving greedy algorithms problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(1)**\n\n### Common Tags\n`greedy`, `array`\n\n---\n\n## Starter Template\n\n```python\ndef canJump(nums: List[int]) -> bool:\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Jump Game 1 [Easy]\n\nGreedy problem: jump-game.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 2. Jump Game 2 [Easy]\n\nGreedy problem: jump-game.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 3. Jump Game 3 [Easy]\n\nGreedy problem: jump-game.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 4. Jump Game 4 [Easy]\n\nGreedy problem: jump-game.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 5. Jump Game 5 [Easy]\n\nGreedy problem: jump-game.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 41%\n- **Average Time:** 31 minutes per problem\n- **Total Points:** 1050 points available\n\n---\n\n## Next Steps\n\nAfter mastering Jump Game:\n\n1. Complete all 50 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Jump Game",
      "Jump Game",
      "Greedy Algorithms"
    ],
    "problem_count": 50
  },
  {
    "family_id": "greedy-stock-problems-080",
    "title": "Stock Problems",
    "content": "# Stock Problems\n\nMaster Stock Problems - a key concept in Greedy Algorithms.\n\n---\n\n## Overview\n\n**Topic:** Greedy Algorithms\n**Subtopic:** Stock Problems\n**Problems Available:** 49\n**Difficulty Range:** hard, easy, medium\n\n---\n\n## What You'll Learn\n\nStock Problems is fundamental to solving greedy algorithms problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(1)**\n\n### Common Tags\n`greedy`\n\n---\n\n## Starter Template\n\n```python\ndef solve(data):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Stock Problems 2 [Easy]\n\nGreedy problem: stock-problems.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 2. Stock Problems 3 [Easy]\n\nGreedy problem: stock-problems.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 3. Stock Problems 7 [Easy]\n\nGreedy problem: stock-problems.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 4. Stock Problems 9 [Easy]\n\nGreedy problem: stock-problems.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 5. Stock Problems 10 [Easy]\n\nGreedy problem: stock-problems.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 42%\n- **Average Time:** 30 minutes per problem\n- **Total Points:** 1010 points available\n\n---\n\n## Next Steps\n\nAfter mastering Stock Problems:\n\n1. Complete all 49 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Stock Problems",
      "Stock Problems",
      "Greedy Algorithms"
    ],
    "problem_count": 49
  },
  {
    "family_id": "backtrack-permutations-081",
    "title": "Permutations & Backtracking",
    "content": "# Permutations & Backtracking\n\nGenerating all permutations using backtracking technique\n\n---\n\n## Backtracking for Permutations\n\nBacktracking is a general algorithmic technique for finding all (or some) solutions by incrementally building candidates and abandoning candidates (\"backtracking\") when they fail to satisfy constraints.\n\n**Permutation:** Arrangement of elements in specific order\n- n elements have n! permutations\n- Order matters: [1,2,3] ≠ [3,2,1]\n\n**Backtracking Process:**\n1. Choose: Make a choice\n2. Explore: Recursively explore consequences\n3. Unchoose: Backtrack and try different choice\n\n**Complexity:**\n- Time: O(n! × n) - n! permutations, O(n) to copy each\n- Space: O(n) for recursion stack\n\n\n---\n\n## Common Patterns\n\n### Pattern 1: Basic Permutations\n```python\ndef permute(nums):\n    result = []\n\n    def backtrack(current, remaining):\n        # Base case: no elements remaining\n        if not remaining:\n            result.append(current[:])\n            return\n\n        for i in range(len(remaining)):\n            # Choose\n            current.append(remaining[i])\n\n            # Explore with remaining elements\n            new_remaining = remaining[:i] + remaining[i+1:]\n            backtrack(current, new_remaining)\n\n            # Unchoose (backtrack)\n            current.pop()\n\n    backtrack([], nums)\n    return result\n```\n\n### Pattern 2: Permutations with Swapping\n```python\ndef permute_swap(nums):\n    result = []\n\n    def backtrack(start):\n        if start == len(nums):\n            result.append(nums[:])\n            return\n\n        for i in range(start, len(nums)):\n            # Swap\n            nums[start], nums[i] = nums[i], nums[start]\n\n            # Recurse\n            backtrack(start + 1)\n\n            # Backtrack (swap back)\n            nums[start], nums[i] = nums[i], nums[start]\n\n    backtrack(0)\n    return result\n```\n\n### Pattern 3: Permutations with Duplicates\n```python\ndef permute_unique(nums):\n    result = []\n    nums.sort()  # Sort to group duplicates\n\n    def backtrack(current, used):\n        if len(current) == len(nums):\n            result.append(current[:])\n            return\n\n        for i in range(len(nums)):\n            # Skip if used or duplicate\n            if used[i]:\n                continue\n            if i > 0 and nums[i] == nums[i-1] and not used[i-1]:\n                continue\n\n            # Choose\n            current.append(nums[i])\n            used[i] = True\n\n            # Explore\n            backtrack(current, used)\n\n            # Unchoose\n            current.pop()\n            used[i] = False\n\n    backtrack([], [False] * len(nums))\n    return result\n```\n\n### Pattern 4: Next Permutation\n```python\ndef next_permutation(nums):\n    # Find first decreasing element from right\n    i = len(nums) - 2\n    while i >= 0 and nums[i] >= nums[i + 1]:\n        i -= 1\n\n    if i >= 0:  # Not last permutation\n        # Find element just larger than nums[i]\n        j = len(nums) - 1\n        while nums[j] <= nums[i]:\n            j -= 1\n        nums[i], nums[j] = nums[j], nums[i]\n\n    # Reverse suffix\n    nums[i + 1:] = reversed(nums[i + 1:])\n```\n\n\n---\n\n## When to Use This Technique\n\nUse backtracking for permutations when: need all arrangements, solving constraint satisfaction, generating sequences, or exploring all possibilities with pruning.\n\n---\n\n## Common Pitfalls to Avoid\n\n- Not making a copy when storing result (shallow copy issues)\n- Forgetting to backtrack (undo choices)\n- Not handling duplicates correctly\n- Stack overflow with large inputs\n- Not pruning unnecessary branches\n- Modifying input array without restoring\n\n---\n\n## Practice Problems\n\nStart with these problems to master this concept:\n\n### 1. Permutations 4 [Hard]\n\nBacktracking: permutations.\n\n**Complexity:** Time O(O(2^n)), Space O(O(n))\n\n\n### 2. Permutations 5 [Hard]\n\nBacktracking: permutations.\n\n**Complexity:** Time O(O(2^n)), Space O(O(n))\n\n\n### 3. Permutations 10 [Hard]\n\nBacktracking: permutations.\n\n**Complexity:** Time O(O(2^n)), Space O(O(n))\n\n\n### 4. Permutations 12 [Hard]\n\nBacktracking: permutations.\n\n**Complexity:** Time O(O(2^n)), Space O(O(n))\n\n\n### 5. Permutations 15 [Hard]\n\nBacktracking: permutations.\n\n**Complexity:** Time O(O(2^n)), Space O(O(n))\n\n\n\n---\n\n## Key Takeaways\n\n- Permutations & Backtracking is essential for generating all permutations using backtracking technique\n- Time complexity improvements can be significant with this technique\n- Practice problems in order of difficulty to build intuition\n- Focus on recognizing patterns in problem statements\n",
    "reading_time_minutes": 15,
    "key_concepts": [
      "Permutations & Backtracking",
      "Basic Permutations"
    ],
    "problem_count": 42
  },
  {
    "family_id": "backtrack-combinations-082",
    "title": "Combinations",
    "content": "# Combinations\n\nMaster Combinations - a key concept in Backtracking.\n\n---\n\n## Overview\n\n**Topic:** Backtracking\n**Subtopic:** Combinations\n**Problems Available:** 41\n**Difficulty Range:** medium, hard\n\n---\n\n## What You'll Learn\n\nCombinations is fundamental to solving backtracking problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(2^n)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`backtracking`\n\n---\n\n## Starter Template\n\n```python\ndef solve(data):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Combinations 3 [Hard]\n\nBacktracking: combinations.\n\n**Time:** O(O(2^n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. Combinations 5 [Hard]\n\nBacktracking: combinations.\n\n**Time:** O(O(2^n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. Combinations 7 [Hard]\n\nBacktracking: combinations.\n\n**Time:** O(O(2^n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. Combinations 8 [Hard]\n\nBacktracking: combinations.\n\n**Time:** O(O(2^n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. Combinations 10 [Hard]\n\nBacktracking: combinations.\n\n**Time:** O(O(2^n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 31%\n- **Average Time:** 36 minutes per problem\n- **Total Points:** 1000 points available\n\n---\n\n## Next Steps\n\nAfter mastering Combinations:\n\n1. Complete all 41 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Combinations",
      "Combinations",
      "Backtracking"
    ],
    "problem_count": 41
  },
  {
    "family_id": "backtrack-subsets-083",
    "title": "Subsets",
    "content": "# Subsets\n\nMaster Subsets - a key concept in Backtracking.\n\n---\n\n## Overview\n\n**Topic:** Backtracking\n**Subtopic:** Subsets\n**Problems Available:** 42\n**Difficulty Range:** medium, hard\n\n---\n\n## What You'll Learn\n\nSubsets is fundamental to solving backtracking problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(2^n)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`backtracking`, `bit-manipulation`\n\n---\n\n## Starter Template\n\n```python\ndef subsets(nums: List[int]) -> List[List[int]]:\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Subsets 3 [Hard]\n\nBacktracking: subsets.\n\n**Time:** O(O(2^n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. Subsets 4 [Hard]\n\nBacktracking: subsets.\n\n**Time:** O(O(2^n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. Subsets 6 [Hard]\n\nBacktracking: subsets.\n\n**Time:** O(O(2^n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. Subsets 7 [Hard]\n\nBacktracking: subsets.\n\n**Time:** O(O(2^n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. Subsets 10 [Hard]\n\nBacktracking: subsets.\n\n**Time:** O(O(2^n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 30%\n- **Average Time:** 37 minutes per problem\n- **Total Points:** 1050 points available\n\n---\n\n## Next Steps\n\nAfter mastering Subsets:\n\n1. Complete all 42 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Subsets",
      "Subsets",
      "Backtracking"
    ],
    "problem_count": 42
  },
  {
    "family_id": "backtrack-n-queens-084",
    "title": "N Queens",
    "content": "# N Queens\n\nMaster N Queens - a key concept in Backtracking.\n\n---\n\n## Overview\n\n**Topic:** Backtracking\n**Subtopic:** N Queens\n**Problems Available:** 41\n**Difficulty Range:** hard, medium\n\n---\n\n## What You'll Learn\n\nN Queens is fundamental to solving backtracking problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(2^n)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`backtracking`\n\n---\n\n## Starter Template\n\n```python\ndef solve(data):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. N Queens 1 [Hard]\n\nBacktracking: n-queens.\n\n**Time:** O(O(2^n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. N Queens 5 [Hard]\n\nBacktracking: n-queens.\n\n**Time:** O(O(2^n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. N Queens 6 [Hard]\n\nBacktracking: n-queens.\n\n**Time:** O(O(2^n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. N Queens 8 [Hard]\n\nBacktracking: n-queens.\n\n**Time:** O(O(2^n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. N Queens 9 [Hard]\n\nBacktracking: n-queens.\n\n**Time:** O(O(2^n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 29%\n- **Average Time:** 38 minutes per problem\n- **Total Points:** 1040 points available\n\n---\n\n## Next Steps\n\nAfter mastering N Queens:\n\n1. Complete all 41 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "N Queens",
      "N Queens",
      "Backtracking"
    ],
    "problem_count": 41
  },
  {
    "family_id": "backtrack-sudoku-085",
    "title": "Sudoku",
    "content": "# Sudoku\n\nMaster Sudoku - a key concept in Backtracking.\n\n---\n\n## Overview\n\n**Topic:** Backtracking\n**Subtopic:** Sudoku\n**Problems Available:** 41\n**Difficulty Range:** hard, medium\n\n---\n\n## What You'll Learn\n\nSudoku is fundamental to solving backtracking problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(2^n)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`backtracking`\n\n---\n\n## Starter Template\n\n```python\ndef solve(data):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Sudoku 1 [Hard]\n\nBacktracking: sudoku.\n\n**Time:** O(O(2^n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. Sudoku 2 [Hard]\n\nBacktracking: sudoku.\n\n**Time:** O(O(2^n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. Sudoku 3 [Hard]\n\nBacktracking: sudoku.\n\n**Time:** O(O(2^n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. Sudoku 6 [Hard]\n\nBacktracking: sudoku.\n\n**Time:** O(O(2^n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. Sudoku 7 [Hard]\n\nBacktracking: sudoku.\n\n**Time:** O(O(2^n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 29%\n- **Average Time:** 38 minutes per problem\n- **Total Points:** 1050 points available\n\n---\n\n## Next Steps\n\nAfter mastering Sudoku:\n\n1. Complete all 41 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Sudoku",
      "Sudoku",
      "Backtracking"
    ],
    "problem_count": 41
  },
  {
    "family_id": "backtrack-word-search-086",
    "title": "Word Search",
    "content": "# Word Search\n\nMaster Word Search - a key concept in Backtracking.\n\n---\n\n## Overview\n\n**Topic:** Backtracking\n**Subtopic:** Word Search\n**Problems Available:** 41\n**Difficulty Range:** medium, hard\n\n---\n\n## What You'll Learn\n\nWord Search is fundamental to solving backtracking problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(2^n)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`backtracking`\n\n---\n\n## Starter Template\n\n```python\ndef solve(data):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Word Search 2 [Hard]\n\nBacktracking: word-search.\n\n**Time:** O(O(2^n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. Word Search 3 [Hard]\n\nBacktracking: word-search.\n\n**Time:** O(O(2^n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. Word Search 5 [Hard]\n\nBacktracking: word-search.\n\n**Time:** O(O(2^n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. Word Search 6 [Hard]\n\nBacktracking: word-search.\n\n**Time:** O(O(2^n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. Word Search 9 [Hard]\n\nBacktracking: word-search.\n\n**Time:** O(O(2^n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 30%\n- **Average Time:** 37 minutes per problem\n- **Total Points:** 1030 points available\n\n---\n\n## Next Steps\n\nAfter mastering Word Search:\n\n1. Complete all 41 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Word Search",
      "Word Search",
      "Backtracking"
    ],
    "problem_count": 41
  },
  {
    "family_id": "backtrack-path-finding-087",
    "title": "Path Finding",
    "content": "# Path Finding\n\nMaster Path Finding - a key concept in Backtracking.\n\n---\n\n## Overview\n\n**Topic:** Backtracking\n**Subtopic:** Path Finding\n**Problems Available:** 41\n**Difficulty Range:** hard, medium\n\n---\n\n## What You'll Learn\n\nPath Finding is fundamental to solving backtracking problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(2^n)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`backtracking`\n\n---\n\n## Starter Template\n\n```python\ndef solve(data):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Path Finding 1 [Hard]\n\nBacktracking: path-finding.\n\n**Time:** O(O(2^n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. Path Finding 2 [Hard]\n\nBacktracking: path-finding.\n\n**Time:** O(O(2^n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. Path Finding 3 [Hard]\n\nBacktracking: path-finding.\n\n**Time:** O(O(2^n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. Path Finding 4 [Hard]\n\nBacktracking: path-finding.\n\n**Time:** O(O(2^n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. Path Finding 5 [Hard]\n\nBacktracking: path-finding.\n\n**Time:** O(O(2^n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 29%\n- **Average Time:** 38 minutes per problem\n- **Total Points:** 1040 points available\n\n---\n\n## Next Steps\n\nAfter mastering Path Finding:\n\n1. Complete all 41 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Path Finding",
      "Path Finding",
      "Backtracking"
    ],
    "problem_count": 41
  },
  {
    "family_id": "recursion-basic-recursion-088",
    "title": "Basic Recursion",
    "content": "# Basic Recursion\n\nMaster Basic Recursion - a key concept in Recursion.\n\n---\n\n## Overview\n\n**Topic:** Recursion\n**Subtopic:** Basic Recursion\n**Problems Available:** 50\n**Difficulty Range:** easy, medium, hard\n\n---\n\n## What You'll Learn\n\nBasic Recursion is fundamental to solving recursion problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`recursion`\n\n---\n\n## Starter Template\n\n```python\ndef solve(n):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Basic Recursion 1 [Easy]\n\nRecursion: basic-recursion.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. Basic Recursion 4 [Easy]\n\nRecursion: basic-recursion.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. Basic Recursion 7 [Easy]\n\nRecursion: basic-recursion.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. Basic Recursion 9 [Easy]\n\nRecursion: basic-recursion.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. Basic Recursion 10 [Easy]\n\nRecursion: basic-recursion.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 42%\n- **Average Time:** 31 minutes per problem\n- **Total Points:** 1050 points available\n\n---\n\n## Next Steps\n\nAfter mastering Basic Recursion:\n\n1. Complete all 50 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Basic Recursion",
      "Basic Recursion",
      "Recursion"
    ],
    "problem_count": 50
  },
  {
    "family_id": "recursion-tail-recursion-089",
    "title": "Tail Recursion",
    "content": "# Tail Recursion\n\nMaster Tail Recursion - a key concept in Recursion.\n\n---\n\n## Overview\n\n**Topic:** Recursion\n**Subtopic:** Tail Recursion\n**Problems Available:** 50\n**Difficulty Range:** hard, medium, easy\n\n---\n\n## What You'll Learn\n\nTail Recursion is fundamental to solving recursion problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`recursion`\n\n---\n\n## Starter Template\n\n```python\ndef solve(n):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Tail Recursion 4 [Easy]\n\nRecursion: tail-recursion.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. Tail Recursion 5 [Easy]\n\nRecursion: tail-recursion.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. Tail Recursion 8 [Easy]\n\nRecursion: tail-recursion.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. Tail Recursion 12 [Easy]\n\nRecursion: tail-recursion.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. Tail Recursion 20 [Easy]\n\nRecursion: tail-recursion.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 45%\n- **Average Time:** 29 minutes per problem\n- **Total Points:** 970 points available\n\n---\n\n## Next Steps\n\nAfter mastering Tail Recursion:\n\n1. Complete all 50 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Tail Recursion",
      "Tail Recursion",
      "Recursion"
    ],
    "problem_count": 50
  },
  {
    "family_id": "recursion-tree-recursion-090",
    "title": "Tree Recursion",
    "content": "# Tree Recursion\n\nMaster Tree Recursion - a key concept in Recursion.\n\n---\n\n## Overview\n\n**Topic:** Recursion\n**Subtopic:** Tree Recursion\n**Problems Available:** 50\n**Difficulty Range:** hard, easy, medium\n\n---\n\n## What You'll Learn\n\nTree Recursion is fundamental to solving recursion problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`recursion`\n\n---\n\n## Starter Template\n\n```python\ndef solve(n):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Tree Recursion 2 [Easy]\n\nRecursion: tree-recursion.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. Tree Recursion 3 [Easy]\n\nRecursion: tree-recursion.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. Tree Recursion 11 [Easy]\n\nRecursion: tree-recursion.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. Tree Recursion 12 [Easy]\n\nRecursion: tree-recursion.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. Tree Recursion 16 [Easy]\n\nRecursion: tree-recursion.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 43%\n- **Average Time:** 30 minutes per problem\n- **Total Points:** 1010 points available\n\n---\n\n## Next Steps\n\nAfter mastering Tree Recursion:\n\n1. Complete all 50 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Tree Recursion",
      "Tree Recursion",
      "Recursion"
    ],
    "problem_count": 50
  },
  {
    "family_id": "recursion-divide-conquer-091",
    "title": "Divide Conquer",
    "content": "# Divide Conquer\n\nMaster Divide Conquer - a key concept in Recursion.\n\n---\n\n## Overview\n\n**Topic:** Recursion\n**Subtopic:** Divide Conquer\n**Problems Available:** 50\n**Difficulty Range:** easy, hard, medium\n\n---\n\n## What You'll Learn\n\nDivide Conquer is fundamental to solving recursion problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`recursion`\n\n---\n\n## Starter Template\n\n```python\ndef solve(n):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Divide Conquer 1 [Easy]\n\nRecursion: divide-conquer.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. Divide Conquer 12 [Easy]\n\nRecursion: divide-conquer.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. Divide Conquer 14 [Easy]\n\nRecursion: divide-conquer.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. Divide Conquer 17 [Easy]\n\nRecursion: divide-conquer.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. Divide Conquer 18 [Easy]\n\nRecursion: divide-conquer.\n\n**Time:** O(O(n)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 43%\n- **Average Time:** 30 minutes per problem\n- **Total Points:** 1010 points available\n\n---\n\n## Next Steps\n\nAfter mastering Divide Conquer:\n\n1. Complete all 50 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Divide Conquer",
      "Divide Conquer",
      "Recursion"
    ],
    "problem_count": 50
  },
  {
    "family_id": "bit-bitwise-ops-092",
    "title": "Bitwise Ops",
    "content": "# Bitwise Ops\n\nMaster Bitwise Ops - a key concept in Bit Manipulation.\n\n---\n\n## Overview\n\n**Topic:** Bit Manipulation\n**Subtopic:** Bitwise Ops\n**Problems Available:** 39\n**Difficulty Range:** easy, hard, medium\n\n---\n\n## What You'll Learn\n\nBitwise Ops is fundamental to solving bit manipulation problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(1)**\n\n### Space Complexity\nTypical space requirement: **O(1)**\n\n### Common Tags\n`bit-manipulation`\n\n---\n\n## Starter Template\n\n```python\ndef solve(n):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Bitwise Ops 1 [Easy]\n\nBit manipulation: bitwise-ops.\n\n**Time:** O(O(1)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 2. Bitwise Ops 3 [Easy]\n\nBit manipulation: bitwise-ops.\n\n**Time:** O(O(1)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 3. Bitwise Ops 10 [Easy]\n\nBit manipulation: bitwise-ops.\n\n**Time:** O(O(1)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 4. Bitwise Ops 12 [Easy]\n\nBit manipulation: bitwise-ops.\n\n**Time:** O(O(1)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 5. Bitwise Ops 15 [Easy]\n\nBit manipulation: bitwise-ops.\n\n**Time:** O(O(1)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 41%\n- **Average Time:** 31 minutes per problem\n- **Total Points:** 820 points available\n\n---\n\n## Next Steps\n\nAfter mastering Bitwise Ops:\n\n1. Complete all 39 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Bitwise Ops",
      "Bitwise Ops",
      "Bit Manipulation"
    ],
    "problem_count": 39
  },
  {
    "family_id": "bit-bit-tricks-093",
    "title": "Bit Tricks",
    "content": "# Bit Tricks\n\nMaster Bit Tricks - a key concept in Bit Manipulation.\n\n---\n\n## Overview\n\n**Topic:** Bit Manipulation\n**Subtopic:** Bit Tricks\n**Problems Available:** 39\n**Difficulty Range:** medium, easy, hard\n\n---\n\n## What You'll Learn\n\nBit Tricks is fundamental to solving bit manipulation problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(1)**\n\n### Space Complexity\nTypical space requirement: **O(1)**\n\n### Common Tags\n`bit-manipulation`\n\n---\n\n## Starter Template\n\n```python\ndef solve(n):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Bit Tricks 4 [Easy]\n\nBit manipulation: bit-tricks.\n\n**Time:** O(O(1)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 2. Bit Tricks 6 [Easy]\n\nBit manipulation: bit-tricks.\n\n**Time:** O(O(1)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 3. Bit Tricks 11 [Easy]\n\nBit manipulation: bit-tricks.\n\n**Time:** O(O(1)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 4. Bit Tricks 13 [Easy]\n\nBit manipulation: bit-tricks.\n\n**Time:** O(O(1)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 5. Bit Tricks 14 [Easy]\n\nBit manipulation: bit-tricks.\n\n**Time:** O(O(1)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 44%\n- **Average Time:** 29 minutes per problem\n- **Total Points:** 770 points available\n\n---\n\n## Next Steps\n\nAfter mastering Bit Tricks:\n\n1. Complete all 39 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Bit Tricks",
      "Bit Tricks",
      "Bit Manipulation"
    ],
    "problem_count": 39
  },
  {
    "family_id": "bit-power-of-two-094",
    "title": "Power Of Two",
    "content": "# Power Of Two\n\nMaster Power Of Two - a key concept in Bit Manipulation.\n\n---\n\n## Overview\n\n**Topic:** Bit Manipulation\n**Subtopic:** Power Of Two\n**Problems Available:** 39\n**Difficulty Range:** medium, hard, easy\n\n---\n\n## What You'll Learn\n\nPower Of Two is fundamental to solving bit manipulation problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(1)**\n\n### Space Complexity\nTypical space requirement: **O(1)**\n\n### Common Tags\n`bit-manipulation`\n\n---\n\n## Starter Template\n\n```python\ndef solve(n):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Power Of Two 4 [Easy]\n\nBit manipulation: power-of-two.\n\n**Time:** O(O(1)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 2. Power Of Two 6 [Easy]\n\nBit manipulation: power-of-two.\n\n**Time:** O(O(1)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 3. Power Of Two 8 [Easy]\n\nBit manipulation: power-of-two.\n\n**Time:** O(O(1)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 4. Power Of Two 14 [Easy]\n\nBit manipulation: power-of-two.\n\n**Time:** O(O(1)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 5. Power Of Two 23 [Easy]\n\nBit manipulation: power-of-two.\n\n**Time:** O(O(1)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 40%\n- **Average Time:** 31 minutes per problem\n- **Total Points:** 830 points available\n\n---\n\n## Next Steps\n\nAfter mastering Power Of Two:\n\n1. Complete all 39 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Power Of Two",
      "Power Of Two",
      "Bit Manipulation"
    ],
    "problem_count": 39
  },
  {
    "family_id": "bit-counting-bits-095",
    "title": "Counting Bits",
    "content": "# Counting Bits\n\nMaster Counting Bits - a key concept in Bit Manipulation.\n\n---\n\n## Overview\n\n**Topic:** Bit Manipulation\n**Subtopic:** Counting Bits\n**Problems Available:** 39\n**Difficulty Range:** medium, easy, hard\n\n---\n\n## What You'll Learn\n\nCounting Bits is fundamental to solving bit manipulation problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(1)**\n\n### Space Complexity\nTypical space requirement: **O(1)**\n\n### Common Tags\n`bit-manipulation`\n\n---\n\n## Starter Template\n\n```python\ndef solve(n):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Counting Bits 3 [Easy]\n\nBit manipulation: counting-bits.\n\n**Time:** O(O(1)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 2. Counting Bits 4 [Easy]\n\nBit manipulation: counting-bits.\n\n**Time:** O(O(1)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 3. Counting Bits 7 [Easy]\n\nBit manipulation: counting-bits.\n\n**Time:** O(O(1)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 4. Counting Bits 8 [Easy]\n\nBit manipulation: counting-bits.\n\n**Time:** O(O(1)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 5. Counting Bits 10 [Easy]\n\nBit manipulation: counting-bits.\n\n**Time:** O(O(1)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 45%\n- **Average Time:** 28 minutes per problem\n- **Total Points:** 740 points available\n\n---\n\n## Next Steps\n\nAfter mastering Counting Bits:\n\n1. Complete all 39 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Counting Bits",
      "Counting Bits",
      "Bit Manipulation"
    ],
    "problem_count": 39
  },
  {
    "family_id": "bit-xor-problems-096",
    "title": "Xor Problems",
    "content": "# Xor Problems\n\nMaster Xor Problems - a key concept in Bit Manipulation.\n\n---\n\n## Overview\n\n**Topic:** Bit Manipulation\n**Subtopic:** XOR Problems\n**Problems Available:** 40\n**Difficulty Range:** easy, medium, hard\n\n---\n\n## What You'll Learn\n\nXor Problems is fundamental to solving bit manipulation problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(1)**\n\n### Common Tags\n`bit-manipulation`, `xor`\n\n---\n\n## Starter Template\n\n```python\ndef singleNumber(nums: List[int]) -> int:\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Single Number [Easy]\n\nFind element that appears once (others appear twice).\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Amazon, Apple, Google\n\n\n### 2. Xor Problems 2 [Easy]\n\nBit manipulation: xor-problems.\n\n**Time:** O(O(1)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 3. Xor Problems 3 [Easy]\n\nBit manipulation: xor-problems.\n\n**Time:** O(O(1)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 4. Xor Problems 6 [Easy]\n\nBit manipulation: xor-problems.\n\n**Time:** O(O(1)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 5. Xor Problems 13 [Easy]\n\nBit manipulation: xor-problems.\n\n**Time:** O(O(1)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 40%\n- **Average Time:** 31 minutes per problem\n- **Total Points:** 850 points available\n\n---\n\n## Next Steps\n\nAfter mastering Xor Problems:\n\n1. Complete all 40 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Xor Problems",
      "XOR Problems",
      "Bit Manipulation"
    ],
    "problem_count": 40
  },
  {
    "family_id": "math-primes-097",
    "title": "Primes",
    "content": "# Primes\n\nMaster Primes - a key concept in Math & Number Theory.\n\n---\n\n## Overview\n\n**Topic:** Math & Number Theory\n**Subtopic:** Primes\n**Problems Available:** 50\n**Difficulty Range:** medium, easy, hard\n\n---\n\n## What You'll Learn\n\nPrimes is fundamental to solving math & number theory problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(1)**\n\n### Common Tags\n`math`\n\n---\n\n## Starter Template\n\n```python\ndef solve(n):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Primes 4 [Easy]\n\nMath problem: primes.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 2. Primes 7 [Easy]\n\nMath problem: primes.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 3. Primes 8 [Easy]\n\nMath problem: primes.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 4. Primes 10 [Easy]\n\nMath problem: primes.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 5. Primes 14 [Easy]\n\nMath problem: primes.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 44%\n- **Average Time:** 29 minutes per problem\n- **Total Points:** 990 points available\n\n---\n\n## Next Steps\n\nAfter mastering Primes:\n\n1. Complete all 50 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Primes",
      "Primes",
      "Math & Number Theory"
    ],
    "problem_count": 50
  },
  {
    "family_id": "math-gcd-lcm-098",
    "title": "Gcd Lcm",
    "content": "# Gcd Lcm\n\nMaster Gcd Lcm - a key concept in Math & Number Theory.\n\n---\n\n## Overview\n\n**Topic:** Math & Number Theory\n**Subtopic:** Gcd Lcm\n**Problems Available:** 50\n**Difficulty Range:** hard, easy, medium\n\n---\n\n## What You'll Learn\n\nGcd Lcm is fundamental to solving math & number theory problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(1)**\n\n### Common Tags\n`math`\n\n---\n\n## Starter Template\n\n```python\ndef solve(n):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Gcd Lcm 2 [Easy]\n\nMath problem: gcd-lcm.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 2. Gcd Lcm 3 [Easy]\n\nMath problem: gcd-lcm.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 3. Gcd Lcm 7 [Easy]\n\nMath problem: gcd-lcm.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 4. Gcd Lcm 10 [Easy]\n\nMath problem: gcd-lcm.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 5. Gcd Lcm 13 [Easy]\n\nMath problem: gcd-lcm.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 43%\n- **Average Time:** 30 minutes per problem\n- **Total Points:** 1020 points available\n\n---\n\n## Next Steps\n\nAfter mastering Gcd Lcm:\n\n1. Complete all 50 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Gcd Lcm",
      "Gcd Lcm",
      "Math & Number Theory"
    ],
    "problem_count": 50
  },
  {
    "family_id": "math-modular-arithmetic-099",
    "title": "Modular Arithmetic",
    "content": "# Modular Arithmetic\n\nMaster Modular Arithmetic - a key concept in Math & Number Theory.\n\n---\n\n## Overview\n\n**Topic:** Math & Number Theory\n**Subtopic:** Modular Arithmetic\n**Problems Available:** 50\n**Difficulty Range:** medium, easy, hard\n\n---\n\n## What You'll Learn\n\nModular Arithmetic is fundamental to solving math & number theory problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(1)**\n\n### Common Tags\n`math`\n\n---\n\n## Starter Template\n\n```python\ndef solve(n):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Modular Arithmetic 3 [Easy]\n\nMath problem: modular-arithmetic.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 2. Modular Arithmetic 5 [Easy]\n\nMath problem: modular-arithmetic.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 3. Modular Arithmetic 8 [Easy]\n\nMath problem: modular-arithmetic.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 4. Modular Arithmetic 12 [Easy]\n\nMath problem: modular-arithmetic.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 5. Modular Arithmetic 14 [Easy]\n\nMath problem: modular-arithmetic.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 45%\n- **Average Time:** 28 minutes per problem\n- **Total Points:** 960 points available\n\n---\n\n## Next Steps\n\nAfter mastering Modular Arithmetic:\n\n1. Complete all 50 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Modular Arithmetic",
      "Modular Arithmetic",
      "Math & Number Theory"
    ],
    "problem_count": 50
  },
  {
    "family_id": "math-combinatorics-100",
    "title": "Combinatorics",
    "content": "# Combinatorics\n\nMaster Combinatorics - a key concept in Math & Number Theory.\n\n---\n\n## Overview\n\n**Topic:** Math & Number Theory\n**Subtopic:** Combinatorics\n**Problems Available:** 50\n**Difficulty Range:** easy, hard, medium\n\n---\n\n## What You'll Learn\n\nCombinatorics is fundamental to solving math & number theory problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(1)**\n\n### Common Tags\n`math`\n\n---\n\n## Starter Template\n\n```python\ndef solve(n):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Combinatorics 1 [Easy]\n\nMath problem: combinatorics.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 2. Combinatorics 2 [Easy]\n\nMath problem: combinatorics.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 3. Combinatorics 9 [Easy]\n\nMath problem: combinatorics.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 4. Combinatorics 10 [Easy]\n\nMath problem: combinatorics.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 5. Combinatorics 11 [Easy]\n\nMath problem: combinatorics.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 47%\n- **Average Time:** 27 minutes per problem\n- **Total Points:** 930 points available\n\n---\n\n## Next Steps\n\nAfter mastering Combinatorics:\n\n1. Complete all 50 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Combinatorics",
      "Combinatorics",
      "Math & Number Theory"
    ],
    "problem_count": 50
  },
  {
    "family_id": "math-geometry-101",
    "title": "Geometry",
    "content": "# Geometry\n\nMaster Geometry - a key concept in Math & Number Theory.\n\n---\n\n## Overview\n\n**Topic:** Math & Number Theory\n**Subtopic:** Geometry\n**Problems Available:** 50\n**Difficulty Range:** easy, medium, hard\n\n---\n\n## What You'll Learn\n\nGeometry is fundamental to solving math & number theory problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(1)**\n\n### Common Tags\n`math`\n\n---\n\n## Starter Template\n\n```python\ndef solve(n):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Geometry 1 [Easy]\n\nMath problem: geometry.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 2. Geometry 7 [Easy]\n\nMath problem: geometry.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 3. Geometry 9 [Easy]\n\nMath problem: geometry.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 4. Geometry 10 [Easy]\n\nMath problem: geometry.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 5. Geometry 11 [Easy]\n\nMath problem: geometry.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 47%\n- **Average Time:** 27 minutes per problem\n- **Total Points:** 930 points available\n\n---\n\n## Next Steps\n\nAfter mastering Geometry:\n\n1. Complete all 50 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Geometry",
      "Geometry",
      "Math & Number Theory"
    ],
    "problem_count": 50
  },
  {
    "family_id": "math-number-theory-102",
    "title": "Number Theory",
    "content": "# Number Theory\n\nMaster Number Theory - a key concept in Math & Number Theory.\n\n---\n\n## Overview\n\n**Topic:** Math & Number Theory\n**Subtopic:** Number Theory\n**Problems Available:** 50\n**Difficulty Range:** hard, medium, easy\n\n---\n\n## What You'll Learn\n\nNumber Theory is fundamental to solving math & number theory problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(n)**\n\n### Space Complexity\nTypical space requirement: **O(1)**\n\n### Common Tags\n`math`\n\n---\n\n## Starter Template\n\n```python\ndef solve(n):\n    pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Number Theory 5 [Easy]\n\nMath problem: number-theory.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 2. Number Theory 6 [Easy]\n\nMath problem: number-theory.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 3. Number Theory 9 [Easy]\n\nMath problem: number-theory.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 4. Number Theory 12 [Easy]\n\nMath problem: number-theory.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n### 5. Number Theory 15 [Easy]\n\nMath problem: number-theory.\n\n**Time:** O(O(n)), **Space:** O(O(1))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 45%\n- **Average Time:** 29 minutes per problem\n- **Total Points:** 970 points available\n\n---\n\n## Next Steps\n\nAfter mastering Number Theory:\n\n1. Complete all 50 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Number Theory",
      "Number Theory",
      "Math & Number Theory"
    ],
    "problem_count": 50
  },
  {
    "family_id": "design-data-structure-design-103",
    "title": "Data Structure Design",
    "content": "# Data Structure Design\n\nMaster Data Structure Design - a key concept in System & Object Design.\n\n---\n\n## Overview\n\n**Topic:** System & Object Design\n**Subtopic:** Data Structure Design\n**Problems Available:** 49\n**Difficulty Range:** hard, medium\n\n---\n\n## What You'll Learn\n\nData Structure Design is fundamental to solving system & object design problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(1)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`design`\n\n---\n\n## Starter Template\n\n```python\nclass Solution:\n    def __init__(self):\n        pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Data Structure Design 1 [Hard]\n\nDesign problem: data-structure-design.\n\n**Time:** O(O(1)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. Data Structure Design 2 [Hard]\n\nDesign problem: data-structure-design.\n\n**Time:** O(O(1)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. Data Structure Design 3 [Hard]\n\nDesign problem: data-structure-design.\n\n**Time:** O(O(1)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. Data Structure Design 4 [Hard]\n\nDesign problem: data-structure-design.\n\n**Time:** O(O(1)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. Data Structure Design 8 [Hard]\n\nDesign problem: data-structure-design.\n\n**Time:** O(O(1)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 30%\n- **Average Time:** 37 minutes per problem\n- **Total Points:** 1230 points available\n\n---\n\n## Next Steps\n\nAfter mastering Data Structure Design:\n\n1. Complete all 49 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Data Structure Design",
      "Data Structure Design",
      "System & Object Design"
    ],
    "problem_count": 49
  },
  {
    "family_id": "design-iterator-design-104",
    "title": "Iterator Design",
    "content": "# Iterator Design\n\nMaster Iterator Design - a key concept in System & Object Design.\n\n---\n\n## Overview\n\n**Topic:** System & Object Design\n**Subtopic:** Iterator Design\n**Problems Available:** 49\n**Difficulty Range:** hard, medium\n\n---\n\n## What You'll Learn\n\nIterator Design is fundamental to solving system & object design problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(1)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`design`\n\n---\n\n## Starter Template\n\n```python\nclass Solution:\n    def __init__(self):\n        pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Iterator Design 1 [Hard]\n\nDesign problem: iterator-design.\n\n**Time:** O(O(1)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. Iterator Design 2 [Hard]\n\nDesign problem: iterator-design.\n\n**Time:** O(O(1)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. Iterator Design 3 [Hard]\n\nDesign problem: iterator-design.\n\n**Time:** O(O(1)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. Iterator Design 5 [Hard]\n\nDesign problem: iterator-design.\n\n**Time:** O(O(1)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. Iterator Design 6 [Hard]\n\nDesign problem: iterator-design.\n\n**Time:** O(O(1)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 29%\n- **Average Time:** 38 minutes per problem\n- **Total Points:** 1250 points available\n\n---\n\n## Next Steps\n\nAfter mastering Iterator Design:\n\n1. Complete all 49 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Iterator Design",
      "Iterator Design",
      "System & Object Design"
    ],
    "problem_count": 49
  },
  {
    "family_id": "design-cache-design-105",
    "title": "Cache Design",
    "content": "# Cache Design\n\nMaster Cache Design - a key concept in System & Object Design.\n\n---\n\n## Overview\n\n**Topic:** System & Object Design\n**Subtopic:** Cache Design\n**Problems Available:** 50\n**Difficulty Range:** medium, hard\n\n---\n\n## What You'll Learn\n\nCache Design is fundamental to solving system & object design problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(1)**\n\n### Space Complexity\nTypical space requirement: **O(capacity)**\n\n### Common Tags\n`design`, `hash-map`, `linked-list`\n\n---\n\n## Starter Template\n\n```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        pass\n    \n    def get(self, key: int) -> int:\n        pass\n    \n    def put(self, key: int, value: int) -> None:\n        pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Cache Design 1 [Hard]\n\nDesign problem: cache-design.\n\n**Time:** O(O(1)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. Cache Design 5 [Hard]\n\nDesign problem: cache-design.\n\n**Time:** O(O(1)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. Cache Design 6 [Hard]\n\nDesign problem: cache-design.\n\n**Time:** O(O(1)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. Cache Design 7 [Hard]\n\nDesign problem: cache-design.\n\n**Time:** O(O(1)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. Cache Design 8 [Hard]\n\nDesign problem: cache-design.\n\n**Time:** O(O(1)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 29%\n- **Average Time:** 38 minutes per problem\n- **Total Points:** 1270 points available\n\n---\n\n## Next Steps\n\nAfter mastering Cache Design:\n\n1. Complete all 50 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Cache Design",
      "Cache Design",
      "System & Object Design"
    ],
    "problem_count": 50
  },
  {
    "family_id": "design-stream-processing-106",
    "title": "Stream Processing",
    "content": "# Stream Processing\n\nMaster Stream Processing - a key concept in System & Object Design.\n\n---\n\n## Overview\n\n**Topic:** System & Object Design\n**Subtopic:** Stream Processing\n**Problems Available:** 49\n**Difficulty Range:** medium, hard\n\n---\n\n## What You'll Learn\n\nStream Processing is fundamental to solving system & object design problems efficiently.\nThis microlesson covers:\n\n- Core concepts and theory\n- Common patterns and templates\n- Time and space complexity analysis\n- Practical problem-solving techniques\n\n---\n\n## Key Concepts\n\n### Time Complexity\nMost problems in this family: **O(1)**\n\n### Space Complexity\nTypical space requirement: **O(n)**\n\n### Common Tags\n`design`\n\n---\n\n## Starter Template\n\n```python\nclass Solution:\n    def __init__(self):\n        pass\n```\n\n---\n\n## Practice Problems\n\nWork through these problems in order to build mastery:\n\n### 1. Stream Processing 2 [Hard]\n\nDesign problem: stream-processing.\n\n**Time:** O(O(1)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 2. Stream Processing 3 [Hard]\n\nDesign problem: stream-processing.\n\n**Time:** O(O(1)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 3. Stream Processing 7 [Hard]\n\nDesign problem: stream-processing.\n\n**Time:** O(O(1)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 4. Stream Processing 8 [Hard]\n\nDesign problem: stream-processing.\n\n**Time:** O(O(1)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n### 5. Stream Processing 13 [Hard]\n\nDesign problem: stream-processing.\n\n**Time:** O(O(1)), **Space:** O(O(n))\n\n**Companies:** Various\n\n\n\n---\n\n## Success Metrics\n\n- **Average Success Rate:** 29%\n- **Average Time:** 37 minutes per problem\n- **Total Points:** 1240 points available\n\n---\n\n## Next Steps\n\nAfter mastering Stream Processing:\n\n1. Complete all 49 problems in this family\n2. Focus on optimizing your solutions\n3. Move to related concepts\n4. Practice timed problem-solving\n",
    "reading_time_minutes": 10,
    "key_concepts": [
      "Stream Processing",
      "Stream Processing",
      "System & Object Design"
    ],
    "problem_count": 49
  }
]