---
slug: linked-list-basics
title: Linked List Basics
sequence_order: 12
estimated_minutes: 15
difficulty: medium
key_concepts:
- Linked List Basics
- Node Definition
content_md: |
  # Linked List Basics

  Fundamental operations on singly linked lists

  ---

  ## Linked Lists

  A linked list is a linear data structure where elements are stored in nodes. Each node contains data and a pointer to the next node.

  **Types:**
  - Singly Linked List: One pointer (next)
  - Doubly Linked List: Two pointers (next, prev)
  - Circular Linked List: Last node points to first

  **Advantages:**
  - Dynamic size
  - Efficient insertions/deletions at beginning: O(1)
  - No memory waste

  **Disadvantages:**
  - No random access: O(n) to access element
  - Extra memory for pointers
  - Not cache-friendly

  **Complexity:**
  - Access: O(n)
  - Search: O(n)
  - Insert at head: O(1)
  - Insert at position: O(n)
  - Delete: O(n)


  ---

  ## Common Patterns

  ### Pattern 1: Node Definition
  ```python
  class ListNode:
      def __init__(self, val=0, next=None):
          self.val = val
          self.next = next
  ```

  ### Pattern 2: Traversal
  ```python
  def traverse(head):
      current = head
      while current:
          process(current.val)
          current = current.next
  ```

  ### Pattern 3: Insert at Beginning
  ```python
  def insert_at_head(head, val):
      new_node = ListNode(val)
      new_node.next = head
      return new_node  # New head
  ```

  ### Pattern 4: Delete Node
  ```python
  def delete_node(head, val):
      # Handle deletion at head
      if head and head.val == val:
          return head.next

      current = head
      while current and current.next:
          if current.next.val == val:
              current.next = current.next.next
              break
          current = current.next

      return head
  ```

  ### Pattern 5: Reverse Linked List
  ```python
  def reverse_list(head):
      prev = None
      current = head

      while current:
          next_temp = current.next  # Save next
          current.next = prev        # Reverse pointer
          prev = current             # Move prev forward
          current = next_temp        # Move current forward

      return prev  # New head
  ```

  ### Pattern 6: Find Middle (Fast & Slow Pointers)
  ```python
  def find_middle(head):
      slow = fast = head

      while fast and fast.next:
          slow = slow.next
          fast = fast.next.next

      return slow  # Middle node
  ```


  ---

  ## When to Use This Technique

  Use linked lists when: frequent insertions/deletions at beginning, size varies frequently, no random access needed, or implementing stacks/queues.

  ---

  ## Common Pitfalls to Avoid

  - Losing reference to head
  - Not handling null/empty list
  - Not updating pointers correctly during insertion/deletion
  - Memory leaks from not cleaning up nodes
  - Infinite loops from incorrect pointer updates
  - Not considering edge cases (single node, two nodes)

  ---

  ## Practice Problems

  Start with these problems to master this concept:

  ### 1. Reverse Linked List [Easy]

  Reverse a singly linked list.

  **Complexity:** Time O(O(n)), Space O(O(1))


  ### 2. Merge Two Sorted Lists [Easy]

  Merge two sorted linked lists.

  **Complexity:** Time O(O(n+m)), Space O(O(1))


  ### 3. Linked List Problem 3 [Easy]

  Linked list problem 3.

  **Complexity:** Time O(O(n)), Space O(O(1))


  ### 4. Linked List Problem 5 [Easy]

  Linked list problem 5.

  **Complexity:** Time O(O(n)), Space O(O(1))


  ### 5. Linked List Problem 15 [Easy]

  Linked list problem 15.

  **Complexity:** Time O(O(n)), Space O(O(1))



  ---

  ## Key Takeaways

  - Linked List Basics is essential for fundamental operations on singly linked lists
  - Time complexity improvements can be significant with this technique
  - Practice problems in order of difficulty to build intuition
  - Focus on recognizing patterns in problem statements
