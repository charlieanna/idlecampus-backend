slug: introduction-to-bash-and-shell-scripting
title: Introduction to Bash and Shell Scripting
sequence_order: 1
estimated_minutes: 2
difficulty: easy
key_concepts: []
content_md: "# Introduction to Bash and Shell Scripting \U0001F680\n\n# Introduction\
  \ to Bash and Shell Scripting\n\n    Bash (Bourne Again Shell) is the default shell\
  \ on most Linux and macOS systems. It's both a command-line interface and a powerful\
  \ scripting language.\n\n    ## What is a Shell?\n\n    A **shell** is a program\
  \ that:\n    - Provides an interface between the user and the operating system\n\
  \    - Interprets commands typed by the user\n    - Executes programs and scripts\n\
  \    - Manages input/output redirection\n\n    ### Types of Shells\n\n    | Shell\
  \ | Description |\n    |-------|-------------|\n    | **sh** | Bourne Shell (original)\
  \ |\n    | **bash** | Bourne Again Shell (most popular) |\n    | **zsh** | Z Shell\
  \ (macOS default since Catalina) |\n    | **fish** | Friendly Interactive Shell\
  \ |\n    | **ksh** | Korn Shell |\n    | **csh/tcsh** | C Shell / TENEX C Shell\
  \ |\n\n    ## Why Learn Bash?\n\n    ### 1. Automation\n    - Automate repetitive\
  \ tasks\n    - Schedule jobs with cron\n    - Batch process files\n    - System\
  \ maintenance scripts\n\n    ### 2. System Administration\n    - Manage users and\
  \ permissions\n    - Monitor system resources\n    - Configure services\n    - Deploy\
  \ applications\n\n    ### 3. DevOps & CI/CD\n    - Build and deployment scripts\n\
  \    - Infrastructure automation\n    - Docker and Kubernetes workflows\n    - Git\
  \ hooks\n\n    ### 4. Data Processing\n    - Parse log files\n    - Transform text\
  \ data\n    - ETL pipelines\n    - Report generation\n\n    ## Your First Shell\
  \ Script\n\n    ### Hello World\n\n    Create a file named `hello.sh`:\n\n    ```bash\n\
  \    #!/bin/bash\n    # My first shell script\n\n    echo \"Hello, World!\"\n  \
  \  ```\n\n    ### Make it Executable\n\n    ```bash\n    chmod +x hello.sh\n   \
  \ ```\n\n    ### Run it\n\n    ```bash\n    ./hello.sh\n    # Output: Hello, World!\n\
  \    ```\n\n    ## The Shebang (#!)\n\n    The first line `#!/bin/bash` is called\
  \ the **shebang**:\n\n    ```bash\n    #!/bin/bash         # Use bash\n    #!/bin/sh\
  \           # Use sh (POSIX shell)\n    #!/usr/bin/env bash # Use bash from PATH\
  \ (portable)\n    #!/usr/bin/python3  # Use Python 3\n    ```\n\n    **Best Practice:**\
  \ Use `#!/usr/bin/env bash` for portability.\n\n    ## Basic Commands\n\n    ###\
  \ Navigation\n\n    ```bash\n    pwd          # Print working directory\n    cd\
  \ /path     # Change directory\n    cd ~         # Go to home directory\n    cd\
  \ -         # Go to previous directory\n    ls           # List files\n    ls -la\
  \       # List all files (long format, including hidden)\n    ```\n\n    ### File\
  \ Operations\n\n    ```bash\n    touch file.txt       # Create empty file\n    mkdir\
  \ directory      # Create directory\n    mkdir -p dir1/dir2   # Create nested directories\n\
  \    cp file1 file2       # Copy file\n    cp -r dir1 dir2      # Copy directory\
  \ recursively\n    mv file1 file2       # Move/rename file\n    rm file.txt    \
  \      # Remove file\n    rm -r directory      # Remove directory recursively\n\
  \    rm -rf directory     # Force remove (be careful!)\n    ```\n\n    ### Viewing\
  \ Files\n\n    ```bash\n    cat file.txt         # Display entire file\n    less\
  \ file.txt        # View file page by page (q to quit)\n    head file.txt      \
  \  # Show first 10 lines\n    head -n 5 file.txt   # Show first 5 lines\n    tail\
  \ file.txt        # Show last 10 lines\n    tail -n 5 file.txt   # Show last 5 lines\n\
  \    tail -f log.txt      # Follow file (live updates)\n    ```\n\n    ### Searching\n\
  \n    ```bash\n    grep \"pattern\" file.txt          # Search for pattern\n   \
  \ grep -i \"pattern\" file.txt       # Case-insensitive search\n    grep -r \"pattern\"\
  \ directory/     # Recursive search\n    grep -n \"pattern\" file.txt       # Show\
  \ line numbers\n    find . -name \"*.txt\"             # Find files by name\n  \
  \  find . -type f -mtime -7         # Files modified in last 7 days\n    ```\n\n\
  \    ## Input and Output\n\n    ### Standard Streams\n\n    - **stdin (0)**: Standard\
  \ input (keyboard)\n    - **stdout (1)**: Standard output (terminal)\n    - **stderr\
  \ (2)**: Standard error (terminal)\n\n    ### Output with echo\n\n    ```bash\n\
  \    echo \"Hello\"              # Print to stdout\n    echo -n \"No newline\" \
  \     # No trailing newline\n    echo -e \"Line1\\\\nLine2\"   # Enable escape sequences\n\
  \    ```\n\n    ### Output with printf\n\n    ```bash\n    printf \"Hello, %s!\\\
  \\n\" \"World\"      # Formatted output\n    printf \"%d + %d = %d\\\\n\" 1 2 3\
  \      # Integer formatting\n    printf \"%.2f\\\\n\" 3.14159            # Float\
  \ with 2 decimals\n    ```\n\n    ## Redirection\n\n    ### Output Redirection\n\
  \n    ```bash\n    echo \"Hello\" > file.txt         # Overwrite file\n    echo\
  \ \"World\" >> file.txt        # Append to file\n    command 2> error.log      \
  \      # Redirect stderr\n    command > output.log 2>&1       # Redirect both stdout\
  \ and stderr\n    command &> all.log              # Redirect both (shorthand)\n\
  \    ```\n\n    ### Input Redirection\n\n    ```bash\n    command < input.txt  \
  \           # Read from file\n    cat < file.txt                  # Same as: cat\
  \ file.txt\n    ```\n\n    ### Here Documents\n\n    ```bash\n    cat << EOF\n \
  \   Line 1\n    Line 2\n    EOF\n    # Outputs multiple lines\n    ```\n\n    ###\
  \ Here Strings\n\n    ```bash\n    grep \"pattern\" <<< \"string to search\"\n \
  \   ```\n\n    ## Pipes\n\n    Pipes (`|`) connect the output of one command to\
  \ the input of another:\n\n    ```bash\n    ls -la | grep \".txt\"             \
  \  # List only .txt files\n    cat file.txt | sort | uniq         # Sort and remove\
  \ duplicates\n    ps aux | grep nginx                # Find nginx processes\n  \
  \  cat access.log | wc -l             # Count lines in file\n    ```\n\n    ###\
  \ Common Pipeline Patterns\n\n    ```bash\n    # Count files in directory\n    ls\
  \ | wc -l\n\n    # Top 10 largest files\n    du -sh * | sort -rh | head -10\n\n\
  \    # Find most common words\n    cat file.txt | tr ' ' '\\\\n' | sort | uniq -c\
  \ | sort -rn | head -10\n\n    # Monitor log file in real-time\n    tail -f /var/log/syslog\
  \ | grep error\n    ```\n\n    ## Command Substitution\n\n    Capture command output\
  \ in a variable:\n\n    ```bash\n    # Modern syntax (preferred)\n    current_date=$(date)\n\
  \    file_count=$(ls | wc -l)\n\n    # Old syntax (backticks)\n    current_date=`date`\n\
  \    file_count=`ls | wc -l`\n    ```\n\n    ### Example\n\n    ```bash\n    #!/bin/bash\n\
  \    echo \"Current user: $(whoami)\"\n    echo \"Current directory: $(pwd)\"\n\
  \    echo \"Number of files: $(ls | wc -l)\"\n    ```\n\n    ## Exit Status\n\n\
  \    Every command returns an **exit status** (0 = success, non-zero = error):\n\
  \n    ```bash\n    command\n    echo $?  # Print exit status of last command\n\n\
  \    # Common exit codes\n    # 0   = Success\n    # 1   = General error\n    #\
  \ 2   = Misuse of command\n    # 126 = Command not executable\n    # 127 = Command\
  \ not found\n    # 130 = Ctrl+C pressed\n    ```\n\n    ### Using Exit Status\n\n\
  \    ```bash\n    if ls /nonexistent 2>/dev/null; then\n        echo \"Directory\
  \ exists\"\n    else\n        echo \"Directory does not exist\"\n    fi\n\n    #\
  \ Short-circuit evaluation\n    command1 && command2  # Run command2 only if command1\
  \ succeeds\n    command1 || command2  # Run command2 only if command1 fails\n  \
  \  ```\n\n    ## Common Utilities\n\n    ### Text Processing\n\n    ```bash\n  \
  \  sort file.txt              # Sort lines\n    uniq file.txt              # Remove\
  \ adjacent duplicates\n    cut -d: -f1 /etc/passwd    # Extract first field (delimiter\
  \ :)\n    tr 'a-z' 'A-Z'             # Translate lowercase to uppercase\n    sed\
  \ 's/old/new/g' file     # Replace text\n    awk '{print $1}' file      # Print\
  \ first column\n    ```\n\n    ### File Information\n\n    ```bash\n    wc file.txt\
  \                # Count lines, words, bytes\n    wc -l file.txt             # Count\
  \ lines only\n    du -sh directory           # Disk usage\n    df -h           \
  \           # Filesystem disk space\n    file document.pdf          # Determine\
  \ file type\n    ```\n\n    ### Process Management\n\n    ```bash\n    ps aux  \
  \                   # List all processes\n    top                        # Interactive\
  \ process viewer\n    htop                       # Better alternative to top\n \
  \   kill <PID>                 # Send SIGTERM to process\n    kill -9 <PID>    \
  \          # Force kill process\n    killall process_name       # Kill all matching\
  \ processes\n    ```\n\n    ## Practical Examples\n\n    ### Example 1: Backup Script\n\
  \n    ```bash\n    #!/bin/bash\n    # Simple backup script\n\n    SOURCE=\"/home/user/documents\"\
  \n    DEST=\"/backup\"\n    DATE=$(date +%Y-%m-%d)\n\n    tar -czf \"$DEST/backup-$DATE.tar.gz\"\
  \ \"$SOURCE\"\n    echo \"Backup completed: backup-$DATE.tar.gz\"\n    ```\n\n \
  \   ### Example 2: System Information\n\n    ```bash\n    #!/bin/bash\n    # Display\
  \ system information\n\n    echo \"=== System Information ===\"\n    echo \"Hostname:\
  \ $(hostname)\"\n    echo \"OS: $(uname -s)\"\n    echo \"Kernel: $(uname -r)\"\n\
  \    echo \"Uptime: $(uptime -p)\"\n    echo \"Load Average: $(uptime | awk -F'load\
  \ average:' '{print $2}')\"\n    echo \"Disk Usage:\"\n    df -h | grep -v tmpfs\n\
  \    ```\n\n    ### Example 3: Log Analyzer\n\n    ```bash\n    #!/bin/bash\n  \
  \  # Analyze nginx access log\n\n    LOG_FILE=\"/var/log/nginx/access.log\"\n\n\
  \    echo \"Top 10 IP addresses:\"\n    awk '{print $1}' \"$LOG_FILE\" | sort |\
  \ uniq -c | sort -rn | head -10\n\n    echo \"\"\n    echo \"Top 10 requested URLs:\"\
  \n    awk '{print $7}' \"$LOG_FILE\" | sort | uniq -c | sort -rn | head -10\n\n\
  \    echo \"\"\n    echo \"HTTP status codes:\"\n    awk '{print $9}' \"$LOG_FILE\"\
  \ | sort | uniq -c | sort -rn\n    ```\n\n    ## Best Practices\n\n    ### 1. Always\
  \ Use Shebang\n\n    ```bash\n    #!/usr/bin/env bash\n    ```\n\n    ### 2. Add\
  \ Comments\n\n    ```bash\n    # This script does something important\n    # Author:\
  \ Your Name\n    # Date: 2024-01-01\n    ```\n\n    ### 3. Quote Variables\n\n \
  \   ```bash\n    # ❌ Bad - can break with spaces\n    echo $variable\n\n    # ✅\
  \ Good\n    echo \"$variable\"\n    ```\n\n    ### 4. Use `set -e`\n\n    Exit immediately\
  \ if any command fails:\n\n    ```bash\n    #!/bin/bash\n    set -e  # Exit on error\n\
  \n    mkdir /path/to/dir\n    cd /path/to/dir\n    # If mkdir fails, script stops\n\
  \    ```\n\n    ### 5. Use `set -u`\n\n    Treat unset variables as errors:\n\n\
  \    ```bash\n    #!/bin/bash\n    set -u  # Error on undefined variable\n\n   \
  \ echo \"$undefined_var\"  # This will cause an error\n    ```\n\n    ### 6. Use\
  \ `set -x`\n\n    Print commands before executing (debugging):\n\n    ```bash\n\
  \    #!/bin/bash\n    set -x  # Debug mode\n\n    echo \"Hello\"\n    # Output:\
  \ + echo Hello\n    #         Hello\n    ```\n\n    ### Combine Options\n\n    ```bash\n\
  \    #!/bin/bash\n    set -euo pipefail  # Exit on error, undefined var, pipe failure\n\
  \    ```\n\n    ## Key Takeaways\n\n    1. **Bash is powerful** - Automate tasks,\
  \ manage systems\n    2. **Shebang matters** - Use `#!/usr/bin/env bash`\n    3.\
  \ **Pipes are your friend** - Chain commands together\n    4. **Quote variables**\
  \ - Prevent word splitting and globbing\n    5. **Check exit status** - Use `$?`\
  \ or `&&` / `||`\n    6. **Use set options** - `set -euo pipefail` for robust scripts\n\
  \    7. **Learn core utilities** - grep, sed, awk, find, etc.\n    8. **Practice\
  \ regularly** - The more you use it, the better you get"
exercises:
- type: terminal
  slug: introduction-to-bash-and-shell-scripting-term
  sequence_order: 1
  description: Create and run a simple bash script
  command: echo '#!/bin/bash' > hello.sh && echo 'echo "Hello, World!"' >> hello.sh && chmod +x hello.sh && ./hello.sh
  validation:
    must_not_include:
    - No such file
    - Permission denied
    - command not found
  hints:
  - The shebang #!/bin/bash tells the system to use bash to run the script
  - Use chmod +x to make the script executable
  - Run with ./scriptname.sh
  timeout_sec: 60
  require_pass: true
- type: mcq
  slug: introduction-to-bash-and-shell-scripting-mcq
  sequence_order: 2
  question: What does the shebang line #!/bin/bash do at the start of a script?
  options:
  - Tells the system to use bash to execute the script
  - Comments out the first line
  - Sets the script version
  - Defines the script name
  correct_answer_index: 0
  explanation: The shebang (#!/bin/bash) specifies which interpreter should execute the script, in this case the bash shell
  require_pass: true
- type: mcq
  slug: introduction-to-bash-and-shell-scripting-mcq-2
  sequence_order: 3
  question: How do you make a bash script executable?
  options:
  - chmod +x scriptname.sh
  - make executable scriptname.sh
  - exec scriptname.sh
  - run scriptname.sh
  correct_answer_index: 0
  explanation: chmod +x adds execute permissions to the file, allowing it to be run as a program
  require_pass: true
- type: mcq
  slug: introduction-to-bash-and-shell-scripting-mcq-3
  sequence_order: 4
  question: In bash, what symbol is used to access the value of a variable?
  options:
  - $variablename
  - variablename
  - @variablename
  - &variablename
  correct_answer_index: 0
  explanation: The $ symbol is used to reference/expand variables in bash (e.g., $HOME, $USER, $myvar)
  require_pass: true
- type: reflection
  slug: introduction-to-bash-and-shell-scripting-reflect
  sequence_order: 5
  prompt: Think of a repetitive task you do regularly. How could you automate it with a bash script? What commands would you need?
- type: checkpoint
  slug: introduction-to-bash-and-shell-scripting-checkpoint
  sequence_order: 6
  prompt: Write a bash script that creates a backup directory, copies files to it, and displays a success message. Include the shebang, variables, and error handling.
objectives:
- Write and execute basic bash scripts with shebang
- Use variables, conditionals, and loops in scripts
- Understand script permissions and execution
- Apply exit codes and error handling
next_recommended:
- lesson-1
- docker-run-creating-and-starting-containers
