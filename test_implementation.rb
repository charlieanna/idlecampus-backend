\n#!/usr/bin/env ruby\n\n# Load Rails environment\nENV['RAILS_ENV'] ||= 'development'\nrequire_relative 'config/environment'\n\nclass ImplementationTest\n  def initialize\n    @user = User.first || create_test_user\n    @results = []\n  end\n\n  def run_tests\n    puts \"\\n\" + \"=\"*80\n    puts \"COMPLETE IMPLEMENTATION TEST\"\n    puts \"Testing Phase 3, Phase 4, and Autonomous Learning System\"\n    puts \"=\"*80 + \"\\n\"\n\n    test_phase3_components\n    test_phase4_components  \n    test_autonomous_learning\n    test_integration\n    \n    print_summary\n  end\n\n  private\n\n  def test_phase3_components\n    puts \"\\n[Phase 3] Testing Intelligent Mastery Decay...\"\n    \n    # Test MasteryDecayService\n    print \"  • MasteryDecayService... \"\n    begin\n      service = MasteryDecayService.new(@user)\n      \n      mastery = CommandMastery.create!(\n        user: @user,\n        canonical_command: 'docker run',\n        mastery_score: 100,\n        last_practiced_at: 7.days.ago\n      )\n      \n      decayed_score = service.calculate_decay(mastery)\n      if decayed_score < 100 && decayed_score >= 40\n        puts \"✓ (Score: 100 → #{decayed_score.round(1)})\"\n        @results << { test: \"MasteryDecayService\", status: :passed }\n      else\n        puts \"✗ Invalid decay calculation\"\n        @results << { test: \"MasteryDecayService\", status: :failed }\n      end\n    rescue => e\n      puts \"✗ Error: #{e.message}\"\n      @results << { test: \"MasteryDecayService\", status: :failed, error: e.message }\n    end\n    \n    # Test StealthReviewGenerator\n    print \"  • StealthReviewGenerator... \"\n    begin\n      generator = StealthReviewGenerator.new(@user)\n      reviews = generator.generate_reviews(3)\n      \n      if reviews.any? && reviews.all? { |r| r.is_a?(StealthReview) }\n        puts \"✓ (Generated #{reviews.count} reviews)\"\n        @results << { test: \"StealthReviewGenerator\", status: :passed }\n      else\n        puts \"✗ Failed to generate reviews\"\n        @results << { test: \"StealthReviewGenerator\", status: :failed }\n      end\n    rescue => e\n      puts \"✗ Error: #{e.message}\"\n      @results << { test: \"StealthReviewGenerator\", status: :failed, error: e.message }\n    end\n    \n    # Test API Controller\n    print \"  • API Endpoints... \"\n    begin\n      # Check if routes exist\n      if Rails.application.routes.url_helpers.respond_to?(:api_mastery_decay_visualization_path)\n        puts \"✓ (Routes configured)\"\n        @results << { test: \"API Endpoints\", status: :passed }\n      else\n        puts \"✗ Routes not found\"\n        @results << { test: \"API Endpoints\", status: :failed }\n      end\n    rescue => e\n      puts \"✗ Error: #{e.message}\"\n      @results << { test: \"API Endpoints\", status: :failed, error: e.message }\n    end\n  end\n\n  def test_phase4_components\n    puts \"\\n[Phase 4] Testing Docker-in-Docker Lab Execution...\"\n    \n    # Test LabRunnerService\n    print \"  • LabRunnerService... \"\n    begin\n      lab = HandsOnLab.create!(\n        title: \"Test Lab\",\n        docker_compose: \"version: '3'\\nservices:\\n  web:\\n    image: nginx\",\n        validation_script: \"docker ps | grep nginx\"\n      )\n      \n      service = LabRunnerService.new(@user, lab)\n      prefix = service.send(:generate_resource_prefix)\n      \n      if prefix.match(/^lab-\\w{8}-user-\\d+$/)\n        puts \"✓ (Prefix: #{prefix})\"\n        @results << { test: \"LabRunnerService\", status: :passed }\n      else\n        puts \"✗ Invalid prefix format\"\n        @results << { test: \"LabRunnerService\", status: :failed }\n      end\n    rescue => e\n      puts \"✗ Error: #{e.message}\"\n      @results << { test: \"LabRunnerService\", status: :failed, error: e.message }\n    end\n    \n    # Test ActionCable Channel\n    print \"  • LabExecutionChannel... \"\n    begin\n      if defined?(LabExecutionChannel)\n        puts \"✓ (Channel defined)\"\n        @results << { test: \"LabExecutionChannel\", status: :passed }\n      else\n        puts \"✗ Channel not found\"\n        @results << { test: \"LabExecutionChannel\", status: :failed }\n      end\n    rescue => e\n      puts \"✗ Error: #{e.message}\"\n      @results << { test: \"LabExecutionChannel\", status: :failed, error: e.message }\n    end\n    \n    # Test ResourceCleanupJob\n    print \"  • ResourceCleanupJob... \"\n    begin\n      job = ResourceCleanupJob.perform_later(@user.id, \"test-prefix\")\n      if job.job_id.present?\n        puts \"✓ (Job ID: #{job.job_id[0..7]}...)\"\n        @results << { test: \"ResourceCleanupJob\", status: :passed }\n      else\n        puts \"✗ Job not enqueued\"\n        @results << { test: \"ResourceCleanupJob\", status: :failed }\n      end\n    rescue => e\n      puts \"✗ Error: #{e.message}\"\n      @results << { test: \"ResourceCleanupJob\", status: :failed, error: e.message }\n    end\n  end\n\n  def test_autonomous_learning\n    puts \"\\n[Autonomous Learning] Testing Zero Navigation System...\"\n    \n    # Test Routes\n    print \"  • Single /learn endpoint... \"\n    begin\n      if Rails.application.routes.url_helpers.respond_to?(:learn_path)\n        puts \"✓ (Route: #{Rails.application.routes.url_helpers.learn_path})\"\n        @results << { test: \"/learn endpoint\", status: :passed }\n      else\n        puts \"✗ Route not found\"\n        @results << { test: \"/learn endpoint\", status: :failed }\n      end\n    rescue => e\n      puts \"✗ Error: #{e.message}\"\n      @results << { test: \"/learn endpoint\", status: :failed, error: e.message }\n    end\n    \n    # Test LearningSession Model\n    print \"  • LearningSession Model... \"\n    begin\n      session = LearningSession.create_for_user!(@user)\n      if session.persisted? && session.session_id.present?\n        puts \"✓ (Session: #{session.session_id})\"\n        @results << { test: \"LearningSession\", status: :passed }\n        \n        # Test state management\n        session.update_state('test_key', 'test_value')\n        if session.get_state('test_key') == 'test_value'\n          @results << { test: \"Session State\", status: :passed }\n        end\n      else\n        puts \"✗ Failed to create session\"\n        @results << { test: \"LearningSession\", status: :failed }\n      end\n    rescue => e\n      puts \"✗ Error: #{e.message}\"\n      @results << { test: \"LearningSession\", status: :failed, error: e.message }\n    end\n    \n    # Test old route redirects\n    print \"  • Old route redirects... \"\n    begin\n      routes = Rails.application.routes.routes\n      redirect_count = 0\n      routes.each do |route|\n        if route.app.is_a?(ActionDispatch::Routing::Redirect)\n          redirect_count += 1\n        end\n      end\n      \n      if redirect_count > 0\n        puts \"✓ (#{redirect_count} redirects configured)\"\n        @results << { test: \"Route Redirects\", status: :passed }\n      else\n        puts \"✗ No redirects found\"\n        @results << { test: \"Route Redirects\", status: :failed }\n      end\n    rescue => e\n      puts \"✗ Error: #{e.message}\"\n      @results << { test: \"Route Redirects\", status: :failed, error: e.message }\n    end\n  end\n\n  def test_integration\n    puts \"\\n[Integration] Testing Complete System...\"\n    \n    print \"  • End-to-end flow... \"\n    begin\n      # Create session\n      session = LearningSession.find_or_create_active(@user)\n      \n      # Record some responses\n      session.record_response('item_1', true, 2.5)\n      session.record_response('item_2', false, 3.1)\n      session.record_response('item_3', true,